{
    "location": "dojo/_base/Deferred",
    "type": "function",
    "parameters": [
        {
            "name": "canceller",
            "types": [
                "Function"
            ],
            "usage": "optional"
        }
    ],
    "returnTypes": [],
    "summary": "<p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.\nNew code should use dojo/Deferred instead.</p>\n",
    "description": "<p>The Deferred API is based on the concept of promises that provide a\ngeneric interface into the eventual completion of an asynchronous action.\nThe motivation for promises fundamentally is about creating a\nseparation of concerns that allows one to achieve the same type of\ncall patterns and logical data flow in asynchronous code as can be\nachieved in synchronous code. Promises allows one\nto be able to call a function purely with arguments needed for\nexecution, without conflating the call with concerns of whether it is\nsync or async. One shouldn&#39;t need to alter a call&#39;s arguments if the\nimplementation switches from sync to async (or vice versa). By having\nasync functions return promises, the concerns of making the call are\nseparated from the concerns of asynchronous interaction (which are\nhandled by the promise).\n\n</p>\n<p>The Deferred is a type of promise that provides methods for fulfilling the\npromise with a successful result or an error. The most important method for\nworking with Dojo&#39;s promises is the then() method, which follows the\nCommonJS proposed promise API. An example of using a Dojo promise:\n\n\n</p>\nvar resultingPromise = someAsyncOperation.then(function(result){\n    ... handle result ...\n},\nfunction(error){\n    ... handle error ...\n});\n<p>The .then() call returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.\n\n</p>\n<p>The Deferred instances also provide the following functions for backwards compatibility:\n\n</p>\n<ul>\n<li>addCallback(handler)</li>\n<li>addErrback(handler)</li>\n<li>callback(result)</li>\n<li>errback(result)</li>\n</ul>\n<p>Callbacks are allowed to return promises themselves, so\nyou can build complicated sequences of events with ease.\n\n</p>\n<p>The creator of the Deferred may specify a canceller.  The canceller\nis a function that will be called if Deferred.cancel is called\nbefore the Deferred fires. You can use this to implement clean\naborting of an XMLHttpRequest, etc. Note that cancel will fire the\ndeferred with a CancelledError (unless your canceller returns\nanother kind of error), so the errbacks should be prepared to\nhandle that error for cancellable Deferreds.</p>\n",
    "examples": [
        "var deferred = new Deferred();\nsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\nreturn deferred;\n",
        "<p>Deferred objects are often used when making code asynchronous. It\nmay be easiest to write functions in a synchronous manner and then\nsplit code using a deferred to trigger a response to a long-lived\noperation. For example, instead of register a callback function to\ndenote when a rendering operation completes, the function can\nsimply return a deferred:\n\n\n</p>\n// callback style:\nfunction renderLotsOfData(data, callback){\n    var success = false\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        success = true;\n    }catch(e){ }\n    if(callback){\n        callback(success);\n    }\n}\n\n\n// using callback style\nrenderLotsOfData(someDataObj, function(success){\n    // handles success or failure\n    if(!success){\n        promptUserToRecover();\n    }\n});\n// NOTE: no way to add another callback here!!\n",
        "<p>Using a Deferred doesn&#39;t simplify the sending code any, but it\nprovides a standard interface for callers and senders alike,\nproviding both with a simple way to service multiple callbacks for\nan operation and freeing both sides from worrying about details\nsuch as &quot;did this get called already?&quot;. With Deferreds, new\ncallbacks can be added at any time.\n\n\n</p>\n// Deferred style:\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        d.callback(true);\n    }catch(e){\n        d.errback(new Error(&quot;rendering failed&quot;));\n    }\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n// NOTE: addErrback and addCallback both return the Deferred\n// again, so we could chain adding callbacks or save the\n// deferred for later should we need to be notified again.\n",
        "<p>In this example, renderLotsOfData is synchronous and so both\nversions are pretty artificial. Putting the data display on a\ntimeout helps show why Deferreds rock:\n\n\n</p>\n// Deferred style and async func\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    setTimeout(function(){\n        try{\n            for(var x in data){\n                renderDataitem(data[x]);\n            }\n            d.callback(true);\n        }catch(e){\n            d.errback(new Error(&quot;rendering failed&quot;));\n        }\n    }, 100);\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n<p>Note that the caller doesn&#39;t have to change his code at all to\nhandle the asynchronous case.</p>\n"
    ],
    "properties": [
        {
            "name": "fired",
            "scope": "prototype",
            "types": [
                "number"
            ],
            "from": "dojo/_base/Deferred"
        },
        {
            "name": "promise",
            "scope": "normal",
            "types": [
                "instance"
            ],
            "from": "dojo/_base/Deferred"
        }
    ],
    "methods": [
        {
            "name": "addBoth",
            "scope": "prototype",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "callback",
                    "types": [
                        "Function"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [
                "any",
                "undefined"
            ],
            "returnDescription": "<p>Returns this deferred object.</p>\n",
            "summary": "<p>Add handler as both successful callback and error callback for this deferred instance.</p>\n"
        },
        {
            "name": "addCallback",
            "scope": "prototype",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "callback",
                    "types": [
                        "Function"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [
                "any",
                "undefined"
            ],
            "returnDescription": "<p>Returns this deferred object.</p>\n",
            "summary": "<p>Adds successful callback for this deferred instance.</p>\n"
        },
        {
            "name": "addCallbacks",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "callback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional",
                    "summary": "<p>The callback attached to this deferred object.</p>\n"
                },
                {
                    "name": "errback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional",
                    "summary": "<p>The error callback attached to this deferred object.</p>\n"
                }
            ],
            "returnTypes": [
                "any"
            ],
            "returnDescription": "<p>Returns this deferred object.</p>\n",
            "summary": "<p>Adds callback and error callback for this deferred instance.</p>\n"
        },
        {
            "name": "addErrback",
            "scope": "prototype",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "errback",
                    "types": [
                        "Function"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [
                "any",
                "undefined"
            ],
            "returnDescription": "<p>Returns this deferred object.</p>\n",
            "summary": "<p>Adds error callback for this deferred instance.</p>\n"
        },
        {
            "name": "callback",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "value",
                    "types": [
                        "undefined"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Fulfills the Deferred instance successfully with the provide value</p>\n"
        },
        {
            "name": "cancel",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [],
            "returnTypes": [],
            "summary": "<p>Cancels the asynchronous operation</p>\n"
        },
        {
            "name": "constructor",
            "scope": "prototype",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "canceller",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.\nNew code should use dojo/Deferred instead.</p>\n",
            "description": "<p>The Deferred API is based on the concept of promises that provide a\ngeneric interface into the eventual completion of an asynchronous action.\nThe motivation for promises fundamentally is about creating a\nseparation of concerns that allows one to achieve the same type of\ncall patterns and logical data flow in asynchronous code as can be\nachieved in synchronous code. Promises allows one\nto be able to call a function purely with arguments needed for\nexecution, without conflating the call with concerns of whether it is\nsync or async. One shouldn&#39;t need to alter a call&#39;s arguments if the\nimplementation switches from sync to async (or vice versa). By having\nasync functions return promises, the concerns of making the call are\nseparated from the concerns of asynchronous interaction (which are\nhandled by the promise).\n\n</p>\n<p>The Deferred is a type of promise that provides methods for fulfilling the\npromise with a successful result or an error. The most important method for\nworking with Dojo&#39;s promises is the then() method, which follows the\nCommonJS proposed promise API. An example of using a Dojo promise:\n\n\n</p>\nvar resultingPromise = someAsyncOperation.then(function(result){\n    ... handle result ...\n},\nfunction(error){\n    ... handle error ...\n});\n<p>The .then() call returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.\n\n</p>\n<p>The Deferred instances also provide the following functions for backwards compatibility:\n\n</p>\n<ul>\n<li>addCallback(handler)</li>\n<li>addErrback(handler)</li>\n<li>callback(result)</li>\n<li>errback(result)</li>\n</ul>\n<p>Callbacks are allowed to return promises themselves, so\nyou can build complicated sequences of events with ease.\n\n</p>\n<p>The creator of the Deferred may specify a canceller.  The canceller\nis a function that will be called if Deferred.cancel is called\nbefore the Deferred fires. You can use this to implement clean\naborting of an XMLHttpRequest, etc. Note that cancel will fire the\ndeferred with a CancelledError (unless your canceller returns\nanother kind of error), so the errbacks should be prepared to\nhandle that error for cancellable Deferreds.</p>\n",
            "examples": [
                "var deferred = new Deferred();\nsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\nreturn deferred;\n",
                "<p>Deferred objects are often used when making code asynchronous. It\nmay be easiest to write functions in a synchronous manner and then\nsplit code using a deferred to trigger a response to a long-lived\noperation. For example, instead of register a callback function to\ndenote when a rendering operation completes, the function can\nsimply return a deferred:\n\n\n</p>\n// callback style:\nfunction renderLotsOfData(data, callback){\n    var success = false\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        success = true;\n    }catch(e){ }\n    if(callback){\n        callback(success);\n    }\n}\n\n\n// using callback style\nrenderLotsOfData(someDataObj, function(success){\n    // handles success or failure\n    if(!success){\n        promptUserToRecover();\n    }\n});\n// NOTE: no way to add another callback here!!\n",
                "<p>Using a Deferred doesn&#39;t simplify the sending code any, but it\nprovides a standard interface for callers and senders alike,\nproviding both with a simple way to service multiple callbacks for\nan operation and freeing both sides from worrying about details\nsuch as &quot;did this get called already?&quot;. With Deferreds, new\ncallbacks can be added at any time.\n\n\n</p>\n// Deferred style:\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        d.callback(true);\n    }catch(e){\n        d.errback(new Error(&quot;rendering failed&quot;));\n    }\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n// NOTE: addErrback and addCallback both return the Deferred\n// again, so we could chain adding callbacks or save the\n// deferred for later should we need to be notified again.\n",
                "<p>In this example, renderLotsOfData is synchronous and so both\nversions are pretty artificial. Putting the data display on a\ntimeout helps show why Deferreds rock:\n\n\n</p>\n// Deferred style and async func\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    setTimeout(function(){\n        try{\n            for(var x in data){\n                renderDataitem(data[x]);\n            }\n            d.callback(true);\n        }catch(e){\n            d.errback(new Error(&quot;rendering failed&quot;));\n        }\n    }, 100);\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n<p>Note that the caller doesn&#39;t have to change his code at all to\nhandle the asynchronous case.</p>\n"
            ]
        },
        {
            "name": "errback",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "error",
                    "types": [
                        "undefined"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Fulfills the Deferred instance as an error with the provided error</p>\n"
        },
        {
            "name": "isCanceled",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [],
            "returnTypes": [
                "Boolean"
            ],
            "summary": "<p>Checks whether the deferred has been canceled.</p>\n"
        },
        {
            "name": "isFulfilled",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [],
            "returnTypes": [
                "Boolean"
            ],
            "summary": "<p>Checks whether the deferred has been resolved or rejected.</p>\n"
        },
        {
            "name": "isRejected",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [],
            "returnTypes": [
                "Boolean"
            ],
            "summary": "<p>Checks whether the deferred has been rejected.</p>\n"
        },
        {
            "name": "isResolved",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [],
            "returnTypes": [
                "Boolean"
            ],
            "summary": "<p>Checks whether the deferred has been resolved.</p>\n"
        },
        {
            "name": "progress",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "update",
                    "types": [
                        "undefined"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Send progress events to all listeners</p>\n"
        },
        {
            "name": "reject",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "error",
                    "types": [
                        "undefined"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Fulfills the Deferred instance as an error with the provided error</p>\n"
        },
        {
            "name": "resolve",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "value",
                    "types": [
                        "undefined"
                    ],
                    "usage": "required"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Fulfills the Deferred instance successfully with the provide value</p>\n"
        },
        {
            "name": "then",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/Deferred",
            "parameters": [
                {
                    "name": "resolvedCallback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional"
                },
                {
                    "name": "errorCallback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional"
                },
                {
                    "name": "progressCallback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional"
                }
            ],
            "returnTypes": [
                "any"
            ],
            "returnDescription": "<p>Returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.</p>\n",
            "summary": "<p>Adds a fulfilledHandler, errorHandler, and progressHandler to be called for\ncompletion of a promise. The fulfilledHandler is called when the promise\nis fulfilled. The errorHandler is called when a promise fails. The\nprogressHandler is called for progress events. All arguments are optional\nand non-function values are ignored. The progressHandler is not only an\noptional argument, but progress events are purely optional. Promise\nproviders are not required to ever create progress events.\n\n</p>\n<p>This function will return a new promise that is fulfilled when the given\nfulfilledHandler or errorHandler callback is finished. This allows promise\noperations to be chained together. The value returned from the callback\nhandler is the fulfillment value for the returned promise. If the callback\nthrows an error, the returned promise will be moved to failed state.\n</p>\n",
            "examples": [
                "<p>An example of using a CommonJS compliant promise:\n\n</p>\nasyncComputeTheAnswerToEverything().\n    then(addTwo).\n    then(printResult, onError);\n&gt;44\n"
            ]
        },
        {
            "name": "when",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/when",
            "parameters": [
                {
                    "name": "valueOrPromise",
                    "types": [
                        "undefined"
                    ],
                    "usage": "required",
                    "summary": "<p>Either a regular value or an object with a <code>then()</code> method that\nfollows the Promises/A specification.</p>\n"
                },
                {
                    "name": "callback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional",
                    "summary": "<p>Callback to be invoked when the promise is resolved, or a non-promise\nis received.</p>\n"
                },
                {
                    "name": "errback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional",
                    "summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
                },
                {
                    "name": "progback",
                    "types": [
                        "Function"
                    ],
                    "usage": "optional",
                    "summary": "<p>Callback to be invoked when the promise emits a progress update.</p>\n"
                }
            ],
            "returnTypes": [
                "dojo/promise/Promise",
                "undefined"
            ],
            "returnDescription": "<p>Promise, or if a callback is provided, the result of the callback.</p>\n",
            "summary": "<p>Transparently applies callbacks to values and/or promises.</p>\n",
            "description": "<p>Accepts promises but also transparently handles non-promises. If no\ncallbacks are provided returns a promise, regardless of the initial\nvalue. Foreign promises are converted.\n\n</p>\n<p>If callbacks are provided and the initial value is not a promise,\nthe callback is executed immediately with no error handling. Returns\na promise if the initial value is a promise, or the result of the\ncallback otherwise.</p>\n"
        }
    ],
    "apiPath": "../../",
    "shortName": "Deferred"
}