{
    "location": "dojo/_base/declare.__DeclareCreatedObject",
    "type": "object",
    "summary": "<p>dojo/_base/declare() returns a constructor <code>C</code>.   <code>new C()</code> returns an Object with the following\nmethods, in addition to the methods and properties specified via the arguments passed to declare().</p>\n",
    "methods": [
        {
            "name": "createSubclass",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "mixins",
                    "types": [
                        "Function[]"
                    ],
                    "usage": "required",
                    "summary": "<p>Specifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
                },
                {
                    "name": "props",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>An optional object whose properties are copied to the created prototype.</p>\n"
                }
            ],
            "returnTypes": [
                "dojo/_base/declare.__DeclareCreatedObject"
            ],
            "returnDescription": "<p>New constructor function.</p>\n",
            "summary": "<p>Create a subclass of the declared class from a list of base classes.</p>\n",
            "description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n</p>\n",
            "examples": [
                "<pre><code>var A = declare(null, {\n    m1: function(){},\n    s1: &quot;bar&quot;\n});\nvar B = declare(null, {\n    m2: function(){},\n    s2: &quot;foo&quot;\n});\nvar C = declare(null, {\n});\nvar D1 = A.createSubclass([B, C], {\n    m1: function(){},\n    d1: 42\n});\nvar d1 = new D1();\n\n// this is equivalent to:\nvar D2 = declare([A, B, C], {\n    m1: function(){},\n    d1: 42\n});\nvar d2 = new D2();</code></pre>\n"
            ]
        },
        {
            "name": "extend",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "source",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>Source object which properties are going to be copied to the\nconstructor&#39;s prototype.</p>\n"
                }
            ],
            "returnTypes": [],
            "summary": "<p>Adds all properties and methods of source to constructor&#39;s\nprototype, making them available to all instances created with\nconstructor. This method is specific to constructors created with\ndeclare().</p>\n",
            "description": "<p>Adds source properties to the constructor&#39;s prototype. It can\noverride existing properties.\n\n</p>\n<p>This method is similar to dojo.extend function, but it is specific\nto constructors produced by declare(). It is implemented\nusing dojo.safeMixin, and it skips a constructor property,\nand properly decorates copied functions.\n</p>\n",
            "examples": [
                "<pre><code>var A = declare(null, {\n    m1: function(){},\n    s1: &quot;Popokatepetl&quot;\n});\nA.extend({\n    m1: function(){},\n    m2: function(){},\n    f1: true,\n    d1: 42\n});</code></pre>\n"
            ]
        },
        {
            "name": "getInherited",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "name",
                    "types": [
                        "String"
                    ],
                    "usage": "optional",
                    "summary": "<p>The optional method name. Should be the same as the caller&#39;s\nname. Usually &quot;name&quot; is specified in complex dynamic cases, when\nthe calling method was dynamically added, undecorated by\ndeclare(), and it cannot be determined.</p>\n"
                },
                {
                    "name": "args",
                    "types": [
                        "Arguments"
                    ],
                    "usage": "required",
                    "summary": "<p>The caller supply this argument, which should be the original\n&quot;arguments&quot;.</p>\n"
                }
            ],
            "returnTypes": [
                "any",
                "object"
            ],
            "returnDescription": "<p>Returns a super method (Function) or &quot;undefined&quot;.</p>\n",
            "summary": "<p>Returns a super method.</p>\n",
            "description": "<p>This method is a convenience method for &quot;this.inherited()&quot;.\nIt uses the same algorithm but instead of executing a super\nmethod, it returns it, or &quot;undefined&quot; if not found.\n</p>\n",
            "examples": [
                "<pre><code>var B = declare(A, {\n    method: function(a, b){\n        var super = this.getInherited(arguments);\n        // ...\n        if(!super){\n            console.log(&quot;there is no super method&quot;);\n            return 0;\n        }\n        return super.apply(this, arguments);\n    }\n});</code></pre>\n"
            ]
        },
        {
            "name": "inherited",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "name",
                    "types": [
                        "String"
                    ],
                    "usage": "optional",
                    "summary": "<p>The optional method name. Should be the same as the caller&#39;s\nname. Usually &quot;name&quot; is specified in complex dynamic cases, when\nthe calling method was dynamically added, undecorated by\ndeclare(), and it cannot be determined.</p>\n"
                },
                {
                    "name": "args",
                    "types": [
                        "Arguments"
                    ],
                    "usage": "required",
                    "summary": "<p>The caller supply this argument, which should be the original\n&quot;arguments&quot;.</p>\n"
                },
                {
                    "name": "newArgs",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>If &quot;true&quot;, the found function will be returned without\nexecuting it.\nIf Array, it will be used to call a super method. Otherwise\n&quot;args&quot; will be used.</p>\n"
                }
            ],
            "returnTypes": [
                "any",
                "object"
            ],
            "returnDescription": "<p>Whatever is returned by a super method, or a super method itself,\nif &quot;true&quot; was specified as newArgs.</p>\n",
            "summary": "<p>Calls a super method.</p>\n",
            "description": "<p>This method is used inside method of classes produced with\ndeclare() to call a super method (next in the chain). It is\nused for manually controlled chaining. Consider using the regular\nchaining, because it is faster. Use &quot;this.inherited()&quot; only in\ncomplex cases.\n\n</p>\n<p>This method cannot me called from automatically chained\nconstructors including the case of a special (legacy)\nconstructor chaining. It cannot be called from chained methods.\n\n</p>\n<p>If &quot;this.inherited()&quot; cannot find the next-in-chain method, it\ndoes nothing and returns &quot;undefined&quot;. The last method in chain\ncan be a default method implemented in Object, which will be\ncalled last.\n\n</p>\n<p>If &quot;name&quot; is specified, it is assumed that the method that\nreceived &quot;args&quot; is the parent method for this call. It is looked\nup in the chain list and if it is found the next-in-chain method\nis called. If it is not found, the first-in-chain method is\ncalled.\n\n</p>\n<p>If &quot;name&quot; is not specified, it will be derived from the calling\nmethod (using a methoid property &quot;nom&quot;).\n</p>\n",
            "examples": [
                "<pre><code>var B = declare(A, {\n    method1: function(a, b, c){\n        this.inherited(arguments);\n    },\n    method2: function(a, b){\n        return this.inherited(arguments, [a + b]);\n    }\n});\n// next method is not in the chain list because it is added\n// manually after the class was created.\nB.prototype.method3 = function(){\n    console.log(&quot;This is a dynamically-added method.&quot;);\n    this.inherited(&quot;method3&quot;, arguments);\n};</code></pre>\n",
                "<pre><code>var B = declare(A, {\n    method: function(a, b){\n        var super = this.inherited(arguments, true);\n        // ...\n        if(!super){\n            console.log(&quot;there is no super method&quot;);\n            return 0;\n        }\n        return super.apply(this, arguments);\n    }\n});</code></pre>\n"
            ]
        },
        {
            "name": "isInstanceOf",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "cls",
                    "types": [
                        "Function"
                    ],
                    "usage": "required",
                    "summary": "<p>Class constructor.</p>\n"
                }
            ],
            "returnTypes": [
                "any",
                "object"
            ],
            "returnDescription": "<p>&quot;true&quot;, if this object is inherited from this class, &quot;false&quot;\notherwise.</p>\n",
            "summary": "<p>Checks the inheritance chain to see if it is inherited from this\nclass.</p>\n",
            "description": "<p>This method is used with instances of classes produced with\ndeclare() to determine of they support a certain interface or\nnot. It models &quot;instanceof&quot; operator.\n</p>\n",
            "examples": [
                "<pre><code>var A = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar B = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar C = declare([A, B], {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar D = declare(A, {\n    // constructor, properties, and methods go here\n    // ...\n});\n\nvar a = new A(), b = new B(), c = new C(), d = new D();\n\nconsole.log(a.isInstanceOf(A)); // true\nconsole.log(b.isInstanceOf(A)); // false\nconsole.log(c.isInstanceOf(A)); // true\nconsole.log(d.isInstanceOf(A)); // true\n\nconsole.log(a.isInstanceOf(B)); // false\nconsole.log(b.isInstanceOf(B)); // true\nconsole.log(c.isInstanceOf(B)); // true\nconsole.log(d.isInstanceOf(B)); // false\n\nconsole.log(a.isInstanceOf(C)); // false\nconsole.log(b.isInstanceOf(C)); // false\nconsole.log(c.isInstanceOf(C)); // true\nconsole.log(d.isInstanceOf(C)); // false\n\nconsole.log(a.isInstanceOf(D)); // false\nconsole.log(b.isInstanceOf(D)); // false\nconsole.log(c.isInstanceOf(D)); // false\nconsole.log(d.isInstanceOf(D)); // true</code></pre>\n"
            ]
        }
    ]
}