{
    "location": "dojo/_base/declare",
    "type": "function",
    "parameters": [
        {
            "name": "className",
            "types": [
                "String"
            ],
            "usage": "optional",
            "summary": "<p>The optional name of the constructor (loosely, a &quot;class&quot;)\nstored in the &quot;declaredClass&quot; property in the created prototype.\nIt will be used as a global name for a created constructor.</p>\n"
        },
        {
            "name": "superclass",
            "types": [
                "Function",
                "Function[]"
            ],
            "usage": "required",
            "summary": "<p>May be null, a Function, or an Array of Functions. This argument\nspecifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
        },
        {
            "name": "props",
            "types": [
                "Object"
            ],
            "usage": "required",
            "summary": "<p>An object whose properties are copied to the created prototype.\nAdd an instance-initialization function by making it a property\nnamed &quot;constructor&quot;.</p>\n"
        }
    ],
    "returnTypes": [
        "dojo/_base/declare.__DeclareCreatedObject",
        "undefined"
    ],
    "returnDescription": "<p>New constructor function.</p>\n",
    "summary": "<p>Create a feature-rich constructor from compact notation.</p>\n",
    "description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n\n</p>\n<p>Ancestors can be compound classes created by this version of\ndeclare(). In complex cases all base classes are going to be\nlinearized according to C3 MRO algorithm\n(see <a href=\"http://www.python.org/download/releases/2.3/mro/\">http://www.python.org/download/releases/2.3/mro/</a> for more\ndetails).\n\n</p>\n<p>&quot;className&quot; is cached in &quot;declaredClass&quot; property of the new class,\nif it was supplied. The immediate super class will be cached in\n&quot;superclass&quot; property of the new class.\n\n</p>\n<p>Methods in &quot;props&quot; will be copied and modified: &quot;nom&quot; property\n(the declared name of the method) will be added to all copied\nfunctions to help identify them for the internal machinery. Be\nvery careful, while reusing methods: if you use the same\nfunction under different names, it can produce errors in some\ncases.\n\n</p>\n<p>It is possible to use constructors created &quot;manually&quot; (without\ndeclare()) as bases. They will be called as usual during the\ncreation of an instance, their methods will be chained, and even\ncalled by &quot;this.inherited()&quot;.\n\n</p>\n<p>Special property &quot;-chains-&quot; governs how to chain methods. It is\na dictionary, which uses method names as keys, and hint strings\nas values. If a hint string is &quot;after&quot;, this method will be\ncalled after methods of its base classes. If a hint string is\n&quot;before&quot;, this method will be called before methods of its base\nclasses.\n\n</p>\n<p>If &quot;constructor&quot; is not mentioned in &quot;-chains-&quot; property, it will\nbe chained using the legacy mode: using &quot;after&quot; chaining,\ncalling preamble() method before each constructor, if available,\nand calling postscript() after all constructors were executed.\nIf the hint is &quot;after&quot;, it is chained as a regular method, but\npostscript() will be called after the chain of constructors.\n&quot;constructor&quot; cannot be chained &quot;before&quot;, but it allows\na special hint string: &quot;manual&quot;, which means that constructors\nare not going to be chained in any way, and programmer will call\nthem manually using this.inherited(). In the latter case\npostscript() will be called after the construction.\n\n</p>\n<p>All chaining hints are &quot;inherited&quot; from base classes and\npotentially can be overridden. Be very careful when overriding\nhints! Make sure that all chained methods can work in a proposed\nmanner of chaining.\n\n</p>\n<p>Once a method was chained, it is impossible to unchain it. The\nonly exception is &quot;constructor&quot;. You don&#39;t need to define a\nmethod in order to supply a chaining hint.\n\n</p>\n<p>If a method is chained, it cannot use this.inherited() because\nall other methods in the hierarchy will be called automatically.\n\n</p>\n<p>Usually constructors and initializers of any kind are chained\nusing &quot;after&quot; and destructors of any kind are chained as\n&quot;before&quot;. Note that chaining assumes that chained methods do not\nreturn any value: any returned value will be discarded.\n</p>\n",
    "examples": [
        "<pre><code>declare(&quot;my.classes.bar&quot;, my.classes.foo, {\n    // properties to be added to the class prototype\n    someValue: 2,\n    // initialization function\n    constructor: function(){\n        this.myComplicatedObject = new ReallyComplicatedObject();\n    },\n    // other functions\n    someMethod: function(){\n        doStuff();\n    }\n});</code></pre>\n",
        "<pre><code>var MyBase = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass1 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass2 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyDiamond = declare([MyClass1, MyClass2], {\n    // constructor, properties, and methods go here\n    // ...\n});</code></pre>\n",
        "<pre><code>var F = function(){ console.log(&quot;raw constructor&quot;); };\nF.prototype.method = function(){\n    console.log(&quot;raw method&quot;);\n};\nvar A = declare(F, {\n    constructor: function(){\n        console.log(&quot;A.constructor&quot;);\n    },\n    method: function(){\n        console.log(&quot;before calling F.method...&quot;);\n        this.inherited(arguments);\n        console.log(&quot;...back in A&quot;);\n    }\n});\nnew A().method();\n// will print:\n// raw constructor\n// A.constructor\n// before calling F.method...\n// raw method\n// ...back in A</code></pre>\n",
        "<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        destroy: &quot;before&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        console.log(&quot;B.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;B.destroy&quot;);\n    }\n});\nvar C = declare(B, {\n    constructor: function(){\n        console.log(&quot;C.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;C.destroy&quot;);\n    }\n});\nnew C().destroy();\n// prints:\n// B.constructor\n// C.constructor\n// C.destroy\n// B.destroy</code></pre>\n",
        "<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        constructor: &quot;manual&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        // ...\n        // call the base constructor with new parameters\n        this.inherited(arguments, [1, 2, 3]);\n        // ...\n    }\n});</code></pre>\n",
        "<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        m1: &quot;before&quot;\n    },\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    &quot;-chains-&quot;: {\n        m2: &quot;after&quot;\n    },\n    m1: function(){\n        console.log(&quot;B.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\nx.m1();\n// prints:\n// B.m1\n// A.m1\nx.m2();\n// prints:\n// A.m2\n// B.m2</code></pre>\n"
    ],
    "properties": [
        {
            "name": "__DeclareCreatedObject",
            "scope": "normal",
            "types": [
                "object"
            ],
            "from": "dojo/_base/declare",
            "private": true,
            "summary": "<p>dojo/_base/declare() returns a constructor <code>C</code>.   <code>new C()</code> returns an Object with the following\nmethods, in addition to the methods and properties specified via the arguments passed to declare().</p>\n"
        }
    ],
    "methods": [
        {
            "name": "constructor",
            "scope": "prototype",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "className",
                    "types": [
                        "String"
                    ],
                    "usage": "optional",
                    "summary": "<p>The optional name of the constructor (loosely, a &quot;class&quot;)\nstored in the &quot;declaredClass&quot; property in the created prototype.\nIt will be used as a global name for a created constructor.</p>\n"
                },
                {
                    "name": "superclass",
                    "types": [
                        "Function",
                        "Function[]"
                    ],
                    "usage": "required",
                    "summary": "<p>May be null, a Function, or an Array of Functions. This argument\nspecifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
                },
                {
                    "name": "props",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>An object whose properties are copied to the created prototype.\nAdd an instance-initialization function by making it a property\nnamed &quot;constructor&quot;.</p>\n"
                }
            ],
            "returnTypes": [
                "dojo/_base/declare.__DeclareCreatedObject",
                "undefined"
            ],
            "returnDescription": "<p>New constructor function.</p>\n",
            "summary": "<p>Create a feature-rich constructor from compact notation.</p>\n",
            "description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n\n</p>\n<p>Ancestors can be compound classes created by this version of\ndeclare(). In complex cases all base classes are going to be\nlinearized according to C3 MRO algorithm\n(see <a href=\"http://www.python.org/download/releases/2.3/mro/\">http://www.python.org/download/releases/2.3/mro/</a> for more\ndetails).\n\n</p>\n<p>&quot;className&quot; is cached in &quot;declaredClass&quot; property of the new class,\nif it was supplied. The immediate super class will be cached in\n&quot;superclass&quot; property of the new class.\n\n</p>\n<p>Methods in &quot;props&quot; will be copied and modified: &quot;nom&quot; property\n(the declared name of the method) will be added to all copied\nfunctions to help identify them for the internal machinery. Be\nvery careful, while reusing methods: if you use the same\nfunction under different names, it can produce errors in some\ncases.\n\n</p>\n<p>It is possible to use constructors created &quot;manually&quot; (without\ndeclare()) as bases. They will be called as usual during the\ncreation of an instance, their methods will be chained, and even\ncalled by &quot;this.inherited()&quot;.\n\n</p>\n<p>Special property &quot;-chains-&quot; governs how to chain methods. It is\na dictionary, which uses method names as keys, and hint strings\nas values. If a hint string is &quot;after&quot;, this method will be\ncalled after methods of its base classes. If a hint string is\n&quot;before&quot;, this method will be called before methods of its base\nclasses.\n\n</p>\n<p>If &quot;constructor&quot; is not mentioned in &quot;-chains-&quot; property, it will\nbe chained using the legacy mode: using &quot;after&quot; chaining,\ncalling preamble() method before each constructor, if available,\nand calling postscript() after all constructors were executed.\nIf the hint is &quot;after&quot;, it is chained as a regular method, but\npostscript() will be called after the chain of constructors.\n&quot;constructor&quot; cannot be chained &quot;before&quot;, but it allows\na special hint string: &quot;manual&quot;, which means that constructors\nare not going to be chained in any way, and programmer will call\nthem manually using this.inherited(). In the latter case\npostscript() will be called after the construction.\n\n</p>\n<p>All chaining hints are &quot;inherited&quot; from base classes and\npotentially can be overridden. Be very careful when overriding\nhints! Make sure that all chained methods can work in a proposed\nmanner of chaining.\n\n</p>\n<p>Once a method was chained, it is impossible to unchain it. The\nonly exception is &quot;constructor&quot;. You don&#39;t need to define a\nmethod in order to supply a chaining hint.\n\n</p>\n<p>If a method is chained, it cannot use this.inherited() because\nall other methods in the hierarchy will be called automatically.\n\n</p>\n<p>Usually constructors and initializers of any kind are chained\nusing &quot;after&quot; and destructors of any kind are chained as\n&quot;before&quot;. Note that chaining assumes that chained methods do not\nreturn any value: any returned value will be discarded.\n</p>\n",
            "examples": [
                "<pre><code>declare(&quot;my.classes.bar&quot;, my.classes.foo, {\n    // properties to be added to the class prototype\n    someValue: 2,\n    // initialization function\n    constructor: function(){\n        this.myComplicatedObject = new ReallyComplicatedObject();\n    },\n    // other functions\n    someMethod: function(){\n        doStuff();\n    }\n});</code></pre>\n",
                "<pre><code>var MyBase = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass1 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass2 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyDiamond = declare([MyClass1, MyClass2], {\n    // constructor, properties, and methods go here\n    // ...\n});</code></pre>\n",
                "<pre><code>var F = function(){ console.log(&quot;raw constructor&quot;); };\nF.prototype.method = function(){\n    console.log(&quot;raw method&quot;);\n};\nvar A = declare(F, {\n    constructor: function(){\n        console.log(&quot;A.constructor&quot;);\n    },\n    method: function(){\n        console.log(&quot;before calling F.method...&quot;);\n        this.inherited(arguments);\n        console.log(&quot;...back in A&quot;);\n    }\n});\nnew A().method();\n// will print:\n// raw constructor\n// A.constructor\n// before calling F.method...\n// raw method\n// ...back in A</code></pre>\n",
                "<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        destroy: &quot;before&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        console.log(&quot;B.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;B.destroy&quot;);\n    }\n});\nvar C = declare(B, {\n    constructor: function(){\n        console.log(&quot;C.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;C.destroy&quot;);\n    }\n});\nnew C().destroy();\n// prints:\n// B.constructor\n// C.constructor\n// C.destroy\n// B.destroy</code></pre>\n",
                "<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        constructor: &quot;manual&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        // ...\n        // call the base constructor with new parameters\n        this.inherited(arguments, [1, 2, 3]);\n        // ...\n    }\n});</code></pre>\n",
                "<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        m1: &quot;before&quot;\n    },\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    &quot;-chains-&quot;: {\n        m2: &quot;after&quot;\n    },\n    m1: function(){\n        console.log(&quot;B.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\nx.m1();\n// prints:\n// B.m1\n// A.m1\nx.m2();\n// prints:\n// A.m2\n// B.m2</code></pre>\n"
            ]
        },
        {
            "name": "safeMixin",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/_base/declare",
            "parameters": [
                {
                    "name": "target",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>Target object to accept new properties.</p>\n"
                },
                {
                    "name": "source",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>Source object for new properties.</p>\n"
                }
            ],
            "returnTypes": [
                "Object"
            ],
            "returnDescription": "<p>Target object to accept new properties.</p>\n",
            "summary": "<p>Mix in properties skipping a constructor and decorating functions\nlike it is done by declare().</p>\n",
            "description": "<p>This function is used to mix in properties like lang.mixin does,\nbut it skips a constructor property and decorates functions like\ndeclare() does.\n\n</p>\n<p>It is meant to be used with classes and objects produced with\ndeclare. Functions mixed in with dojo.safeMixin can use\nthis.inherited() like normal methods.\n\n</p>\n<p>This function is used to implement extend() method of a constructor\nproduced with declare().\n</p>\n",
            "examples": [
                "<pre><code>var A = declare(null, {\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    m1: function(){\n        this.inherited(arguments);\n        console.log(&quot;B.m1&quot;);\n    }\n});\nB.extend({\n    m2: function(){\n        this.inherited(arguments);\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\ndojo.safeMixin(x, {\n    m1: function(){\n        this.inherited(arguments);\n        console.log(&quot;X.m1&quot;);\n    },\n    m2: function(){\n        this.inherited(arguments);\n        console.log(&quot;X.m2&quot;);\n    }\n});\nx.m2();\n// prints:\n// A.m1\n// B.m1\n// X.m1</code></pre>\n"
            ]
        }
    ]
}