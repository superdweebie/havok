{
    "location": "dojo/parser",
    "type": "object",
    "summary": "<p>The Dom/Widget parsing package</p>\n",
    "methods": [
        {
            "name": "_clearCache",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "private": true,
            "parameters": [],
            "returnTypes": [],
            "summary": "<p>Clear cached data.   Used mainly for benchmarking.</p>\n"
        },
        {
            "name": "_functionFromScript",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "private": true,
            "parameters": [
                {
                    "name": "script",
                    "types": [
                        "DOMNode"
                    ],
                    "usage": "required",
                    "summary": "<p>The <code>&lt;script&gt;</code> DOMNode</p>\n"
                },
                {
                    "name": "attrData",
                    "types": [
                        "String"
                    ],
                    "usage": "required",
                    "summary": "<p>For HTML5 compliance, searches for attrData + &quot;args&quot; (typically\n&quot;data-dojo-args&quot;) instead of &quot;args&quot;</p>\n"
                }
            ],
            "returnTypes": [
                "instance"
            ],
            "summary": "<p>Convert a <code>&lt;script type=&quot;dojo/method&quot; args=&quot;a, b, c&quot;&gt; ... &lt;/script&gt;</code>\ninto a function</p>\n"
        },
        {
            "name": "_instantiate",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "private": true,
            "parameters": [
                {
                    "name": "nodes",
                    "types": [
                        "Array"
                    ],
                    "usage": "required",
                    "summary": "<p>Array of objects like\n\n</p>\n{\n    ctor: Function (may be null)\n    types: [&quot;dijit/form/Button&quot;, &quot;acme/MyMixin&quot;] (used if ctor not specified)\n    node: DOMNode,\n    scripts: [ ... ],   // array of &lt;script type=&quot;dojo/...&quot;&gt; children of node\n    inherited: { ... }  // settings inherited from ancestors like dir, theme, etc.\n}\n"
                },
                {
                    "name": "mixin",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>An object that will be mixed in with each node in the array.\nValues in the mixin will override values in the node, if they\nexist.</p>\n"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>An options object used to hold kwArgs for instantiation.\nSee parse.options argument for details.</p>\n"
                },
                {
                    "name": "returnPromise",
                    "types": [
                        "Boolean"
                    ],
                    "usage": "required",
                    "summary": "<p>Return a Promise rather than the instance; supports asynchronous widget creation.</p>\n"
                }
            ],
            "returnTypes": [
                "any",
                "undefined"
            ],
            "returnDescription": "<p>Array of instances, or if returnPromise is true, a promise for array of instances\nthat resolves when instances have finished initializing.</p>\n",
            "summary": "<p>Takes array of objects representing nodes, and turns them into class instances and\npotentially calls a startup method to allow them to connect with\nany children.</p>\n"
        },
        {
            "name": "_require",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "private": true,
            "parameters": [
                {
                    "name": "script",
                    "types": [
                        "DOMNode"
                    ],
                    "usage": "required"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional"
                }
            ],
            "returnTypes": [
                "undefined"
            ],
            "summary": "<p>Helper for _scanAMD().  Takes a <code>&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;</code> node,\ncalls require() to load the specified modules and (asynchronously) assign them to the specified global\nvariables, and returns a Promise for when that operation completes.\n\n</p>\n<p>In the example above, it is effectively doing a require([&quot;acme/bar&quot;, ...], function(a){ bar = a; }).</p>\n"
        },
        {
            "name": "_scanAmd",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "private": true,
            "parameters": [
                {
                    "name": "root",
                    "types": [
                        "DomNode"
                    ],
                    "usage": "required",
                    "summary": "<p>The node to base the scan from.</p>\n"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>a kwArgs options object, see parse() for details</p>\n"
                }
            ],
            "returnTypes": [
                "undefined"
            ],
            "summary": "<p>Scans the DOM for any declarative requires and returns their values.</p>\n",
            "description": "<p>Looks for <code>&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;</code> node, calls require() to load the\nspecified modules and (asynchronously) assign them to the specified global variables,\nand returns a Promise for when those operations complete.</p>\n"
        },
        {
            "name": "construct",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "parameters": [
                {
                    "name": "ctor",
                    "types": [
                        "Function"
                    ],
                    "usage": "required",
                    "summary": "<p>Widget constructor.</p>\n"
                },
                {
                    "name": "node",
                    "types": [
                        "DOMNode"
                    ],
                    "usage": "required",
                    "summary": "<p>This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.</p>\n"
                },
                {
                    "name": "mixin",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>Attributes in this object will be passed as parameters to ctor,\noverriding attributes specified on the node.</p>\n"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>An options object used to hold kwArgs for instantiation.   See parse.options argument for details.</p>\n"
                },
                {
                    "name": "scripts",
                    "types": [
                        "DomNode[]"
                    ],
                    "usage": "optional",
                    "summary": "<p>Array of <code>&lt;script type=&quot;dojo/*&quot;&gt;</code> DOMNodes.  If not specified, will search for <code>&lt;script&gt;</code> tags inside node.</p>\n"
                },
                {
                    "name": "inherited",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.</p>\n"
                }
            ],
            "returnTypes": [
                "any",
                "undefined"
            ],
            "returnDescription": "<p>Instance or Promise for the instance, if markupFactory() itself returned a promise</p>\n",
            "summary": "<p>Calls new ctor(params, node), where params is the hash of parameters specified on the node,\nexcluding data-dojo-type and data-dojo-mixins.   Does not call startup().</p>\n"
        },
        {
            "name": "instantiate",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "parameters": [
                {
                    "name": "nodes",
                    "types": [
                        "Array"
                    ],
                    "usage": "required",
                    "summary": "<p>Array of DOM nodes</p>\n"
                },
                {
                    "name": "mixin",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>An object that will be mixed in with each node in the array.\nValues in the mixin will override values in the node, if they\nexist.</p>\n"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>An object used to hold kwArgs for instantiation.\nSee parse.options argument for details.</p>\n"
                }
            ],
            "returnTypes": [
                "any",
                "undefined"
            ],
            "returnDescription": "<p>Array of instances.</p>\n",
            "summary": "<p>Takes array of nodes, and turns them into class instances and\npotentially calls a startup method to allow them to connect with\nany children.</p>\n"
        },
        {
            "name": "parse",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "parameters": [
                {
                    "name": "rootNode",
                    "types": [
                        "DomNode"
                    ],
                    "usage": "optional",
                    "summary": "<p>A default starting root node from which to start the parsing. Can be\nomitted, defaulting to the entire document. If omitted, the <code>options</code>\nobject can be passed in this place. If the <code>options</code> object has a\n<code>rootNode</code> member, that is used.</p>\n"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "optional",
                    "summary": "<p>A hash of options.\n\n</p>\n<ul>\n<li>noStart: Boolean?:\n  when set will prevent the parser from calling .startup()\n  when locating the nodes.</li>\n<li>rootNode: DomNode?:\n  identical to the function&#39;s <code>rootNode</code> argument, though\n  allowed to be passed in via this `options object.</li>\n<li>template: Boolean:\n  If true, ignores ContentPane&#39;s stopParser flag and parses contents inside of\n  a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes\n  nested inside the ContentPane to work.</li>\n<li>inherited: Object:\n  Hash possibly containing dir and lang settings to be applied to\n  parsed widgets, unless there&#39;s another setting on a sub-node that overrides</li>\n<li>scope: String:\n  Root for attribute names to search for.   If scopeName is dojo,\n  will search for data-dojo-type (or dojoType).   For backwards compatibility\n  reasons defaults to dojo._scopeName (which is &quot;dojo&quot; except when\n  multi-version support is used, when it will be something like dojo16, dojo20, etc.)</li>\n<li>propsThis: Object:\n  If specified, &quot;this&quot; referenced from data-dojo-props will refer to propsThis.\n  Intended for use from the widgets-in-template feature of <code>dijit._WidgetsInTemplateMixin</code></li>\n<li>contextRequire: Function:\n  If specified, this require is utilised for looking resolving modules instead of the\n  <code>dojo/parser</code> context <code>require()</code>.  Intended for use from the widgets-in-template feature of\n  <code>dijit._WidgetsInTemplateMixin</code>.</li>\n</ul>\n"
                }
            ],
            "returnTypes": [
                "Mixed",
                "Array"
            ],
            "returnDescription": "<p>Returns a blended object that is an array of the instantiated objects, but also can include\na promise that is resolved with the instantiated objects.  This is done for backwards\ncompatibility.  If the parser auto-requires modules, it will always behave in a promise\nfashion and <code>parser.parse().then(function(instances){...})</code> should be used.</p>\n",
            "summary": "<p>Scan the DOM for class instances, and instantiate them.</p>\n",
            "description": "<p>Search specified node (or root node) recursively for class instances,\nand instantiate them. Searches for either data-dojo-type=&quot;Class&quot; or\ndojoType=&quot;Class&quot; where &quot;Class&quot; is a a fully qualified class name,\nlike <code>dijit/form/Button</code>\n\n</p>\n<p>Using <code>data-dojo-type</code>:\nAttributes using can be mixed into the parameters used to instantiate the\nClass by using a <code>data-dojo-props</code> attribute on the node being converted.\n<code>data-dojo-props</code> should be a string attribute to be converted from JSON.\n\n</p>\n<p>Using <code>dojoType</code>:\nAttributes are read from the original domNode and converted to appropriate\ntypes by looking up the Class prototype values. This is the default behavior\nfrom Dojo 1.0 to Dojo 1.5. <code>dojoType</code> support is deprecated, and will\ngo away in Dojo 2.0.</p>\n",
            "examples": [
                "<p>Parse all widgets on a page:\n\n</p>\nparser.parse();\n",
                "<p>Parse all classes within the node with id=&quot;foo&quot;\n\n</p>\nparser.parse(dojo.byId(&#39;foo&#39;));\n",
                "<p>Parse all classes in a page, but do not call .startup() on any\nchild\n\n</p>\nparser.parse({ noStart: true })\n",
                "<p>Parse all classes in a node, but do not call .startup()\n\n</p>\nparser.parse(someNode, { noStart:true });\n// or\nparser.parse({ noStart:true, rootNode: someNode });\n"
            ]
        },
        {
            "name": "scan",
            "scope": "normal",
            "types": [
                "function"
            ],
            "from": "dojo/parser",
            "parameters": [
                {
                    "name": "root",
                    "types": [
                        "DomNode"
                    ],
                    "usage": "optional",
                    "summary": "<p>A default starting root node from which to start the parsing. Can be\nomitted, defaulting to the entire document. If omitted, the <code>options</code>\nobject can be passed in this place. If the <code>options</code> object has a\n<code>rootNode</code> member, that is used.</p>\n"
                },
                {
                    "name": "options",
                    "types": [
                        "Object"
                    ],
                    "usage": "required",
                    "summary": "<p>a kwArgs options object, see parse() for details\n</p>\n"
                }
            ],
            "returnTypes": [
                "Promise",
                "undefined"
            ],
            "returnDescription": "<p>A promise that is resolved with the nodes that have been parsed.</p>\n",
            "summary": "<p>Scan a DOM tree and return an array of objects representing the DOMNodes\nthat need to be turned into widgets.</p>\n",
            "description": "<p>Search specified node (or document root node) recursively for class instances\nand return an array of objects that represent potential widgets to be\ninstantiated. Searches for either data-dojo-type=&quot;MID&quot; or dojoType=&quot;MID&quot; where\n&quot;MID&quot; is a module ID like &quot;dijit/form/Button&quot; or a fully qualified Class name\nlike &quot;dijit/form/Button&quot;.  If the MID is not currently available, scan will\nattempt to require() in the module.\n\n</p>\n<p>See parser.parse() for details of markup.</p>\n"
        }
    ],
    "apiPath": "../",
    "shortName": "parser"
}