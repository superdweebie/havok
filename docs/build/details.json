{
	"havok/array": {
		"location": "havok/array",
		"type": "object",
		"summary": "<p>The Javascript v1.6 array extensions.</p>\n",
		"methods": [
			{
				"name": "clearCache",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "every",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate on. If a string, operates on individual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments: item, index,\nand array and returns true if the condition is met.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Determines whether or not every item in arr satisfies the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s every skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</a></p>\n",
				"examples": [
					"<pre><code>// returns false\narray.every([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n",
					"<pre><code>// returns true\narray.every([1, 2, 3, 4], function(item){ return item&gt;0; });</code></pre>\n"
				]
			},
			{
				"name": "filter",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>the array to iterate over.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function that is invoked with three arguments (item,\nindex, array). The return of this function is expected to\nbe a boolean which determines whether the passed-in item\nwill be included in the returned array.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns a new Array with those items from arr that match the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s filter skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</a></p>\n",
				"examples": [
					"<pre><code>// returns [2, 3, 4]\narray.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n"
				]
			},
			{
				"name": "forEach",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>for every item in arr, callback is invoked. Return values are ignored.\nIf you want to break out of the loop, consider using array.every() or array.some().\nforEach does not allow breaking out of the loop over the items in arr.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s forEach skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</a></p>\n",
				"examples": [
					"<pre><code>// log out all members of the array:\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      function(item){\n          console.log(item);\n      }\n);</code></pre>\n",
					"<pre><code>// log out the members and their indexes\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      function(item, idx, arr){\n          console.log(item, &quot;at index:&quot;, idx);\n      }\n);</code></pre>\n",
					"<pre><code>// use a scoped object member as the callback\n\nvar obj = {\n      prefix: &quot;logged via obj.callback:&quot;,\n      callback: function(item){\n          console.log(this.prefix, item);\n      }\n};\n\n// specifying the scope function executes the callback in that scope\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      obj.callback,\n      obj\n);\n\n// alternately, we can accomplish the same thing with lang.hitch()\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      lang.hitch(obj, &quot;callback&quot;)\n);</code></pre>\n"
				]
			},
			{
				"name": "indexOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "fromIndex",
						"types": [
							"Integer"
						],
						"usage": "optional"
					},
					{
						"name": "findLast",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.</p>\n"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>locates the first index of the provided value in the\npassed array. If the value is not found, -1 is returned.</p>\n",
				"description": "<p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\n\n</p>\n<ol>\n<li>when run over sparse arrays, the Dojo function invokes the callback for every index\nwhereas JavaScript 1.6&#39;s indexOf skips the holes in the sparse array.</li>\n<li>uses equality (==) rather than strict equality (===)</li>\n</ol>\n<p>For details on this method, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</a></p>\n"
			},
			{
				"name": "lastIndexOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "fromIndex",
						"types": [
							"Integer"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>locates the last index of the provided value in the passed\narray. If the value is not found, -1 is returned.</p>\n",
				"description": "<p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\n\n</p>\n<ol>\n<li>when run over sparse arrays, the Dojo function invokes the callback for every index\nwhereas JavaScript 1.6&#39;s lasIndexOf skips the holes in the sparse array.</li>\n<li>uses equality (==) rather than strict equality (===)</li>\n</ol>\n<p>For details on this method, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</a></p>\n"
			},
			{
				"name": "map",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate on. If a string, operates on\nindividual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments, (item, index,\narray),  and returns a value</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					},
					{
						"name": "Ctr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Array",
					"instance"
				],
				"summary": "<p>applies callback to each element of arr and returns\nan Array with the results</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s map skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</a></p>\n",
				"examples": [
					"<pre><code>// returns [2, 3, 4, 5]\narray.map([1, 2, 3, 4], function(item){ return item+1 });</code></pre>\n"
				]
			},
			{
				"name": "some",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate over. If a string, operates on individual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments: item, index,\nand array and returns true if the condition is met.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Determines whether or not any item in arr satisfies the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s some skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</a></p>\n",
				"examples": [
					"<pre><code>// is true\narray.some([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n",
					"<pre><code>// is false\narray.some([1, 2, 3, 4], function(item){ return item&lt;1; });</code></pre>\n"
				]
			},
			{
				"name": "subtract",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/array",
				"parameters": [
					{
						"name": "removeFrom",
						"types": [
							"havok/array"
						],
						"usage": "required"
					},
					{
						"name": "removeValues",
						"types": [
							"havok/array"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Remove the values in removeValues from the array removeFrom</p>\n"
			}
		]
	},
	"dojo/_base/array": {
		"location": "dojo/_base/array",
		"type": "object",
		"summary": "<p>The Javascript v1.6 array extensions.</p>\n",
		"methods": [
			{
				"name": "clearCache",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "every",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate on. If a string, operates on individual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments: item, index,\nand array and returns true if the condition is met.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Determines whether or not every item in arr satisfies the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s every skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</a></p>\n",
				"examples": [
					"<pre><code>// returns false\narray.every([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n",
					"<pre><code>// returns true\narray.every([1, 2, 3, 4], function(item){ return item&gt;0; });</code></pre>\n"
				]
			},
			{
				"name": "filter",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>the array to iterate over.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function that is invoked with three arguments (item,\nindex, array). The return of this function is expected to\nbe a boolean which determines whether the passed-in item\nwill be included in the returned array.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns a new Array with those items from arr that match the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s filter skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</a></p>\n",
				"examples": [
					"<pre><code>// returns [2, 3, 4]\narray.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n"
				]
			},
			{
				"name": "forEach",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>for every item in arr, callback is invoked. Return values are ignored.\nIf you want to break out of the loop, consider using array.every() or array.some().\nforEach does not allow breaking out of the loop over the items in arr.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s forEach skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</a></p>\n",
				"examples": [
					"<pre><code>// log out all members of the array:\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      function(item){\n          console.log(item);\n      }\n);</code></pre>\n",
					"<pre><code>// log out the members and their indexes\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      function(item, idx, arr){\n          console.log(item, &quot;at index:&quot;, idx);\n      }\n);</code></pre>\n",
					"<pre><code>// use a scoped object member as the callback\n\nvar obj = {\n      prefix: &quot;logged via obj.callback:&quot;,\n      callback: function(item){\n          console.log(this.prefix, item);\n      }\n};\n\n// specifying the scope function executes the callback in that scope\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      obj.callback,\n      obj\n);\n\n// alternately, we can accomplish the same thing with lang.hitch()\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      lang.hitch(obj, &quot;callback&quot;)\n);</code></pre>\n"
				]
			},
			{
				"name": "indexOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "fromIndex",
						"types": [
							"Integer"
						],
						"usage": "optional"
					},
					{
						"name": "findLast",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.</p>\n"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>locates the first index of the provided value in the\npassed array. If the value is not found, -1 is returned.</p>\n",
				"description": "<p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\n\n</p>\n<ol>\n<li>when run over sparse arrays, the Dojo function invokes the callback for every index\nwhereas JavaScript 1.6&#39;s indexOf skips the holes in the sparse array.</li>\n<li>uses equality (==) rather than strict equality (===)</li>\n</ol>\n<p>For details on this method, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</a></p>\n"
			},
			{
				"name": "lastIndexOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "fromIndex",
						"types": [
							"Integer"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>locates the last index of the provided value in the passed\narray. If the value is not found, -1 is returned.</p>\n",
				"description": "<p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\n\n</p>\n<ol>\n<li>when run over sparse arrays, the Dojo function invokes the callback for every index\nwhereas JavaScript 1.6&#39;s lasIndexOf skips the holes in the sparse array.</li>\n<li>uses equality (==) rather than strict equality (===)</li>\n</ol>\n<p>For details on this method, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</a></p>\n"
			},
			{
				"name": "map",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate on. If a string, operates on\nindividual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments, (item, index,\narray),  and returns a value</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					},
					{
						"name": "Ctr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Array",
					"instance"
				],
				"summary": "<p>applies callback to each element of arr and returns\nan Array with the results</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s map skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</a></p>\n",
				"examples": [
					"<pre><code>// returns [2, 3, 4, 5]\narray.map([1, 2, 3, 4], function(item){ return item+1 });</code></pre>\n"
				]
			},
			{
				"name": "some",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate over. If a string, operates on individual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments: item, index,\nand array and returns true if the condition is met.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Determines whether or not any item in arr satisfies the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s some skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</a></p>\n",
				"examples": [
					"<pre><code>// is true\narray.some([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n",
					"<pre><code>// is false\narray.some([1, 2, 3, 4], function(item){ return item&lt;1; });</code></pre>\n"
				]
			},
			{
				"name": "subtract",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "removeFrom",
						"types": [
							"havok/array"
						],
						"usage": "required"
					},
					{
						"name": "removeValues",
						"types": [
							"havok/array"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Remove the values in removeValues from the array removeFrom</p>\n"
			}
		]
	},
	"dojo/_base/kernel": {
		"location": "dojo/_base/kernel",
		"type": "object",
		"summary": "<p>This module is the foundational module of the dojo boot sequence; it defines the dojo object.</p>\n",
		"properties": [
			{
				"name": "_blockAsync",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "_contentHandlers",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"summary": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls.</p>\n",
				"description": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls. Each contentHandler is\ncalled, passing the xhr object for manipulation. The return value\nfrom the contentHandler will be passed to the <code>load</code> or <code>handle</code>\nfunctions defined in the original xhr call.</p>\n",
				"examples": [
					"<p>Creating a custom content-handler:\n\n</p>\n<pre><code>xhr.contentHandlers.makeCaps = function(xhr){\n    return xhr.responseText.toUpperCase();\n}\n// and later:\ndojo.xhrGet({\n    url:&quot;foo.txt&quot;,\n    handleAs:&quot;makeCaps&quot;,\n    load: function(data){ /* data is a toUpper version of foo.txt */ }\n});</code></pre>\n"
				]
			},
			{
				"name": "_hasResource",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/kernel",
				"private": true
			},
			{
				"name": "_name",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/_base/sniff",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "_postLoad",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/ready",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "baseUrl",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "cldr",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/cldr/monetary",
				"extensionModule": true
			},
			{
				"name": "config",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/kernel",
				"summary": "<p>This module defines the user configuration during bootstrap.</p>\n",
				"description": "<p>By defining user configuration as a module value, an entire configuration can be specified in a build,\nthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\nAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\nat an unique absolute module identifier as given by the package configuration. Implementing configuration\nas a module allows for specifying unique, per-instance configurations.</p>\n",
				"examples": [
					"<p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and\ndojo.js are already loaded).\n\n</p>\n<pre><code>// specify a configuration that creates a new instance of dojo at the absolute module identifier &quot;myDojo&quot;\nrequire({\n    packages:[{\n        name:&quot;myDojo&quot;,\n        location:&quot;.&quot;, //assume baseUrl points to dojo.js\n    }]\n});\n\n// specify a configuration for the myDojo instance\ndefine(&quot;myDojo/config&quot;, {\n    // normal configuration variables go here, e.g.,\n    locale:&quot;fr-ca&quot;\n});\n\n// load and use the new instance of dojo\nrequire([&quot;myDojo&quot;], function(dojo){\n    // dojo is the new instance of dojo\n    // use as required\n});</code></pre>\n"
				]
			},
			{
				"name": "contentHandlers",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls.</p>\n",
				"description": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls. Each contentHandler is\ncalled, passing the xhr object for manipulation. The return value\nfrom the contentHandler will be passed to the <code>load</code> or <code>handle</code>\nfunctions defined in the original xhr call.</p>\n",
				"examples": [
					"<p>Creating a custom content-handler:\n\n</p>\n<pre><code>xhr.contentHandlers.makeCaps = function(xhr){\n    return xhr.responseText.toUpperCase();\n}\n// and later:\ndojo.xhrGet({\n    url:&quot;foo.txt&quot;,\n    handleAs:&quot;makeCaps&quot;,\n    load: function(data){ /* data is a toUpper version of foo.txt */ }\n});</code></pre>\n"
				]
			},
			{
				"name": "currency",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/currency",
				"extensionModule": true,
				"summary": "<p>localized formatting and parsing routines for currencies</p>\n",
				"description": "<p>extends dojo.number to provide culturally-appropriate formatting of values\nin various world currencies, including use of a currency symbol.  The currencies are specified\nby a three-letter international symbol in all uppercase, and support for the currencies is\nprovided by the data in <code>dojo.cldr</code>.  The scripts generating dojo.cldr specify which\ncurrency support is included.  A fixed number of decimal places is determined based\non the currency type and is not determined by the &#39;pattern&#39; argument.  The fractional\nportion is optional, by default, and variable length decimals are not supported.</p>\n"
			},
			{
				"name": "date",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/date/stamp",
				"extensionModule": true
			},
			{
				"name": "dijit",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "doc",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/window",
				"extensionModule": true,
				"summary": "<p>Alias for the current document. &#39;doc&#39; can be modified\nfor temporary context shifting. See also withDoc().</p>\n",
				"description": "<p>Use this rather than referring to &#39;window.document&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n",
				"examples": [
					"<pre><code>n.appendChild(dojo.doc.createElement(&#39;div&#39;));</code></pre>\n"
				]
			},
			{
				"name": "dojox",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "fx",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/fx",
				"extensionModule": true,
				"summary": "<p>Effects library on top of Base animations</p>\n"
			},
			{
				"name": "global",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/window",
				"extensionModule": true,
				"summary": "<p>Alias for the current window. &#39;global&#39; can be modified\nfor temporary context shifting. See also withGlobal().</p>\n",
				"description": "<p>Use this rather than referring to &#39;window&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n"
			},
			{
				"name": "i18n",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"summary": "<p>This module implements the dojo/i18n! plugin and the v1.6- i18n API</p>\n",
				"description": "<p>We choose to include our own plugin to leverage functionality already contained in dojo\nand thereby reduce the size of the plugin compared to various loader implementations. Also, this\nallows foreign AMD loaders to be used without their plugins.</p>\n"
			},
			{
				"name": "isAir",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>True if client is Adobe Air</p>\n"
			},
			{
				"name": "isAndroid",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is android browser. undefined otherwise.</p>\n"
			},
			{
				"name": "isAsync",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "isBrowser",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>True if the client is a web-browser</p>\n"
			},
			{
				"name": "isChrome",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is Chrome browser. undefined otherwise.</p>\n"
			},
			{
				"name": "isFF",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is FireFox. undefined otherwise. Corresponds to\nmajor detected FireFox version (1.5, 2, 3, etc.)</p>\n"
			},
			{
				"name": "isIE",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to\nmajor detected IE version (6, 7, 8, etc.)</p>\n"
			},
			{
				"name": "isIos",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is iPhone, iPod, or iPad. undefined otherwise.</p>\n"
			},
			{
				"name": "isKhtml",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major\ndetected version.</p>\n"
			},
			{
				"name": "isMac",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>True if the client runs on Mac</p>\n"
			},
			{
				"name": "isMoz",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is a Mozilla-based browser (Firefox,\nSeaMonkey). undefined otherwise. Corresponds to major detected version.</p>\n"
			},
			{
				"name": "isMozilla",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is a Mozilla-based browser (Firefox,\nSeaMonkey). undefined otherwise. Corresponds to major detected version.</p>\n"
			},
			{
				"name": "isOpera",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is Opera. undefined otherwise. Corresponds to\nmajor detected version.</p>\n"
			},
			{
				"name": "isQuirks",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Page is in quirks mode.</p>\n"
			},
			{
				"name": "isSafari",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is Safari or iPhone. undefined otherwise.</p>\n"
			},
			{
				"name": "isWebKit",
				"scope": "normal",
				"types": [
					"Number",
					"undefined"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>Version as a Number if client is a WebKit-derived browser (Konqueror,\nSafari, Chrome, etc.). undefined otherwise.</p>\n"
			},
			{
				"name": "isWii",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/sniff",
				"extensionModule": true,
				"summary": "<p>True if client is Wii</p>\n"
			},
			{
				"name": "keys",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/keys",
				"extensionModule": true,
				"summary": "<p>Definitions for common key values.  Client code should test keyCode against these named constants,\nas the actual codes can vary by browser.</p>\n"
			},
			{
				"name": "locale",
				"scope": "normal",
				"types": [
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>The locale to assume for loading localized resources in this page,\nspecified according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a>.\nMust be specified entirely in lowercase, e.g. <code>en-us</code> and <code>zh-cn</code>.\nSee the documentation for <code>dojo.i18n</code> and <code>dojo.requireLocalization</code>\nfor details on loading localized resources. If no locale is specified,\nDojo assumes the locale of the user agent, according to <code>navigator.userLanguage</code>\nor <code>navigator.language</code> properties.</p>\n"
			},
			{
				"name": "mouseButtons",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/mouse",
				"extensionModule": true
			},
			{
				"name": "number",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/number",
				"extensionModule": true,
				"summary": "<p>localized formatting and parsing routines for Number</p>\n"
			},
			{
				"name": "parser",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/parser",
				"extensionModule": true,
				"summary": "<p>The Dom/Widget parsing package</p>\n"
			},
			{
				"name": "query",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/query",
				"extensionModule": true
			},
			{
				"name": "regexp",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/regexp",
				"extensionModule": true,
				"summary": "<p>Regular expressions and Builder resources</p>\n"
			},
			{
				"name": "scopeMap",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "store",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/store/util/QueryResults",
				"extensionModule": true
			},
			{
				"name": "string",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/string",
				"extensionModule": true,
				"summary": "<p>String utilities for Dojo</p>\n"
			},
			{
				"name": "toJsonIndentStr",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/_base/json",
				"extensionModule": true
			},
			{
				"name": "touch",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"summary": "<p>This module provides unified touch event handlers by exporting\npress, move, release and cancel which can also run well on desktop.\nBased on <a href=\"http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html\">http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html</a>\nAlso, if the dojoClick property is set to true on a DOM node, dojo/touch generates\nclick events immediately for this node and its descendants, to avoid the\ndelay before native browser click events, and regardless of whether evt.preventDefault()\nwas called in a touch.press event listener.\n</p>\n",
				"examples": [
					"<p>Used with dojo.on\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;, &quot;dojo/touch&quot;], function(on, touch){\n    on(node, touch.press, function(e){});\n    on(node, touch.move, function(e){});\n    on(node, touch.release, function(e){});\n    on(node, touch.cancel, function(e){});</code></pre>\n",
					"<p>Used with touch.* directly\n\n</p>\n<pre><code>touch.press(node, function(e){});\ntouch.move(node, function(e){});\ntouch.release(node, function(e){});\ntouch.cancel(node, function(e){});</code></pre>\n",
					"<p>Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels\n\n</p>\n<pre><code>node.dojoClick = true;</code></pre>\n",
					"<p>Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically\n\n</p>\n<pre><code>node.dojoClick = 10;</code></pre>\n",
					"<p>Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically\n\n</p>\n<pre><code>node.dojoClick = {x:50, y:5};</code></pre>\n"
				]
			},
			{
				"name": "version",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/kernel",
				"summary": "<p>Version number of the Dojo Toolkit</p>\n",
				"description": "<p>Hash about the version, including\n\n</p>\n<ul>\n<li>major: Integer: Major version. If total version is &quot;1.2.0beta1&quot;, will be 1</li>\n<li>minor: Integer: Minor version. If total version is &quot;1.2.0beta1&quot;, will be 2</li>\n<li>patch: Integer: Patch version. If total version is &quot;1.2.0beta1&quot;, will be 0</li>\n<li>flag: String: Descriptor flag. If total version is &quot;1.2.0beta1&quot;, will be &quot;beta1&quot;</li>\n<li>revision: Number: The SVN rev from which dojo was pulled</li>\n</ul>\n"
			},
			{
				"name": "window",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/window",
				"extensionModule": true,
				"summary": "<p>TODOC</p>\n"
			}
		],
		"methods": [
			{
				"name": "__IoArgs",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__IoCallbackArgs",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__IoPublish",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__XhrArgs",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_Animation",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The &#39;magic argument&#39;, mixing all the properties into this\nanimation instance.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>A generic animation class that fires callbacks into its handlers\nobject at various states.</p>\n",
				"description": "<p>A generic animation class that fires callbacks into its handlers\nobject at various states. Nearly all dojo animation functions\nreturn an instance of this method, usually without calling the\n.play() method beforehand. Therefore, you will likely need to\ncall .play() on instances of <code>Animation</code> when one is\nreturned.</p>\n"
			},
			{
				"name": "_defaultEasing",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>The default easing function for Animation(s)</p>\n"
			},
			{
				"name": "_escapeString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/json",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>A value to be serialized.</p>\n"
					},
					{
						"name": "replacer",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>A replacer function that is called for each value and can return a replacement</p>\n"
					},
					{
						"name": "spacer",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>A spacer string to be used for pretty printing of JSON</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a <a href=\"http://json.org\">JSON</a> serialization of an object.</p>\n",
				"description": "<p>Returns a <a href=\"http://json.org\">JSON</a> serialization of an object.\nThis function follows <a href=\"https://developer.mozilla.org/en/JSON\">native JSON API</a>\nNote that this doesn&#39;t check for infinite recursion, so don&#39;t do that!</p>\n",
				"examples": [
					"<p>simple serialization of a trivial object\n\n</p>\n<pre><code>define([&quot;dojo/json&quot;], function(JSON){\n    var jsonStr = JSON.stringify({ howdy: &quot;stranger!&quot;, isStrange: true });\n    doh.is(&#39;{&quot;howdy&quot;:&quot;stranger!&quot;,&quot;isStrange&quot;:true}&#39;, jsonStr);</code></pre>\n"
				]
			},
			{
				"name": "_fade",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns an animation that will fade the node defined by\nargs.node from the start to end values passed (args.start\nargs.end) (end is mandatory, start is optional)</p>\n"
			},
			{
				"name": "_filterQueryResult",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/query",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "nodes",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "selector",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "root",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_getText",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "url",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_ioAddQueryToUrl",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "ioArgs",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>args (Object): <p>the original object argument to the IO call.</p>\n</li><li>xhr (XMLHttpRequest): <p>For XMLHttpRequest calls only, the\nXMLHttpRequest object that was used for the\nrequest.</p>\n</li><li>url (String): <p>The final URL used for the call. Many times it\nwill be different than the original args.url\nvalue.</p>\n</li><li>query (String): <p>For non-GET requests, the\nname1=value1&amp;name2=value2 parameters sent up in\nthe request.</p>\n</li><li>handleAs (String): <p>The final indicator on how the response will be\nhandled.</p>\n</li><li>id (String): <p>For dojo/io/script calls only, the internal\nscript ID used for the request.</p>\n</li><li>canDelete (Boolean): <p>For dojo/io/script calls only, indicates\nwhether the script tag that represents the\nrequest can be deleted after callbacks have\nbeen called. Used internally to know when\ncleanup can happen on JSONP-type requests.</p>\n</li><li>json (Object): <p>For dojo/io/script calls only: holds the JSON\nresponse for JSONP-type requests. Used\ninternally to hold on to the JSON responses.\nYou should not need to access it directly --\nthe same object should be passed to the success\ncallbacks directly.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Adds query params discovered by the io deferred construction to the URL.\nOnly use this for operations which are fundamentally GET-type operations.</p>\n"
			},
			{
				"name": "_ioCancelAll",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Cancels all pending IO requests, regardless of IO type\n(xhr, script, iframe).</p>\n"
			},
			{
				"name": "_ioNotifyStart",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "dfd",
						"types": [
							"dojo/_base/Deferred"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>If dojo.publish is available, publish topics\nabout the start of a request queue and/or the\nthe beginning of request.\n\n</p>\n<p>Used by IO transports. An IO transport should\ncall this method before making the network connection.</p>\n"
			},
			{
				"name": "_ioSetArgs",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"dojo/main.__IoArgs"
						],
						"usage": "required",
						"summary": "<p>The args object passed into the public io call. Recognized properties on\nthe args object are:</p>\n"
					},
					{
						"name": "canceller",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The canceller function used for the Deferred object. The function\nwill receive one argument, the Deferred object that is related to the\ncanceller.</p>\n"
					},
					{
						"name": "okHandler",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The first OK callback to be registered with Deferred. It has the opportunity\nto transform the OK response. It will receive one argument -- the Deferred\nobject returned from this function.</p>\n"
					},
					{
						"name": "errHandler",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The first error callback to be registered with Deferred. It has the opportunity\nto do cleanup on an error. It will receive two arguments: error (the\nError object) and dfd, the Deferred object returned from this function.</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>sets up the Deferred and ioArgs property on the Deferred so it\ncan be used in an io call.</p>\n"
			},
			{
				"name": "_ioWatch",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "dfd",
						"types": [
							"dojo/_base/Deferred"
						],
						"usage": "required",
						"summary": "<p>The Deferred object to watch.</p>\n"
					},
					{
						"name": "validCheck",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function used to check if the IO request is still valid. Gets the dfd\nobject as its only argument.</p>\n"
					},
					{
						"name": "ioCheck",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function used to check if basic IO call worked. Gets the dfd\nobject as its only argument.</p>\n"
					},
					{
						"name": "resHandle",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function used to process response. Gets the dfd\nobject as its only argument.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Watches the io request represented by dfd to see if it completes.</p>\n"
			},
			{
				"name": "_isDocumentOk",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "x",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_keypress",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "object",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_Line",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "start",
						"types": [
							"int"
						],
						"usage": "required",
						"summary": "<p>Beginning value for range</p>\n"
					},
					{
						"name": "end",
						"types": [
							"int"
						],
						"usage": "required",
						"summary": "<p>Ending value for range</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Object used to generate values from a start value to an end value</p>\n"
			},
			{
				"name": "_Url",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/url",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_xhrObj",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "addOnLoad",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/ready",
				"extensionModule": true,
				"parameters": [
					{
						"name": "priority",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The order in which to exec this callback relative to other callbacks, defaults to 1000</p>\n"
					},
					{
						"name": "context",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The context in which to run execute callback, or a callback if not using context</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The function to execute.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.\nIn most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed.\n\n</p>\n<p>When called in a non-browser environment, just checks that all requested modules have arrived and been\nevaluated.</p>\n",
				"examples": [
					"<p>Simple DOM and Modules ready syntax\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(function(){ alert(&quot;Dom ready!&quot;); });\n});</code></pre>\n",
					"<p>Using a priority\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(2, function(){ alert(&quot;low priority ready!&quot;); })\n});</code></pre>\n",
					"<p>Using context\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(foo, function(){\n        // in here, this == foo\n    });\n});</code></pre>\n",
					"<p>Using dojo/hitch style args:\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    var foo = { dojoReady: function(){ console.warn(this, &quot;dojo dom and modules ready.&quot;); } };\n    ready(foo, &quot;dojoReady&quot;);\n});</code></pre>\n"
				]
			},
			{
				"name": "anim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>a DOM node or the id of a node to animate CSS properties on</p>\n"
					},
					{
						"name": "properties",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "duration",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The number of milliseconds over which the animation\nshould run. Defaults to the global animation default duration\n(350ms).</p>\n"
					},
					{
						"name": "easing",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>An easing function over which to calculate acceleration\nand deceleration of the animation through its duration.\nA default easing algorithm is provided, but you may\nplug in any you wish. A large selection of easing algorithms\nare available in <code>dojo/fx/easing</code>.</p>\n"
					},
					{
						"name": "onEnd",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>A function to be called when the animation finishes\nrunning.</p>\n"
					},
					{
						"name": "delay",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The number of milliseconds to delay beginning the\nanimation by. The default is 0.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>A simpler interface to <code>animateProperty()</code>, also returns\nan instance of <code>Animation</code> but begins the animation\nimmediately, unlike nearly every other Dojo animation API.</p>\n",
				"description": "<p>Simpler (but somewhat less powerful) version\nof <code>animateProperty</code>.  It uses defaults for many basic properties\nand allows for positional parameters to be used in place of the\npacked &quot;property bag&quot; which is used for other Dojo animation\nmethods.\n\n</p>\n<p>The <code>Animation</code> object returned will be already playing, so\ncalling play() on it again is (usually) a no-op.</p>\n",
				"examples": [
					"<p>Fade out a node\n\n</p>\n<pre><code>basefx.anim(&quot;id&quot;, { opacity: 0 });</code></pre>\n",
					"<p>Fade out a node over a full second\n\n</p>\n<pre><code>basefx.anim(&quot;id&quot;, { opacity: 0 }, 1000);</code></pre>\n"
				]
			},
			{
				"name": "animateProperty",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>properties (Object, optional): <p>A hash map of style properties to Objects describing the transition,\nsuch as the properties of _Line with an additional &#39;units&#39; property</p>\n</li><li>node (DOMNode|String): <p>The node referenced in the animation</p>\n</li><li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p>\n</li><li>easing (Function, optional): <p>An easing function.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"instance",
					"undefined"
				],
				"summary": "<p>Returns an animation that will transition the properties of\nnode defined in <code>args</code> depending how they are defined in\n<code>args.properties</code>\n</p>\n",
				"description": "<p>Foundation of most <code>dojo/_base/fx</code>\nanimations. It takes an object of &quot;properties&quot; corresponding to\nstyle properties, and animates them in parallel over a set\nduration.\n</p>\n",
				"examples": [
					"<p>A simple animation that changes the width of the specified node.\n\n</p>\n<pre><code>basefx.animateProperty({\n    node: &quot;nodeId&quot;,\n    properties: { width: 400 },\n}).play();</code></pre>\n<p>Dojo figures out the start value for the width and converts the\n\n</p>\n<p>integer specified for the width to the more expressive but\nverbose form <code>{ width: { end: &#39;400&#39;, units: &#39;px&#39; } }</code> which you\ncan also specify directly. Defaults to &#39;px&#39; if omitted.\n</p>\n",
					"<p>Animate width, height, and padding over 2 seconds... the\npedantic way:\n\n</p>\n<pre><code>basefx.animateProperty({ node: node, duration:2000,\n    properties: {\n        width: { start: &#39;200&#39;, end: &#39;400&#39;, units:&quot;px&quot; },\n        height: { start:&#39;200&#39;, end: &#39;400&#39;, units:&quot;px&quot; },\n        paddingTop: { start:&#39;5&#39;, end:&#39;50&#39;, units:&quot;px&quot; }\n    }\n}).play();</code></pre>\n<p>Note &#39;paddingTop&#39; is used over &#39;padding-top&#39;. Multi-name CSS properties\n\n</p>\n<p>are written using &quot;mixed case&quot;, as the hyphen is illegal as an object key.\n</p>\n",
					"<p>Plug in a different easing function and register a callback for\nwhen the animation ends. Easing functions accept values between\nzero and one and return a value on that basis. In this case, an\nexponential-in curve.\n\n</p>\n<pre><code>basefx.animateProperty({\n    node: &quot;nodeId&quot;,\n    // dojo figures out the start value\n    properties: { width: { end: 400 } },\n    easing: function(n){\n        return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));\n    },\n    onEnd: function(node){\n        // called when the animation finishes. The animation\n        // target is passed to this function\n    }\n}).play(500); // delay playing half a second</code></pre>\n",
					"<p>Like all <code>Animation</code>s, animateProperty returns a handle to the\nAnimation instance, which fires the events common to Dojo FX. Use <code>aspect.after</code>\nto access these events outside of the Animation definition:\n\n</p>\n<pre><code>var anim = basefx.animateProperty({\n    node:&quot;someId&quot;,\n    properties:{\n        width:400, height:500\n    }\n});\naspect.after(anim, &quot;onEnd&quot;, function(){\n    console.log(&quot;animation ended&quot;);\n}, true);\n// play the animation now:\nanim.play();</code></pre>\n",
					"<p>Each property can be a function whose return value is substituted along.\nAdditionally, each measurement (eg: start, end) can be a function. The node\nreference is passed directly to callbacks.\n\n</p>\n<pre><code>basefx.animateProperty({\n    node:&quot;mine&quot;,\n    properties:{\n        height:function(node){\n            // shrink this node by 50%\n            return domGeom.position(node).h / 2\n        },\n        width:{\n            start:function(node){ return 100; },\n            end:function(node){ return 200; }\n        }\n    }\n}).play();</code></pre>\n"
				]
			},
			{
				"name": "Animation",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The &#39;magic argument&#39;, mixing all the properties into this\nanimation instance.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>A generic animation class that fires callbacks into its handlers\nobject at various states.</p>\n",
				"description": "<p>A generic animation class that fires callbacks into its handlers\nobject at various states. Nearly all dojo animation functions\nreturn an instance of this method, usually without calling the\n.play() method beforehand. Therefore, you will likely need to\ncall .play() on instances of <code>Animation</code> when one is\nreturned.</p>\n"
			},
			{
				"name": "blendColors",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "start",
						"types": [
							"havok/form/Color"
						],
						"usage": "required"
					},
					{
						"name": "end",
						"types": [
							"havok/form/Color"
						],
						"usage": "required"
					},
					{
						"name": "weight",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,\ncan reuse a previously allocated Color object for the result</p>\n"
			},
			{
				"name": "body",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return the body element of the specified document or of dojo/_base/window::doc.</p>\n",
				"examples": [
					"<pre><code>win.body().appendChild(dojo.doc.createElement(&#39;div&#39;));</code></pre>\n"
				]
			},
			{
				"name": "cache",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/text",
				"extensionModule": true,
				"parameters": [
					{
						"name": "module",
						"types": [
							"String",
							"Object"
						],
						"usage": "required",
						"summary": "<p>dojo/number</p>\n"
					},
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The rest of the path to append to the path derived from the module argument. If\nmodule is an object, then this second argument should be the &quot;value&quot; argument instead.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "optional",
						"summary": "<p>If a String, the value to use in the cache for the module/url combination.\nIf an Object, it can have two properties: value and sanitize. The value property\nshould be the value to use in the cache, and sanitize can be set to true or false,\nto indicate if XML declarations should be removed from the value and if the HTML\ninside a body tag in the value should be extracted as the real value. The value argument\nor the value property on the value argument are usually only used by the build system\nas it inlines cache content.</p>\n"
					}
				],
				"returnTypes": [
					"undefined",
					"null"
				],
				"summary": "<p>A getter and setter for storing the string content associated with the\nmodule and url arguments.</p>\n",
				"description": "<p>If module is a string that contains slashes, then it is interpretted as a fully\nresolved path (typically a result returned by require.toUrl), and url should not be\nprovided. This is the preferred signature. If module is a string that does not\ncontain slashes, then url must also be provided and module and url are used to\ncall <code>dojo.moduleUrl()</code> to generate a module URL. This signature is deprecated.\nIf value is specified, the cache value for the moduleUrl will be set to\nthat value. Otherwise, dojo.cache will fetch the moduleUrl and store it\nin its internal cache and return that cached value for the URL. To clear\na cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the\nthe URL contents, only modules on the same domain of the page can use this capability.\nThe build system can inline the cache values though, to allow for xdomain hosting.</p>\n",
				"examples": [
					"<p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&quot;cache&quot;] style\nof call is used to avoid an issue with the build system erroneously trying to intern\nthis example. To get the build system to intern your dojo.cache calls, use the\n&quot;dojo.cache&quot; style of call):\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot; that will be\n//the value for the text variable.\nvar text = dojo[&quot;cache&quot;](&quot;my.module&quot;, &quot;template.html&quot;);</code></pre>\n",
					"<p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input\n (the dojo[&quot;cache&quot;] style of call is used to avoid an issue with the build system\nerroneously trying to intern this example. To get the build system to intern your\ndojo.cache calls, use the &quot;dojo.cache&quot; style of call):\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the\n//text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.\nvar text = dojo[&quot;cache&quot;](&quot;my.module&quot;, &quot;template.html&quot;, {sanitize: true});</code></pre>\n",
					"<p>Same example as previous, but demonstrates how an object can be passed in as\nthe first argument, then the value argument can then be the second argument.\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the\n//text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.\nvar text = dojo[&quot;cache&quot;](new dojo._Url(&quot;my/module/template.html&quot;), {sanitize: true});</code></pre>\n"
				]
			},
			{
				"name": "clearCache",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "Color",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "color",
						"types": [
							"Array",
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand creates a new Color instance to work from.\n</p>\n",
				"examples": [
					"<p>Work with a Color instance:\n\n</p>\n<pre><code>var c = new Color();\nc.setColor([0,0,0]); // black\nvar hex = c.toHex(); // #000000</code></pre>\n",
					"<p>Work with a node&#39;s color:\n\n</p>\n<pre><code>var color = dojo.style(&quot;someNode&quot;, &quot;backgroundColor&quot;);\nvar n = new Color(color);\n// adjust the color some\nn.r *= .5;\nconsole.log(n.toString()); // rgb(128, 255, 255);</code></pre>\n"
				]
			},
			{
				"name": "colorFromArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "a",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Builds a <code>Color</code> from a 3 or 4 element array, mapping each\nelement in sequence to the rgb(a) values of the color.</p>\n",
				"examples": [
					"<pre><code>var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha</code></pre>\n"
				]
			},
			{
				"name": "colorFromHex",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "color",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any",
					"null",
					"string"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.\n</p>\n",
				"summary": "<p>Converts a hex string with a &#39;#&#39; prefix to a color object.\nSupports 12-bit #rgb shorthand. Optionally accepts a\n<code>Color</code> object to update with the parsed value.\n</p>\n",
				"examples": [
					"<pre><code>var thing = dojo.colorFromHex(&quot;#ededed&quot;); // grey, longhand</code></pre>\n",
					"<pre><code>var thing = dojo.colorFromHex(&quot;#000&quot;); // black, shorthand</code></pre>\n"
				]
			},
			{
				"name": "colorFromRgb",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "color",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Returns a <code>Color</code> instance from a string of the form\n&quot;rgb(...)&quot; or &quot;rgba(...)&quot;. Optionally accepts a <code>Color</code>\nobject to update with the parsed value and return instead of\ncreating a new object.</p>\n"
			},
			{
				"name": "colorFromString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Parses <code>str</code> for a color value. Accepts hex, rgb, and rgba\nstyle color values.</p>\n",
				"description": "<p>Acceptable input values for str may include arrays of any form\naccepted by dojo.colorFromArray, hex strings such as &quot;#aaaaaa&quot;, or\nrgb or rgba strings such as &quot;rgb(133, 200, 16)&quot; or &quot;rgba(10, 10,\n10, 50)&quot;</p>\n"
			},
			{
				"name": "connect",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The source object for the event function.\nDefaults to <code>kernel.global</code> if null.\nIf obj is a DOM node, the connection is delegated\nto the DOM event manager (unless dontFix is true).\n</p>\n"
					},
					{
						"name": "event",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String name of the event function in obj.\nI.e. identifies a property <code>obj[event]</code>.\n</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>The object that method will receive as &quot;this&quot;.\n\n</p>\n<p>If context is null and method is a function, then method\ninherits the context of event.\n\n</p>\n<p>If method is a string then context must be the source\nobject object for method (context[method]). If context is null,\nkernel.global is used.\n</p>\n"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>A function reference, or name of a function in context.\nThe function identified by method fires after event does.\nmethod receives the same arguments as the event.\nSee context argument comments for information on method&#39;s scope.\n</p>\n"
					},
					{
						"name": "dontFix",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If obj is a DOM node, set dontFix to true to prevent delegation\nof this connection to the DOM event manager.\n</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p><code>dojo.connect</code> is a deprecated event handling and delegation method in\nDojo. It allows one function to &quot;listen in&quot; on the execution of\nany other, triggering the second whenever the first is called. Many\nlisteners may be attached to a function, and source functions may\nbe either regular function calls or DOM events.\n</p>\n",
				"description": "<p>Connects listeners to actions, so that after event fires, a\nlistener is called with the same arguments passed to the original\nfunction.\n\n</p>\n<p>Since <code>dojo.connect</code> allows the source of events to be either a\n&quot;regular&quot; JavaScript function or a DOM event, it provides a uniform\ninterface for listening to all the types of events that an\napplication is likely to deal with though a single, unified\ninterface. DOM programmers may want to think of it as\n&quot;addEventListener for everything and anything&quot;.\n\n</p>\n<p>When setting up a connection, the <code>event</code> parameter must be a\nstring that is the name of the method/event to be listened for. If\n<code>obj</code> is null, <code>kernel.global</code> is assumed, meaning that connections\nto global methods are supported but also that you may inadvertently\nconnect to a global by passing an incorrect object name or invalid\nreference.\n\n</p>\n<p><code>dojo.connect</code> generally is forgiving. If you pass the name of a\nfunction or method that does not yet exist on <code>obj</code>, connect will\nnot fail, but will instead set up a stub method. Similarly, null\narguments may simply be omitted such that fewer than 4 arguments\nmay be required to set up a connection See the examples for details.\n\n</p>\n<p>The return value is a handle that is needed to\nremove this connection with <code>dojo.disconnect</code>.\n</p>\n",
				"examples": [
					"<p>When obj.onchange(), do ui.update():\n\n</p>\n<pre><code>dojo.connect(obj, &quot;onchange&quot;, ui, &quot;update&quot;);\ndojo.connect(obj, &quot;onchange&quot;, ui, ui.update); // same</code></pre>\n",
					"<p>Using return value for disconnect:\n\n</p>\n<pre><code>var link = dojo.connect(obj, &quot;onchange&quot;, ui, &quot;update&quot;);\n...\ndojo.disconnect(link);</code></pre>\n",
					"<p>When onglobalevent executes, watcher.handler is invoked:\n\n</p>\n<pre><code>dojo.connect(null, &quot;onglobalevent&quot;, watcher, &quot;handler&quot;);</code></pre>\n",
					"<p>When ob.onCustomEvent executes, customEventHandler is invoked:\n\n</p>\n<pre><code>dojo.connect(ob, &quot;onCustomEvent&quot;, null, &quot;customEventHandler&quot;);\ndojo.connect(ob, &quot;onCustomEvent&quot;, &quot;customEventHandler&quot;); // same</code></pre>\n",
					"<p>When ob.onCustomEvent executes, customEventHandler is invoked\nwith the same scope (this):\n\n</p>\n<pre><code>dojo.connect(ob, &quot;onCustomEvent&quot;, null, customEventHandler);\ndojo.connect(ob, &quot;onCustomEvent&quot;, customEventHandler); // same</code></pre>\n",
					"<p>When globalEvent executes, globalHandler is invoked\nwith the same scope (this):\n\n</p>\n<pre><code>dojo.connect(null, &quot;globalEvent&quot;, null, globalHandler);\ndojo.connect(&quot;globalEvent&quot;, globalHandler); // same</code></pre>\n"
				]
			},
			{
				"name": "connectPublisher",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the topic to publish.</p>\n"
					},
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The source object for the event function. Defaults to kernel.global\nif null.</p>\n"
					},
					{
						"name": "event",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the event function in obj.\nI.e. identifies a property obj[event].</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Ensure that every time obj.event() is called, a message is published\non the topic. Returns a handle which can be passed to\ndojo.disconnect() to disable subsequent automatic publication on\nthe topic.</p>\n",
				"examples": [
					"<pre><code>dojo.connectPublisher(&quot;/ajax/start&quot;, dojo, &quot;xhrGet&quot;);</code></pre>\n"
				]
			},
			{
				"name": "declare",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"extensionModule": true,
				"parameters": [
					{
						"name": "className",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>The optional name of the constructor (loosely, a &quot;class&quot;)\nstored in the &quot;declaredClass&quot; property in the created prototype.\nIt will be used as a global name for a created constructor.</p>\n"
					},
					{
						"name": "superclass",
						"types": [
							"Function",
							"Function[]"
						],
						"usage": "required",
						"summary": "<p>May be null, a Function, or an Array of Functions. This argument\nspecifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object whose properties are copied to the created prototype.\nAdd an instance-initialization function by making it a property\nnamed &quot;constructor&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/_base/declare.__DeclareCreatedObject",
					"undefined"
				],
				"returnDescription": "<p>New constructor function.</p>\n",
				"summary": "<p>Create a feature-rich constructor from compact notation.</p>\n",
				"description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n\n</p>\n<p>Ancestors can be compound classes created by this version of\ndeclare(). In complex cases all base classes are going to be\nlinearized according to C3 MRO algorithm\n(see <a href=\"http://www.python.org/download/releases/2.3/mro/\">http://www.python.org/download/releases/2.3/mro/</a> for more\ndetails).\n\n</p>\n<p>&quot;className&quot; is cached in &quot;declaredClass&quot; property of the new class,\nif it was supplied. The immediate super class will be cached in\n&quot;superclass&quot; property of the new class.\n\n</p>\n<p>Methods in &quot;props&quot; will be copied and modified: &quot;nom&quot; property\n(the declared name of the method) will be added to all copied\nfunctions to help identify them for the internal machinery. Be\nvery careful, while reusing methods: if you use the same\nfunction under different names, it can produce errors in some\ncases.\n\n</p>\n<p>It is possible to use constructors created &quot;manually&quot; (without\ndeclare()) as bases. They will be called as usual during the\ncreation of an instance, their methods will be chained, and even\ncalled by &quot;this.inherited()&quot;.\n\n</p>\n<p>Special property &quot;-chains-&quot; governs how to chain methods. It is\na dictionary, which uses method names as keys, and hint strings\nas values. If a hint string is &quot;after&quot;, this method will be\ncalled after methods of its base classes. If a hint string is\n&quot;before&quot;, this method will be called before methods of its base\nclasses.\n\n</p>\n<p>If &quot;constructor&quot; is not mentioned in &quot;-chains-&quot; property, it will\nbe chained using the legacy mode: using &quot;after&quot; chaining,\ncalling preamble() method before each constructor, if available,\nand calling postscript() after all constructors were executed.\nIf the hint is &quot;after&quot;, it is chained as a regular method, but\npostscript() will be called after the chain of constructors.\n&quot;constructor&quot; cannot be chained &quot;before&quot;, but it allows\na special hint string: &quot;manual&quot;, which means that constructors\nare not going to be chained in any way, and programmer will call\nthem manually using this.inherited(). In the latter case\npostscript() will be called after the construction.\n\n</p>\n<p>All chaining hints are &quot;inherited&quot; from base classes and\npotentially can be overridden. Be very careful when overriding\nhints! Make sure that all chained methods can work in a proposed\nmanner of chaining.\n\n</p>\n<p>Once a method was chained, it is impossible to unchain it. The\nonly exception is &quot;constructor&quot;. You don&#39;t need to define a\nmethod in order to supply a chaining hint.\n\n</p>\n<p>If a method is chained, it cannot use this.inherited() because\nall other methods in the hierarchy will be called automatically.\n\n</p>\n<p>Usually constructors and initializers of any kind are chained\nusing &quot;after&quot; and destructors of any kind are chained as\n&quot;before&quot;. Note that chaining assumes that chained methods do not\nreturn any value: any returned value will be discarded.\n</p>\n",
				"examples": [
					"<pre><code>declare(&quot;my.classes.bar&quot;, my.classes.foo, {\n    // properties to be added to the class prototype\n    someValue: 2,\n    // initialization function\n    constructor: function(){\n        this.myComplicatedObject = new ReallyComplicatedObject();\n    },\n    // other functions\n    someMethod: function(){\n        doStuff();\n    }\n});</code></pre>\n",
					"<pre><code>var MyBase = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass1 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass2 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyDiamond = declare([MyClass1, MyClass2], {\n    // constructor, properties, and methods go here\n    // ...\n});</code></pre>\n",
					"<pre><code>var F = function(){ console.log(&quot;raw constructor&quot;); };\nF.prototype.method = function(){\n    console.log(&quot;raw method&quot;);\n};\nvar A = declare(F, {\n    constructor: function(){\n        console.log(&quot;A.constructor&quot;);\n    },\n    method: function(){\n        console.log(&quot;before calling F.method...&quot;);\n        this.inherited(arguments);\n        console.log(&quot;...back in A&quot;);\n    }\n});\nnew A().method();\n// will print:\n// raw constructor\n// A.constructor\n// before calling F.method...\n// raw method\n// ...back in A</code></pre>\n",
					"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        destroy: &quot;before&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        console.log(&quot;B.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;B.destroy&quot;);\n    }\n});\nvar C = declare(B, {\n    constructor: function(){\n        console.log(&quot;C.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;C.destroy&quot;);\n    }\n});\nnew C().destroy();\n// prints:\n// B.constructor\n// C.constructor\n// C.destroy\n// B.destroy</code></pre>\n",
					"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        constructor: &quot;manual&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        // ...\n        // call the base constructor with new parameters\n        this.inherited(arguments, [1, 2, 3]);\n        // ...\n    }\n});</code></pre>\n",
					"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        m1: &quot;before&quot;\n    },\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    &quot;-chains-&quot;: {\n        m2: &quot;after&quot;\n    },\n    m1: function(){\n        console.log(&quot;B.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\nx.m1();\n// prints:\n// B.m1\n// A.m1\nx.m2();\n// prints:\n// A.m2\n// B.m2</code></pre>\n"
				]
			},
			{
				"name": "Deferred",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"extensionModule": true,
				"parameters": [
					{
						"name": "canceller",
						"types": [
							"Function"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.\nNew code should use dojo/Deferred instead.</p>\n",
				"description": "<p>The Deferred API is based on the concept of promises that provide a\ngeneric interface into the eventual completion of an asynchronous action.\nThe motivation for promises fundamentally is about creating a\nseparation of concerns that allows one to achieve the same type of\ncall patterns and logical data flow in asynchronous code as can be\nachieved in synchronous code. Promises allows one\nto be able to call a function purely with arguments needed for\nexecution, without conflating the call with concerns of whether it is\nsync or async. One shouldn&#39;t need to alter a call&#39;s arguments if the\nimplementation switches from sync to async (or vice versa). By having\nasync functions return promises, the concerns of making the call are\nseparated from the concerns of asynchronous interaction (which are\nhandled by the promise).\n\n</p>\n<p>The Deferred is a type of promise that provides methods for fulfilling the\npromise with a successful result or an error. The most important method for\nworking with Dojo&#39;s promises is the then() method, which follows the\nCommonJS proposed promise API. An example of using a Dojo promise:\n\n\n</p>\n<pre><code>var resultingPromise = someAsyncOperation.then(function(result){\n    ... handle result ...\n},\nfunction(error){\n    ... handle error ...\n});</code></pre>\n<p>The .then() call returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.\n\n</p>\n<p>The Deferred instances also provide the following functions for backwards compatibility:\n\n</p>\n<ul>\n<li>addCallback(handler)</li>\n<li>addErrback(handler)</li>\n<li>callback(result)</li>\n<li>errback(result)</li>\n</ul>\n<p>Callbacks are allowed to return promises themselves, so\nyou can build complicated sequences of events with ease.\n\n</p>\n<p>The creator of the Deferred may specify a canceller.  The canceller\nis a function that will be called if Deferred.cancel is called\nbefore the Deferred fires. You can use this to implement clean\naborting of an XMLHttpRequest, etc. Note that cancel will fire the\ndeferred with a CancelledError (unless your canceller returns\nanother kind of error), so the errbacks should be prepared to\nhandle that error for cancellable Deferreds.</p>\n",
				"examples": [
					"<pre><code>var deferred = new Deferred();\nsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\nreturn deferred;</code></pre>\n",
					"<p>Deferred objects are often used when making code asynchronous. It\nmay be easiest to write functions in a synchronous manner and then\nsplit code using a deferred to trigger a response to a long-lived\noperation. For example, instead of register a callback function to\ndenote when a rendering operation completes, the function can\nsimply return a deferred:\n\n\n</p>\n<pre><code>// callback style:\nfunction renderLotsOfData(data, callback){\n    var success = false\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        success = true;\n    }catch(e){ }\n    if(callback){\n        callback(success);\n    }\n}\n\n\n// using callback style\nrenderLotsOfData(someDataObj, function(success){\n    // handles success or failure\n    if(!success){\n        promptUserToRecover();\n    }\n});\n// NOTE: no way to add another callback here!!</code></pre>\n",
					"<p>Using a Deferred doesn&#39;t simplify the sending code any, but it\nprovides a standard interface for callers and senders alike,\nproviding both with a simple way to service multiple callbacks for\nan operation and freeing both sides from worrying about details\nsuch as &quot;did this get called already?&quot;. With Deferreds, new\ncallbacks can be added at any time.\n\n\n</p>\n<pre><code>// Deferred style:\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        d.callback(true);\n    }catch(e){\n        d.errback(new Error(&quot;rendering failed&quot;));\n    }\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n// NOTE: addErrback and addCallback both return the Deferred\n// again, so we could chain adding callbacks or save the\n// deferred for later should we need to be notified again.</code></pre>\n",
					"<p>In this example, renderLotsOfData is synchronous and so both\nversions are pretty artificial. Putting the data display on a\ntimeout helps show why Deferreds rock:\n\n\n</p>\n<pre><code>// Deferred style and async func\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    setTimeout(function(){\n        try{\n            for(var x in data){\n                renderDataitem(data[x]);\n            }\n            d.callback(true);\n        }catch(e){\n            d.errback(new Error(&quot;rendering failed&quot;));\n        }\n    }, 100);\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});</code></pre>\n<p>Note that the caller doesn&#39;t have to change his code at all to\nhandle the asynchronous case.</p>\n"
				]
			},
			{
				"name": "DeferredList",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/DeferredList",
				"extensionModule": true,
				"parameters": [
					{
						"name": "list",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>The list of deferreds to be synchronizied with this DeferredList</p>\n"
					},
					{
						"name": "fireOnOneCallback",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Will cause the DeferredLists callback to be fired as soon as any\nof the deferreds in its list have been fired instead of waiting until\nthe entire list has finished</p>\n"
					},
					{
						"name": "fireOnOneErrback",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					},
					{
						"name": "consumeErrors",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					},
					{
						"name": "canceller",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>A deferred canceller function, see dojo.Deferred</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, use dojo/promise/all instead.\nProvides event handling for a group of Deferred objects.</p>\n",
				"description": "<p>DeferredList takes an array of existing deferreds and returns a new deferred of its own\nthis new deferred will typically have its callback fired when all of the deferreds in\nthe given list have fired their own deferreds.  The parameters <code>fireOnOneCallback</code> and\nfireOnOneErrback, will fire before all the deferreds as appropriate</p>\n"
			},
			{
				"name": "deprecated",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/kernel",
				"parameters": [
					{
						"name": "behaviour",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The API or behavior being deprecated. Usually in the form\nof &quot;myApp.someFunction()&quot;.</p>\n"
					},
					{
						"name": "extra",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Text to append to the message. Often provides advice on a\nnew function or facility to achieve the same goal during\nthe deprecation period.</p>\n"
					},
					{
						"name": "removal",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Text to indicate when in the future the behavior will be\nremoved. Usually a version number.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Log a debug message to indicate that a behavior has been\ndeprecated.</p>\n",
				"examples": [
					"<pre><code>dojo.deprecated(&quot;myApp.getTemp()&quot;, &quot;use myApp.getLocaleTemp() instead&quot;, &quot;1.0&quot;);</code></pre>\n"
				]
			},
			{
				"name": "disconnect",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Handle"
						],
						"usage": "required",
						"summary": "<p>the return value of the dojo.connect call that created the connection.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Remove a link created by dojo.connect.</p>\n",
				"description": "<p>Removes the connection between event and the method referenced by handle.</p>\n"
			},
			{
				"name": "eval",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/kernel",
				"parameters": [
					{
						"name": "scriptText",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The text to evaluation.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>The result of the evaluation. Often <code>undefined</code></p>\n",
				"summary": "<p>A legacy method created for use exclusively by internal Dojo methods. Do not use this method\ndirectly unless you understand its possibly-different implications on the platforms your are targeting.</p>\n",
				"description": "<p>Makes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers\nthat support indirect eval.\n\n</p>\n<p>As usual, IE does not. On IE, the only way to implement global eval is to\nuse execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.\nThis implementation uses the technique of executing eval in the scope of a function that is a single scope\nframe below the global scope; thereby coming close to the global scope. Note carefully that\n\n</p>\n<p>dojo.eval(&quot;var pi = 3.14;&quot;);\n\n</p>\n<p>will define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want\nto define a global variable using dojo.eval, write something like\n\n</p>\n<p>dojo.eval(&quot;window.pi = 3.14;&quot;)</p>\n"
			},
			{
				"name": "every",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate on. If a string, operates on individual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments: item, index,\nand array and returns true if the condition is met.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Determines whether or not every item in arr satisfies the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s every skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</a></p>\n",
				"examples": [
					"<pre><code>// returns false\narray.every([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n",
					"<pre><code>// returns true\narray.every([1, 2, 3, 4], function(item){ return item&gt;0; });</code></pre>\n"
				]
			},
			{
				"name": "exit",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/kernel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "experimental",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/kernel",
				"parameters": [
					{
						"name": "moduleName",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of a module, or the name of a module file or a specific\nfunction</p>\n"
					},
					{
						"name": "extra",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>some additional message for the user</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Marks code as experimental.</p>\n",
				"description": "<p>This can be used to mark a function, file, or module as\nexperimental.    Experimental code is not ready to be used, and the\nAPIs are subject to change without notice.  Experimental code may be\ncompleted deleted without going through the normal deprecation\nprocess.</p>\n",
				"examples": [
					"<pre><code>dojo.experimental(&quot;dojo.data.Result&quot;);</code></pre>\n",
					"<pre><code>dojo.experimental(&quot;dojo.weather.toKelvin()&quot;, &quot;PENDING approval from NOAA&quot;);</code></pre>\n"
				]
			},
			{
				"name": "fadeIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>node (DOMNode|String): <p>The node referenced in the animation</p>\n</li><li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p>\n</li><li>easing (Function, optional): <p>An easing function.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns an animation that will fade node defined in &#39;args&#39; from\nits current opacity to fully opaque.</p>\n"
			},
			{
				"name": "fadeOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>node (DOMNode|String): <p>The node referenced in the animation</p>\n</li><li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p>\n</li><li>easing (Function, optional): <p>An easing function.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns an animation that will fade node defined in &#39;args&#39;\nfrom its current opacity to fully transparent.</p>\n"
			},
			{
				"name": "fieldToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"extensionModule": true,
				"parameters": [
					{
						"name": "inputNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"summary": "<p>Serialize a form field to a JavaScript object.</p>\n",
				"description": "<p>Returns the value encoded in a form field as\nas a string or an array of strings. Disabled form elements\nand unchecked radio and checkboxes are skipped. Multi-select\nelements are returned as an array of string values.</p>\n"
			},
			{
				"name": "filter",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>the array to iterate over.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function that is invoked with three arguments (item,\nindex, array). The return of this function is expected to\nbe a boolean which determines whether the passed-in item\nwill be included in the returned array.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns a new Array with those items from arr that match the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s filter skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</a></p>\n",
				"examples": [
					"<pre><code>// returns [2, 3, 4]\narray.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n"
				]
			},
			{
				"name": "fixEvent",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/event",
				"extensionModule": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>native event object</p>\n"
					},
					{
						"name": "sender",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>node to treat as &quot;currentTarget&quot;</p>\n"
					}
				],
				"returnTypes": [
					"Event"
				],
				"returnDescription": "<p>native event object</p>\n",
				"summary": "<p>normalizes properties on the event object including event\nbubbling methods, keystroke normalization, and x/y positions</p>\n"
			},
			{
				"name": "forEach",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>for every item in arr, callback is invoked. Return values are ignored.\nIf you want to break out of the loop, consider using array.every() or array.some().\nforEach does not allow breaking out of the loop over the items in arr.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s forEach skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</a></p>\n",
				"examples": [
					"<pre><code>// log out all members of the array:\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      function(item){\n          console.log(item);\n      }\n);</code></pre>\n",
					"<pre><code>// log out the members and their indexes\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      function(item, idx, arr){\n          console.log(item, &quot;at index:&quot;, idx);\n      }\n);</code></pre>\n",
					"<pre><code>// use a scoped object member as the callback\n\nvar obj = {\n      prefix: &quot;logged via obj.callback:&quot;,\n      callback: function(item){\n          console.log(this.prefix, item);\n      }\n};\n\n// specifying the scope function executes the callback in that scope\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      obj.callback,\n      obj\n);\n\n// alternately, we can accomplish the same thing with lang.hitch()\narray.forEach(\n      [ &quot;thinger&quot;, &quot;blah&quot;, &quot;howdy&quot;, 10 ],\n      lang.hitch(obj, &quot;callback&quot;)\n);</code></pre>\n"
				]
			},
			{
				"name": "formToJson",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"extensionModule": true,
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "prettyPrint",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"summary": "<p>Create a serialized JSON string from a form node or string\nID identifying the form to serialize</p>\n"
			},
			{
				"name": "formToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"extensionModule": true,
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Serialize a form node to a JavaScript object.</p>\n",
				"description": "<p>Returns the values encoded in an HTML form as\nstring properties in an object which it then returns. Disabled form\nelements, buttons, and other non-value form elements are skipped.\nMulti-select elements are returned as an array of string values.</p>\n",
				"examples": [
					"<p>This form:\n\n</p>\n<pre><code>&lt;form id=&quot;test_form&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;blah&quot; value=&quot;blah&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;no_value&quot; value=&quot;blah&quot; disabled&gt;\n    &lt;input type=&quot;button&quot; name=&quot;no_value2&quot; value=&quot;blah&quot;&gt;\n    &lt;select type=&quot;select&quot; multiple name=&quot;multi&quot; size=&quot;5&quot;&gt;\n        &lt;option value=&quot;blah&quot;&gt;blah&lt;/option&gt;\n        &lt;option value=&quot;thud&quot; selected&gt;thud&lt;/option&gt;\n        &lt;option value=&quot;thonk&quot; selected&gt;thonk&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/form&gt;</code></pre>\n<p>yields this object structure as the result of a call to\nformToObject():\n\n\n</p>\n<pre><code>{\n    blah: &quot;blah&quot;,\n    multi: [\n        &quot;thud&quot;,\n        &quot;thonk&quot;\n    ]\n};</code></pre>\n"
				]
			},
			{
				"name": "formToQuery",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"extensionModule": true,
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"summary": "<p>Returns a URL-encoded string representing the form passed as either a\nnode or string ID identifying the form to serialize</p>\n"
			},
			{
				"name": "fromJson",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/json",
				"extensionModule": true,
				"parameters": [
					{
						"name": "js",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>a string literal of a JavaScript expression, for instance:\n<code>&#39;{ &quot;foo&quot;: [ &quot;bar&quot;, 1, { &quot;baz&quot;: &quot;thud&quot; } ] }&#39;</code></p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Parses a JavaScript expression and returns a JavaScript value.</p>\n",
				"description": "<p>Throws for invalid JavaScript expressions. It does not use a strict JSON parser. It\nalways delegates to eval(). The content passed to this method must therefore come\nfrom a trusted source.\nIt is recommend that you use dojo/json&#39;s parse function for an\nimplementation uses the (faster) native JSON parse when available.</p>\n"
			},
			{
				"name": "getL10nName",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"parameters": [
					{
						"name": "moduleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "bundleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "indexOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "fromIndex",
						"types": [
							"Integer"
						],
						"usage": "optional"
					},
					{
						"name": "findLast",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Makes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.</p>\n"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>locates the first index of the provided value in the\npassed array. If the value is not found, -1 is returned.</p>\n",
				"description": "<p>This method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\n\n</p>\n<ol>\n<li>when run over sparse arrays, the Dojo function invokes the callback for every index\nwhereas JavaScript 1.6&#39;s indexOf skips the holes in the sparse array.</li>\n<li>uses equality (==) rather than strict equality (===)</li>\n</ol>\n<p>For details on this method, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</a></p>\n"
			},
			{
				"name": "isCopyKey",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "e",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>Event object to examine</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)</p>\n"
			},
			{
				"name": "lastIndexOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "fromIndex",
						"types": [
							"Integer"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>locates the last index of the provided value in the passed\narray. If the value is not found, -1 is returned.</p>\n",
				"description": "<p>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\n\n</p>\n<ol>\n<li>when run over sparse arrays, the Dojo function invokes the callback for every index\nwhereas JavaScript 1.6&#39;s lasIndexOf skips the holes in the sparse array.</li>\n<li>uses equality (==) rather than strict equality (===)</li>\n</ol>\n<p>For details on this method, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</a></p>\n"
			},
			{
				"name": "map",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate on. If a string, operates on\nindividual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments, (item, index,\narray),  and returns a value</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					},
					{
						"name": "Ctr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Array",
					"instance"
				],
				"summary": "<p>applies callback to each element of arr and returns\nan Array with the results</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s map skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</a></p>\n",
				"examples": [
					"<pre><code>// returns [2, 3, 4, 5]\narray.map([1, 2, 3, 4], function(item){ return item+1 });</code></pre>\n"
				]
			},
			{
				"name": "moduleUrl",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/kernel",
				"parameters": [
					{
						"name": "module",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>dojo/text</p>\n"
					},
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a URL relative to a module.</p>\n",
				"examples": [
					"<pre><code>var pngPath = dojo.moduleUrl(&quot;acme&quot;,&quot;images/small.png&quot;);\nconsole.dir(pngPath); // list the object properties\n// create an image and set it&#39;s source to pngPath&#39;s value:\nvar img = document.createElement(&quot;img&quot;);\nimg.src = pngPath;\n// add our image to the document\ndojo.body().appendChild(img);</code></pre>\n",
					"<p>you may de-reference as far as you like down the package\nhierarchy.  This is sometimes handy to avoid lenghty relative\nurls or for building portable sub-packages. In this example,\nthe <code>acme.widget</code> and <code>acme.util</code> directories may be located\nunder different roots (see <code>dojo.registerModulePath</code>) but the\nthe modules which reference them can be unaware of their\nrelative locations on the filesystem:\n\n</p>\n<pre><code>// somewhere in a configuration block\ndojo.registerModulePath(&quot;acme.widget&quot;, &quot;../../acme/widget&quot;);\ndojo.registerModulePath(&quot;acme.util&quot;, &quot;../../util&quot;);\n\n// ...\n\n// code in a module using acme resources\nvar tmpltPath = dojo.moduleUrl(&quot;acme.widget&quot;,&quot;templates/template.html&quot;);\nvar dataPath = dojo.moduleUrl(&quot;acme.util&quot;,&quot;resources/data.json&quot;);</code></pre>\n"
				]
			},
			{
				"name": "NodeList",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/query",
				"extensionModule": true,
				"parameters": [
					{
						"name": "array",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Array-like object which adds syntactic\nsugar for chaining, common iteration operations, animation, and\nnode manipulation. NodeLists are most often returned as the\nresult of dojo.query() calls.</p>\n",
				"description": "<p>NodeList instances provide many utilities that reflect\ncore Dojo APIs for Array iteration and manipulation, DOM\nmanipulation, and event handling. Instead of needing to dig up\nfunctions in the dojo.* namespace, NodeLists generally make the\nfull power of Dojo available for DOM manipulation tasks in a\nsimple, chainable way.</p>\n",
				"examples": [
					"<p>create a node list from a node\n\n</p>\n<pre><code>new query.NodeList(dojo.byId(&quot;foo&quot;));</code></pre>\n",
					"<p>get a NodeList from a CSS query and iterate on it\n\n</p>\n<pre><code>var l = dojo.query(&quot;.thinger&quot;);\nl.forEach(function(node, index, nodeList){\n    console.log(index, node.innerHTML);\n});</code></pre>\n",
					"<p>use native and Dojo-provided array methods to manipulate a\nNodeList without needing to use dojo.* functions explicitly:\n\n</p>\n<pre><code>var l = dojo.query(&quot;.thinger&quot;);\n// since NodeLists are real arrays, they have a length\n// property that is both readable and writable and\n// push/pop/shift/unshift methods\nconsole.log(l.length);\nl.push(dojo.create(&quot;span&quot;));\n\n// dojo&#39;s normalized array methods work too:\nconsole.log( l.indexOf(dojo.byId(&quot;foo&quot;)) );\n// ...including the special &quot;function as string&quot; shorthand\nconsole.log( l.every(&quot;item.nodeType == 1&quot;) );\n\n// NodeLists can be [..] indexed, or you can use the at()\n// function to get specific items wrapped in a new NodeList:\nvar node = l[3]; // the 4th element\nvar newList = l.at(1, 3); // the 2nd and 4th elements</code></pre>\n",
					"<p>the style functions you expect are all there too:\n\n</p>\n<pre><code>// style() as a getter...\nvar borders = dojo.query(&quot;.thinger&quot;).style(&quot;border&quot;);\n// ...and as a setter:\ndojo.query(&quot;.thinger&quot;).style(&quot;border&quot;, &quot;1px solid black&quot;);\n// class manipulation\ndojo.query(&quot;li:nth-child(even)&quot;).addClass(&quot;even&quot;);\n// even getting the coordinates of all the items\nvar coords = dojo.query(&quot;.thinger&quot;).coords();</code></pre>\n",
					"<p>DOM manipulation functions from the dojo.* namespace area also available:\n\n</p>\n<pre><code>// remove all of the elements in the list from their\n// parents (akin to &quot;deleting&quot; them from the document)\ndojo.query(&quot;.thinger&quot;).orphan();\n// place all elements in the list at the front of #foo\ndojo.query(&quot;.thinger&quot;).place(&quot;foo&quot;, &quot;first&quot;);</code></pre>\n",
					"<p>Event handling couldn&#39;t be easier. <code>dojo.connect</code> is mapped in,\nand shortcut handlers are provided for most DOM events:\n\n</p>\n<pre><code>// like dojo.connect(), but with implicit scope\ndojo.query(&quot;li&quot;).connect(&quot;onclick&quot;, console, &quot;log&quot;);\n\n// many common event handlers are already available directly:\ndojo.query(&quot;li&quot;).onclick(console, &quot;log&quot;);\nvar toggleHovered = dojo.hitch(dojo, &quot;toggleClass&quot;, &quot;hovered&quot;);\ndojo.query(&quot;p&quot;)\n    .onmouseenter(toggleHovered)\n    .onmouseleave(toggleHovered);</code></pre>\n",
					"<p>chainability is a key advantage of NodeLists:\n\n</p>\n<pre><code>dojo.query(&quot;.thinger&quot;)\n    .onclick(function(e){ /* ... */ })\n    .at(1, 3, 8) // get a subset\n        .style(&quot;padding&quot;, &quot;5px&quot;)\n        .forEach(console.log);</code></pre>\n"
				]
			},
			{
				"name": "objectToQuery",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/io-query",
				"extensionModule": true,
				"parameters": [
					{
						"name": "map",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>takes a name/value mapping object and returns a string representing\na URL-encoded version of that object.</p>\n",
				"examples": [
					"<p>this object:\n\n\n</p>\n<pre><code>{\n    blah: &quot;blah&quot;,\n    multi: [\n        &quot;thud&quot;,\n        &quot;thonk&quot;\n    ]\n};</code></pre>\n<p>yields the following query string:\n\n\n</p>\n<pre><code>&quot;blah=blah&amp;multi=thud&amp;multi=thonk&quot;</code></pre>\n"
				]
			},
			{
				"name": "publish",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the topic to publish.</p>\n"
					},
					{
						"name": "args",
						"types": [
							"Array"
						],
						"usage": "optional",
						"summary": "<p>An array of arguments. The arguments will be applied\nto each topic subscriber (as first class parameters, via apply).</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Invoke all listener method subscribed to topic.</p>\n",
				"examples": [
					"<pre><code>dojo.subscribe(&quot;alerts&quot;, null, function(caption, message){ alert(caption + &quot;\\n&quot; + message); };\ndojo.publish(&quot;alerts&quot;, [ &quot;read this&quot;, &quot;hello world&quot; ]);</code></pre>\n"
				]
			},
			{
				"name": "queryToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/io-query",
				"extensionModule": true,
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Create an object representing a de-serialized query section of a\nURL. Query keys with multiple values are returned in an array.\n</p>\n",
				"examples": [
					"<p>This string:\n\n\n</p>\n<pre><code>&quot;foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;&quot;</code></pre>\n<p>results in this object structure:\n\n\n</p>\n<pre><code>{\n    foo: [ &quot;bar&quot;, &quot;baz&quot; ],\n    thinger: &quot; spaces =blah&quot;,\n    zonk: &quot;blarg&quot;\n}</code></pre>\n<p>Note that spaces and other urlencoded entities are correctly\nhandled.</p>\n"
				]
			},
			{
				"name": "rawXhrPost",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP POST request to the server. In addition to the properties\nlisted for the dojo.__XhrArgs type, the following property is allowed:</p>\n"
			},
			{
				"name": "rawXhrPut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP PUT request to the server. In addition to the properties\nlisted for the dojo.__XhrArgs type, the following property is allowed:</p>\n"
			},
			{
				"name": "ready",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/ready",
				"extensionModule": true,
				"parameters": [
					{
						"name": "priority",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The order in which to exec this callback relative to other callbacks, defaults to 1000</p>\n"
					},
					{
						"name": "context",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The context in which to run execute callback, or a callback if not using context</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The function to execute.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.\nIn most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed.\n\n</p>\n<p>When called in a non-browser environment, just checks that all requested modules have arrived and been\nevaluated.</p>\n",
				"examples": [
					"<p>Simple DOM and Modules ready syntax\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(function(){ alert(&quot;Dom ready!&quot;); });\n});</code></pre>\n",
					"<p>Using a priority\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(2, function(){ alert(&quot;low priority ready!&quot;); })\n});</code></pre>\n",
					"<p>Using context\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(foo, function(){\n        // in here, this == foo\n    });\n});</code></pre>\n",
					"<p>Using dojo/hitch style args:\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    var foo = { dojoReady: function(){ console.warn(this, &quot;dojo dom and modules ready.&quot;); } };\n    ready(foo, &quot;dojoReady&quot;);\n});</code></pre>\n"
				]
			},
			{
				"name": "safeMixin",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"extensionModule": true,
				"parameters": [
					{
						"name": "target",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Target object to accept new properties.</p>\n"
					},
					{
						"name": "source",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Source object for new properties.</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>Target object to accept new properties.</p>\n",
				"summary": "<p>Mix in properties skipping a constructor and decorating functions\nlike it is done by declare().</p>\n",
				"description": "<p>This function is used to mix in properties like lang.mixin does,\nbut it skips a constructor property and decorates functions like\ndeclare() does.\n\n</p>\n<p>It is meant to be used with classes and objects produced with\ndeclare. Functions mixed in with dojo.safeMixin can use\nthis.inherited() like normal methods.\n\n</p>\n<p>This function is used to implement extend() method of a constructor\nproduced with declare().\n</p>\n",
				"examples": [
					"<pre><code>var A = declare(null, {\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    m1: function(){\n        this.inherited(arguments);\n        console.log(&quot;B.m1&quot;);\n    }\n});\nB.extend({\n    m2: function(){\n        this.inherited(arguments);\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\ndojo.safeMixin(x, {\n    m1: function(){\n        this.inherited(arguments);\n        console.log(&quot;X.m1&quot;);\n    },\n    m2: function(){\n        this.inherited(arguments);\n        console.log(&quot;X.m2&quot;);\n    }\n});\nx.m2();\n// prints:\n// A.m1\n// B.m1\n// X.m1</code></pre>\n"
				]
			},
			{
				"name": "setContext",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "globalObject",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "globalDocument",
						"types": [
							"DocumentElement"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>changes the behavior of many core Dojo functions that deal with\nnamespace and DOM lookup, changing them to work in a new global\ncontext (e.g., an iframe). The varibles dojo.global and dojo.doc\nare modified as a result of calling this function and the result of\n<code>dojo.body()</code> likewise differs.</p>\n"
			},
			{
				"name": "some",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/array",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Array",
							"String"
						],
						"usage": "required",
						"summary": "<p>the array to iterate over. If a string, operates on individual characters.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>a function is invoked with three arguments: item, index,\nand array and returns true if the condition is met.</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>may be used to scope the call to callback</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Determines whether or not any item in arr satisfies the\ncondition implemented by callback.</p>\n",
				"description": "<p>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\nrun over sparse arrays, this implementation passes the &quot;holes&quot; in the sparse array to\nthe callback function with a value of undefined. JavaScript 1.6&#39;s some skips the holes in the sparse array.\nFor more details, see:\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</a></p>\n",
				"examples": [
					"<pre><code>// is true\narray.some([1, 2, 3, 4], function(item){ return item&gt;1; });</code></pre>\n",
					"<pre><code>// is false\narray.some([1, 2, 3, 4], function(item){ return item&lt;1; });</code></pre>\n"
				]
			},
			{
				"name": "Stateful",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/Stateful",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "stopEvent",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/event",
				"extensionModule": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>The event object. If omitted, window.event is used on IE.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>prevents propagation and clobbers the default action of the\npassed event</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic to which to subscribe.</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Scope in which method will be invoked, or null for default scope.</p>\n"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>The name of a function in context, or a function reference. This is the function that\nis invoked when topic is published.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Attach a listener to a named topic. The listener function is invoked whenever the\nnamed topic is published (see: dojo.publish).\nReturns a handle which is needed to unsubscribe this listener.</p>\n",
				"examples": [
					"<pre><code>dojo.subscribe(&quot;alerts&quot;, null, function(caption, message){ alert(caption + &quot;\\n&quot; + message); });\ndojo.publish(&quot;alerts&quot;, [ &quot;read this&quot;, &quot;hello world&quot; ]);</code></pre>\n"
				]
			},
			{
				"name": "toJson",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/json",
				"extensionModule": true,
				"parameters": [
					{
						"name": "it",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>an object to be serialized. Objects may define their own\nserialization via a special &quot;<strong>json</strong>&quot; or &quot;json&quot; function\nproperty. If a specialized serializer has been defined, it will\nbe used as a fallback.\nNote that in 1.6, toJson would serialize undefined, but this no longer supported\nsince it is not supported by native JSON serializer.</p>\n"
					},
					{
						"name": "prettyPrint",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>if true, we indent objects and arrays to make the output prettier.\nThe variable <code>dojo.toJsonIndentStr</code> is used as the indent string --\nto use something other than the default (tab), change that variable\nbefore calling dojo.toJson().\nNote that if native JSON support is available, it will be used for serialization,\nand native implementations vary on the exact spacing used in pretty printing.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A JSON string serialization of the passed-in object.</p>\n",
				"summary": "<p>Returns a <a href=\"http://json.org\">JSON</a> serialization of an object.</p>\n",
				"description": "<p>Returns a <a href=\"http://json.org\">JSON</a> serialization of an object.\nNote that this doesn&#39;t check for infinite recursion, so don&#39;t do that!\nIt is recommend that you use dojo/json&#39;s stringify function for an lighter\nand faster implementation that matches the native JSON API and uses the\nnative JSON serializer when available.</p>\n",
				"examples": [
					"<p>simple serialization of a trivial object\n\n</p>\n<pre><code>var jsonStr = dojo.toJson({ howdy: &quot;stranger!&quot;, isStrange: true });\ndoh.is(&#39;{&quot;howdy&quot;:&quot;stranger!&quot;,&quot;isStrange&quot;:true}&#39;, jsonStr);</code></pre>\n",
					"<p>a custom serializer for an objects of a particular class:\n\n</p>\n<pre><code>dojo.declare(&quot;Furby&quot;, null, {\n    furbies: &quot;are strange&quot;,\n    furbyCount: 10,\n    __json__: function(){\n    },\n});</code></pre>\n"
				]
			},
			{
				"name": "unsubscribe",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"extensionModule": true,
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Handle"
						],
						"usage": "required",
						"summary": "<p>The handle returned from a call to subscribe.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Remove a topic listener.</p>\n",
				"examples": [
					"<pre><code>var alerter = dojo.subscribe(&quot;alerts&quot;, null, function(caption, message){ alert(caption + &quot;\\n&quot; + message); };\n...\ndojo.unsubscribe(alerter);</code></pre>\n"
				]
			},
			{
				"name": "when",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/when",
				"extensionModule": true,
				"parameters": [
					{
						"name": "valueOrPromise",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Either a regular value or an object with a <code>then()</code> method that\nfollows the Promises/A specification.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is resolved, or a non-promise\nis received.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
					},
					{
						"name": "progback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise emits a progress update.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Promise, or if a callback is provided, the result of the callback.</p>\n",
				"summary": "<p>Transparently applies callbacks to values and/or promises.</p>\n",
				"description": "<p>Accepts promises but also transparently handles non-promises. If no\ncallbacks are provided returns a promise, regardless of the initial\nvalue. Foreign promises are converted.\n\n</p>\n<p>If callbacks are provided and the initial value is not a promise,\nthe callback is executed immediately with no error handling. Returns\na promise if the initial value is a promise, or the result of the\ncallback otherwise.</p>\n"
			},
			{
				"name": "withDoc",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "documentObject",
						"types": [
							"DocumentElement"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "cbArguments",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Invoke callback with documentObject as dojo/_base/window::doc.</p>\n",
				"description": "<p>Invoke callback with documentObject as dojo/_base/window::doc. If provided,\ncallback will be executed in the context of object thisObject\nWhen callback() returns or throws an error, the dojo/_base/window::doc will\nbe restored to its previous state.</p>\n"
			},
			{
				"name": "withGlobal",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "globalObject",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "cbArguments",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Invoke callback with globalObject as dojo.global and\nglobalObject.document as dojo.doc.</p>\n",
				"description": "<p>Invoke callback with globalObject as dojo.global and\nglobalObject.document as dojo.doc. If provided, globalObject\nwill be executed in the context of object thisObject\nWhen callback() returns or throws an error, the dojo.global\nand dojo.doc will be restored to its previous state.</p>\n"
			},
			{
				"name": "xhr",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "method",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.</p>\n"
					},
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					},
					{
						"name": "hasBody",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If the request has an HTTP body, then pass true for hasBody.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated.   Use dojo/request instead.</p>\n",
				"description": "<p>Sends an HTTP request with the given method.\nSee also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts\nfor those HTTP methods. There are also methods for &quot;raw&quot; PUT and POST methods\nvia dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</p>\n"
			},
			{
				"name": "xhrDelete",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP DELETE request to the server.</p>\n"
			},
			{
				"name": "xhrGet",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP GET request to the server.</p>\n"
			},
			{
				"name": "xhrPost",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP POST request to the server. In addition to the properties\nlisted for the dojo.__XhrArgs type, the following property is allowed:</p>\n"
			},
			{
				"name": "xhrPut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP PUT request to the server. In addition to the properties\nlisted for the dojo.__XhrArgs type, the following property is allowed:</p>\n"
			}
		]
	},
	"dojo/_base/kernel.config": {
		"location": "dojo/_base/kernel.config",
		"type": "object",
		"summary": "<p>This module defines the user configuration during bootstrap.</p>\n",
		"description": "<p>By defining user configuration as a module value, an entire configuration can be specified in a build,\nthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\nAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\nat an unique absolute module identifier as given by the package configuration. Implementing configuration\nas a module allows for specifying unique, per-instance configurations.</p>\n",
		"examples": [
			"<p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and\ndojo.js are already loaded).\n\n</p>\n<pre><code>// specify a configuration that creates a new instance of dojo at the absolute module identifier &quot;myDojo&quot;\nrequire({\n    packages:[{\n        name:&quot;myDojo&quot;,\n        location:&quot;.&quot;, //assume baseUrl points to dojo.js\n    }]\n});\n\n// specify a configuration for the myDojo instance\ndefine(&quot;myDojo/config&quot;, {\n    // normal configuration variables go here, e.g.,\n    locale:&quot;fr-ca&quot;\n});\n\n// load and use the new instance of dojo\nrequire([&quot;myDojo&quot;], function(dojo){\n    // dojo is the new instance of dojo\n    // use as required\n});</code></pre>\n"
		],
		"properties": [
			{
				"name": "addOnLoad",
				"scope": "normal",
				"types": [
					"Function",
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Adds a callback via dojo/ready. Useful when Dojo is added after\nthe page loads and djConfig.afterOnLoad is true. Supports the same\narguments as dojo/ready. When using a function reference, use\n<code>djConfig.addOnLoad = function(){};</code>. For object with function name use\n<code>djConfig.addOnLoad = [myObject, &quot;functionName&quot;];</code> and for object with\nfunction reference use\n<code>djConfig.addOnLoad = [myObject, function(){}];</code></p>\n"
			},
			{
				"name": "afterOnLoad",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/ready",
				"extensionModule": true
			},
			{
				"name": "baseUrl",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "callback",
				"scope": "normal",
				"types": [
					"Function",
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Defines a callback to be used when dependencies are defined before \nthe loader has been loaded. When provided, they cause the loader to \nexecute require(deps, callback) once it has finished loading. \nShould be used with deps.</p>\n"
			},
			{
				"name": "defaultDuration",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Default duration, in milliseconds, for wipe and fade animations within dijits.\nAssigned to dijit.defaultDuration.</p>\n"
			},
			{
				"name": "deferredInstrumentation",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Whether deferred instrumentation should be loaded or included\nin builds.</p>\n"
			},
			{
				"name": "deps",
				"scope": "normal",
				"types": [
					"Function",
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Defines dependencies to be used before the loader has been loaded.\nWhen provided, they cause the loader to execute require(deps, callback) \nonce it has finished loading. Should be used with callback.</p>\n"
			},
			{
				"name": "dojoBlankHtmlUrl",
				"scope": "normal",
				"types": [
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Used by some modules to configure an empty iframe. Used by dojo/io/iframe and\ndojo/back, and dijit/popup support in IE where an iframe is needed to make sure native\ncontrols do not bleed through the popups. Normally this configuration variable\ndoes not need to be set, except when using cross-domain/CDN Dojo builds.\nSave dojo/resources/blank.html to your domain and set <code>djConfig.dojoBlankHtmlUrl</code>\nto the path on your domain your copy of blank.html.</p>\n"
			},
			{
				"name": "extraLocale",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>No default value. Specifies additional locales whose\nresources should also be loaded alongside the default locale when\ncalls to <code>dojo.requireLocalization()</code> are processed.</p>\n"
			},
			{
				"name": "ioPublish",
				"scope": "normal",
				"types": [
					"Boolean?"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Set this to true to enable publishing of topics for the different phases of\nIO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list\nof topics that are published.</p>\n"
			},
			{
				"name": "isDebug",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Defaults to <code>false</code>. If set to <code>true</code>, ensures that Dojo provides\nextended debugging feedback via Firebug. If Firebug is not available\non your platform, setting <code>isDebug</code> to <code>true</code> will force Dojo to\npull in (and display) the version of Firebug Lite which is\nintegrated into the Dojo distribution, thereby always providing a\ndebugging/logging console when <code>isDebug</code> is enabled. Note that\nFirebug&#39;s <code>console.*</code> methods are ALWAYS defined by Dojo. If\n<code>isDebug</code> is false and you are on a platform without Firebug, these\nmethods will be defined as no-ops.</p>\n"
			},
			{
				"name": "locale",
				"scope": "normal",
				"types": [
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>The locale to assume for loading localized resources in this page,\nspecified according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a>.\nMust be specified entirely in lowercase, e.g. <code>en-us</code> and <code>zh-cn</code>.\nSee the documentation for <code>dojo.i18n</code> and <code>dojo.requireLocalization</code>\nfor details on loading localized resources. If no locale is specified,\nDojo assumes the locale of the user agent, according to <code>navigator.userLanguage</code>\nor <code>navigator.language</code> properties.</p>\n"
			},
			{
				"name": "modulePaths",
				"scope": "normal",
				"types": [
					"Object"
				],
				"from": "dojo/_base/config",
				"tags": [
					"deprecated"
				],
				"summary": "<p>A map of module names to paths relative to <code>dojo.baseUrl</code>. The\nkey/value pairs correspond directly to the arguments which\n<code>dojo.registerModulePath</code> accepts. Specifying\n<code>djConfig.modulePaths = { &quot;foo&quot;: &quot;../../bar&quot; }</code> is the equivalent\nof calling <code>dojo.registerModulePath(&quot;foo&quot;, &quot;../../bar&quot;);</code>. Multiple\nmodules may be configured via <code>djConfig.modulePaths</code>.</p>\n"
			},
			{
				"name": "parseOnLoad",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Run the parser after the page is loaded</p>\n"
			},
			{
				"name": "require",
				"scope": "normal",
				"types": [
					"String[]"
				],
				"from": "dojo/_base/config",
				"summary": "<p>An array of module names to be loaded immediately after dojo.js has been included\nin a page.</p>\n"
			},
			{
				"name": "transparentColor",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Array containing the r, g, b components used as transparent color in dojo.Color;\nif undefined, [255,255,255] (white) will be used.</p>\n"
			},
			{
				"name": "useCustomLogger",
				"scope": "normal",
				"types": [
					"Anything?"
				],
				"from": "dojo/_base/config",
				"summary": "<p>If set to a value that evaluates to true such as a string or array and\nisDebug is true and Firebug is not available or running, then it bypasses\nthe creation of Firebug Lite allowing you to define your own console object.</p>\n"
			},
			{
				"name": "useDeferredInstrumentation",
				"scope": "normal",
				"types": [
					"Boolean",
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Whether the deferred instrumentation should be used.\n\n</p>\n<ul>\n<li><code>&quot;report-rejections&quot;</code>: report each rejection as it occurs.</li>\n<li><code>true</code> or <code>1</code> or <code>&quot;report-unhandled-rejections&quot;</code>: wait 1 second\n  in an attempt to detect unhandled rejections.</li>\n</ul>\n"
			}
		]
	},
	"dojo/_base/kernel.global": {
		"location": "dojo/_base/kernel.global",
		"type": "object",
		"summary": "<p>Alias for the current window. &#39;global&#39; can be modified\nfor temporary context shifting. See also withGlobal().</p>\n",
		"description": "<p>Use this rather than referring to &#39;window&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n"
	},
	"dojo/_base/kernel.dijit": {
		"location": "dojo/_base/kernel.dijit",
		"type": "object",
		"properties": [
			{
				"name": "form",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dijit/form/_FormMixin",
				"extensionModule": true
			}
		],
		"methods": [
			{
				"name": "_AttachMixin",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_FocusMixin",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_TemplatedMixin",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_WidgetBase",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_WidgetsInTemplateMixin",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "Destroyable",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dijit/Destroyable",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/_base/kernel.dojox": {
		"location": "dojo/_base/kernel.dojox",
		"type": "object"
	},
	"dojo/_base/kernel.scopeMap": {
		"location": "dojo/_base/kernel.scopeMap",
		"type": "object",
		"properties": [
			{
				"name": "dijit",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "dojo",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "dojox",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/kernel"
			}
		]
	},
	"dojo/_base/kernel.version": {
		"location": "dojo/_base/kernel.version",
		"type": "object",
		"summary": "<p>Version number of the Dojo Toolkit</p>\n",
		"description": "<p>Hash about the version, including\n\n</p>\n<ul>\n<li>major: Integer: Major version. If total version is &quot;1.2.0beta1&quot;, will be 1</li>\n<li>minor: Integer: Minor version. If total version is &quot;1.2.0beta1&quot;, will be 2</li>\n<li>patch: Integer: Patch version. If total version is &quot;1.2.0beta1&quot;, will be 0</li>\n<li>flag: String: Descriptor flag. If total version is &quot;1.2.0beta1&quot;, will be &quot;beta1&quot;</li>\n<li>revision: Number: The SVN rev from which dojo was pulled</li>\n</ul>\n",
		"properties": [
			{
				"name": "flag",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "major",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "minor",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "patch",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/_base/kernel"
			},
			{
				"name": "revision",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/_base/kernel"
			}
		],
		"methods": [
			{
				"name": "toString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/kernel",
				"parameters": [],
				"returnTypes": [
					"string"
				]
			}
		]
	},
	"dojo/_base/kernel._hasResource": {
		"location": "dojo/_base/kernel._hasResource",
		"type": "object"
	},
	"dojo/_base/kernel.Stateful": {
		"location": "dojo/_base/kernel.Stateful",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Base class for objects that provide named properties with optional getter/setter\ncontrol and the ability to watch for property changes\n\n</p>\n<p>The class also provides the functionality to auto-magically manage getters\nand setters for object attributes/properties.\n\n</p>\n<p>Getters and Setters should follow the format of _xxxGetter or _xxxSetter where \nthe xxx is a name of the attribute to handle.  So an attribute of &quot;foo&quot; \nwould have a custom getter of _fooGetter and a custom setter of _fooSetter.\n</p>\n",
		"examples": [
			"<pre><code>var obj = new dojo.Stateful();\nobj.watch(&quot;foo&quot;, function(){\n    console.log(&quot;foo changed to &quot; + this.get(&quot;foo&quot;));\n});\nobj.set(&quot;foo&quot;,&quot;bar&quot;);</code></pre>\n"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"extensionModule": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"extensionModule": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"extensionModule": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"extensionModule": true,
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"extensionModule": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"extensionModule": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"dojo/_base/kernel.store": {
		"location": "dojo/_base/kernel.store",
		"type": "object",
		"properties": [
			{
				"name": "util",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/store/util/QueryResults",
				"extensionModule": true
			}
		],
		"methods": [
			{
				"name": "JsonRest",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/JsonRest",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "Memory",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/Memory",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/_base/kernel.doc": {
		"location": "dojo/_base/kernel.doc",
		"type": "object",
		"summary": "<p>Alias for the current document. &#39;doc&#39; can be modified\nfor temporary context shifting. See also withDoc().</p>\n",
		"description": "<p>Use this rather than referring to &#39;window.document&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n",
		"examples": [
			"<pre><code>n.appendChild(dojo.doc.createElement(&#39;div&#39;));</code></pre>\n"
		]
	},
	"dojo/_base/kernel.mouseButtons": {
		"location": "dojo/_base/kernel.mouseButtons",
		"type": "object",
		"properties": [
			{
				"name": "LEFT",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"summary": "<p>Numeric value of the left mouse button for the platform.</p>\n"
			},
			{
				"name": "MIDDLE",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"summary": "<p>Numeric value of the middle mouse button for the platform.</p>\n"
			},
			{
				"name": "RIGHT",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"summary": "<p>Numeric value of the right mouse button for the platform.</p>\n"
			}
		],
		"methods": [
			{
				"name": "isButton",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"parameters": [
					{
						"name": "e",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>Event object to examine</p>\n"
					},
					{
						"name": "button",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The button value (example: dojo.mouseButton.LEFT)</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks an event object for a pressed button</p>\n"
			},
			{
				"name": "isLeft",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"parameters": [
					{
						"name": "e",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>Event object to examine</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks an event object for the pressed left button</p>\n"
			},
			{
				"name": "isMiddle",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"parameters": [
					{
						"name": "e",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>Event object to examine</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks an event object for the pressed middle button</p>\n"
			},
			{
				"name": "isRight",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"extensionModule": true,
				"parameters": [
					{
						"name": "e",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>Event object to examine</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks an event object for the pressed right button</p>\n"
			}
		]
	},
	"dojo/_base/kernel.keys": {
		"location": "dojo/_base/kernel.keys",
		"type": "object",
		"summary": "<p>Definitions for common key values.  Client code should test keyCode against these named constants,\nas the actual codes can vary by browser.</p>\n",
		"properties": [
			{
				"name": "ALT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "BACKSPACE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "CAPS_LOCK",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "CLEAR",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "copyKey",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "CTRL",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "DELETE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "DOWN_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "DOWN_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "END",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "ENTER",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "ESCAPE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F1",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F10",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F11",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F12",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F13",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F14",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F15",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F2",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F3",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F4",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F5",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F6",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F7",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F8",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "F9",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "HELP",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "HOME",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "INSERT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "LEFT_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "LEFT_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "LEFT_WINDOW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "META",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUM_LOCK",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_0",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_1",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_2",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_3",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_4",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_5",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_6",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_7",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_8",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_9",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_DIVIDE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_ENTER",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_MINUS",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_MULTIPLY",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_PERIOD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "NUMPAD_PLUS",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "PAGE_DOWN",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "PAGE_UP",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "PAUSE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "RIGHT_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "RIGHT_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "RIGHT_WINDOW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "SCROLL_LOCK",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "SELECT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "SHIFT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "SPACE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "TAB",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "UP_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			},
			{
				"name": "UP_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys",
				"extensionModule": true
			}
		]
	},
	"dojo/_base/kernel.string": {
		"location": "dojo/_base/kernel.string",
		"type": "object",
		"summary": "<p>String utilities for Dojo</p>\n",
		"methods": [
			{
				"name": "pad",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"extensionModule": true,
				"parameters": [
					{
						"name": "text",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the string to pad</p>\n"
					},
					{
						"name": "size",
						"types": [
							"Integer"
						],
						"usage": "required",
						"summary": "<p>length to provide padding</p>\n"
					},
					{
						"name": "ch",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>character to pad, defaults to &#39;0&#39;</p>\n"
					},
					{
						"name": "end",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>adds padding at the end if true, otherwise pads at start</p>\n"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Pad a string to guarantee that it is at least <code>size</code> length by\nfilling with the character <code>ch</code> at either the start or end of the\nstring. Pads at the start, by default.</p>\n",
				"examples": [
					"<pre><code>// Fill the string to length 10 with &quot;+&quot; characters on the right.  Yields &quot;Dojo++++++&quot;.\nstring.pad(&quot;Dojo&quot;, 10, &quot;+&quot;, true);</code></pre>\n"
				]
			},
			{
				"name": "rep",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"extensionModule": true,
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the string to replicate</p>\n"
					},
					{
						"name": "num",
						"types": [
							"Integer"
						],
						"usage": "required",
						"summary": "<p>number of times to replicate the string</p>\n"
					}
				],
				"returnTypes": [
					"string",
					"undefined"
				],
				"summary": "<p>Efficiently replicate a string <code>n</code> times.</p>\n"
			},
			{
				"name": "substitute",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"extensionModule": true,
				"parameters": [
					{
						"name": "template",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>a string with expressions in the form <code>${key}</code> to be replaced or\n<code>${key:format}</code> which specifies a format function. keys are case-sensitive.</p>\n"
					},
					{
						"name": "map",
						"types": [
							"Object",
							"Array"
						],
						"usage": "required",
						"summary": "<p>hash to search for substitutions</p>\n"
					},
					{
						"name": "transform",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>a function to process all parameters before substitution takes\nplace, e.g. mylib.encodeXML</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>where to look for optional format function; default to the global\nnamespace</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Performs parameterized substitutions on a string. Throws an\nexception if any parameter is unmatched.</p>\n",
				"examples": [
					"<p>Substitutes two expressions in a string from an Array or Object\n\n</p>\n<pre><code>// returns &quot;File &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\n// by providing substitution data in an Array\nstring.substitute(\n    &quot;File &#39;${0}&#39; is not found in directory &#39;${1}&#39;.&quot;,\n    [&quot;foo.html&quot;,&quot;/temp&quot;]\n);\n\n// also returns &quot;File &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\n// but provides substitution data in an Object structure.  Dotted\n// notation may be used to traverse the structure.\nstring.substitute(\n    &quot;File &#39;${name}&#39; is not found in directory &#39;${info.dir}&#39;.&quot;,\n    { name: &quot;foo.html&quot;, info: { dir: &quot;/temp&quot; } }\n);</code></pre>\n",
					"<p>Use a transform function to modify the values:\n\n</p>\n<pre><code>// returns &quot;file &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\nstring.substitute(\n    &quot;${0} is not found in ${1}.&quot;,\n    [&quot;foo.html&quot;,&quot;/temp&quot;],\n    function(str){\n        // try to figure out the type\n        var prefix = (str.charAt(0) == &quot;/&quot;) ? &quot;directory&quot;: &quot;file&quot;;\n        return prefix + &quot; &#39;&quot; + str + &quot;&#39;&quot;;\n    }\n);</code></pre>\n",
					"<p>Use a formatter\n\n</p>\n<pre><code>// returns &quot;thinger -- howdy&quot;\nstring.substitute(\n    &quot;${0:postfix}&quot;, [&quot;thinger&quot;], null, {\n        postfix: function(value, key){\n            return value + &quot; -- howdy&quot;;\n        }\n    }\n);</code></pre>\n"
				]
			},
			{
				"name": "trim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"extensionModule": true,
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be trimmed</p>\n"
					}
				],
				"returnTypes": [
					"String",
					"string"
				],
				"returnDescription": "<p>Returns the trimmed string</p>\n",
				"summary": "<p>Trims whitespace from both sides of the string</p>\n",
				"description": "<p>This version of trim() was taken from <a href=\"http://blog.stevenlevithan.com/archives/faster-trim-javascript\">Steven Levithan&#39;s blog</a>.\nThe short yet performant version of this function is dojo.trim(),\nwhich is part of Dojo base.  Uses String.prototype.trim instead, if available.</p>\n"
			},
			{
				"name": "ucFirst",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/string",
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Makes the first letter of a string uppercase</p>\n"
			}
		]
	},
	"dojo/_base/kernel.touch": {
		"location": "dojo/_base/kernel.touch",
		"type": "object",
		"summary": "<p>This module provides unified touch event handlers by exporting\npress, move, release and cancel which can also run well on desktop.\nBased on <a href=\"http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html\">http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html</a>\nAlso, if the dojoClick property is set to true on a DOM node, dojo/touch generates\nclick events immediately for this node and its descendants, to avoid the\ndelay before native browser click events, and regardless of whether evt.preventDefault()\nwas called in a touch.press event listener.\n</p>\n",
		"examples": [
			"<p>Used with dojo.on\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;, &quot;dojo/touch&quot;], function(on, touch){\n    on(node, touch.press, function(e){});\n    on(node, touch.move, function(e){});\n    on(node, touch.release, function(e){});\n    on(node, touch.cancel, function(e){});</code></pre>\n",
			"<p>Used with touch.* directly\n\n</p>\n<pre><code>touch.press(node, function(e){});\ntouch.move(node, function(e){});\ntouch.release(node, function(e){});\ntouch.cancel(node, function(e){});</code></pre>\n",
			"<p>Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels\n\n</p>\n<pre><code>node.dojoClick = true;</code></pre>\n",
			"<p>Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically\n\n</p>\n<pre><code>node.dojoClick = 10;</code></pre>\n",
			"<p>Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically\n\n</p>\n<pre><code>node.dojoClick = {x:50, y:5};</code></pre>\n"
		],
		"methods": [
			{
				"name": "cancel",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;touchcancel&#39;|&#39;mouseleave&#39; for the given node</p>\n"
			},
			{
				"name": "enter",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to mouse.enter or touch equivalent for the given node</p>\n"
			},
			{
				"name": "leave",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to mouse.leave or touch equivalent for the given node</p>\n"
			},
			{
				"name": "move",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener that fires when the mouse cursor or a finger is dragged over the given node.</p>\n"
			},
			{
				"name": "out",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;mouseout&#39; or touch equivalent for the given node</p>\n"
			},
			{
				"name": "over",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;mouseover&#39; or touch equivalent for the given node</p>\n"
			},
			{
				"name": "press",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;touchstart&#39;|&#39;mousedown&#39; for the given node</p>\n"
			},
			{
				"name": "release",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to releasing the mouse button while the cursor is over the given node\n(i.e. &quot;mouseup&quot;) or for removing the finger from the screen while touching the given node.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.date": {
		"location": "dojo/_base/kernel.date",
		"type": "object",
		"properties": [
			{
				"name": "stamp",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/date/stamp",
				"extensionModule": true,
				"summary": "<p>TODOC</p>\n"
			}
		],
		"methods": [
			{
				"name": "add",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"extensionModule": true,
				"parameters": [
					{
						"name": "date",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Date object to start with</p>\n"
					},
					{
						"name": "interval",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representing the interval.  One of the following:\n&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;,\n&quot;millisecond&quot;, &quot;quarter&quot;, &quot;week&quot;, &quot;weekday&quot;</p>\n"
					},
					{
						"name": "amount",
						"types": [
							"int"
						],
						"usage": "required",
						"summary": "<p>How much to add to the date.</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Add to a Date in intervals of different size, from milliseconds to years</p>\n"
			},
			{
				"name": "compare",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"extensionModule": true,
				"parameters": [
					{
						"name": "date1",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Date object</p>\n"
					},
					{
						"name": "date2",
						"types": [
							"Date"
						],
						"usage": "optional",
						"summary": "<p>Date object.  If not specified, the current Date is used.</p>\n"
					},
					{
						"name": "portion",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>A string indicating the &quot;date&quot; or &quot;time&quot; portion of a Date object.\nCompares both &quot;date&quot; and &quot;time&quot; by default.  One of the following:\n&quot;date&quot;, &quot;time&quot;, &quot;datetime&quot;</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Compare two date objects by date, time, or both.</p>\n",
				"description": "<p>Returns 0 if equal, positive if a &gt; b, else negative.</p>\n"
			},
			{
				"name": "difference",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"extensionModule": true,
				"parameters": [
					{
						"name": "date1",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Date object</p>\n"
					},
					{
						"name": "date2",
						"types": [
							"Date"
						],
						"usage": "optional",
						"summary": "<p>Date object.  If not specified, the current Date is used.</p>\n"
					},
					{
						"name": "interval",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>A string representing the interval.  One of the following:\n&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;,\n&quot;millisecond&quot;, &quot;quarter&quot;, &quot;week&quot;, &quot;weekday&quot;\n\n</p>\n<p>Defaults to &quot;day&quot;.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Get the difference in a specific unit of time (e.g., number of\nmonths, weeks, days, etc.) between two dates, rounded to the\nnearest integer.</p>\n"
			},
			{
				"name": "getDaysInMonth",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"extensionModule": true,
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns the number of days in the month used by dateObject</p>\n"
			},
			{
				"name": "getTimezoneName",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"extensionModule": true,
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Needed because the timezone may vary with time (daylight savings)</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Get the user&#39;s time zone as provided by the browser</p>\n",
				"description": "<p>Try to get time zone info from toString or toLocaleString method of\nthe Date object -- UTC offset is not a time zone.  See\n<a href=\"http://www.twinsun.com/tz/tz-link.htm\">http://www.twinsun.com/tz/tz-link.htm</a> Note: results may be\ninconsistent across browsers.</p>\n"
			},
			{
				"name": "isLeapYear",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"extensionModule": true,
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Determines if the year of the dateObject is a leap year</p>\n",
				"description": "<p>Leap years are years with an additional day YYYY-02-29, where the\nyear number is a multiple of four with the following exception: If\na year is a multiple of 100, then it is only a leap year if it is\nalso a multiple of 400. For example, 1900 was not a leap year, but\n2000 is one.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.parser": {
		"location": "dojo/_base/kernel.parser",
		"type": "object",
		"summary": "<p>The Dom/Widget parsing package</p>\n",
		"methods": [
			{
				"name": "_clearCache",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Clear cached data.   Used mainly for benchmarking.</p>\n"
			},
			{
				"name": "_functionFromScript",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "script",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The <code>&lt;script&gt;</code> DOMNode</p>\n"
					},
					{
						"name": "attrData",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>For HTML5 compliance, searches for attrData + &quot;args&quot; (typically\n&quot;data-dojo-args&quot;) instead of &quot;args&quot;</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Convert a <code>&lt;script type=&quot;dojo/method&quot; args=&quot;a, b, c&quot;&gt; ... &lt;/script&gt;</code>\ninto a function</p>\n"
			},
			{
				"name": "_instantiate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "nodes",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>Array of objects like\n\n</p>\n<pre><code>{\n    ctor: Function (may be null)\n    types: [&quot;dijit/form/Button&quot;, &quot;acme/MyMixin&quot;] (used if ctor not specified)\n    node: DOMNode,\n    scripts: [ ... ],   // array of &lt;script type=&quot;dojo/...&quot;&gt; children of node\n    inherited: { ... }  // settings inherited from ancestors like dir, theme, etc.\n}</code></pre>\n"
					},
					{
						"name": "mixin",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object that will be mixed in with each node in the array.\nValues in the mixin will override values in the node, if they\nexist.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An options object used to hold kwArgs for instantiation.\nSee parse.options argument for details.</p>\n"
					},
					{
						"name": "returnPromise",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>Return a Promise rather than the instance; supports asynchronous widget creation.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Array of instances, or if returnPromise is true, a promise for array of instances\nthat resolves when instances have finished initializing.</p>\n",
				"summary": "<p>Takes array of objects representing nodes, and turns them into class instances and\npotentially calls a startup method to allow them to connect with\nany children.</p>\n"
			},
			{
				"name": "_require",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "script",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper for _scanAMD().  Takes a <code>&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;</code> node,\ncalls require() to load the specified modules and (asynchronously) assign them to the specified global\nvariables, and returns a Promise for when that operation completes.\n\n</p>\n<p>In the example above, it is effectively doing a require([&quot;acme/bar&quot;, ...], function(a){ bar = a; }).</p>\n"
			},
			{
				"name": "_scanAmd",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to base the scan from.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>a kwArgs options object, see parse() for details</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Scans the DOM for any declarative requires and returns their values.</p>\n",
				"description": "<p>Looks for <code>&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;</code> node, calls require() to load the\nspecified modules and (asynchronously) assign them to the specified global variables,\nand returns a Promise for when those operations complete.</p>\n"
			},
			{
				"name": "construct",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"extensionModule": true,
				"parameters": [
					{
						"name": "ctor",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Widget constructor.</p>\n"
					},
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.</p>\n"
					},
					{
						"name": "mixin",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Attributes in this object will be passed as parameters to ctor,\noverriding attributes specified on the node.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An options object used to hold kwArgs for instantiation.   See parse.options argument for details.</p>\n"
					},
					{
						"name": "scripts",
						"types": [
							"DomNode[]"
						],
						"usage": "optional",
						"summary": "<p>Array of <code>&lt;script type=&quot;dojo/*&quot;&gt;</code> DOMNodes.  If not specified, will search for <code>&lt;script&gt;</code> tags inside node.</p>\n"
					},
					{
						"name": "inherited",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Instance or Promise for the instance, if markupFactory() itself returned a promise</p>\n",
				"summary": "<p>Calls new ctor(params, node), where params is the hash of parameters specified on the node,\nexcluding data-dojo-type and data-dojo-mixins.   Does not call startup().</p>\n"
			},
			{
				"name": "instantiate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"extensionModule": true,
				"parameters": [
					{
						"name": "nodes",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>Array of DOM nodes</p>\n"
					},
					{
						"name": "mixin",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An object that will be mixed in with each node in the array.\nValues in the mixin will override values in the node, if they\nexist.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An object used to hold kwArgs for instantiation.\nSee parse.options argument for details.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Array of instances.</p>\n",
				"summary": "<p>Takes array of nodes, and turns them into class instances and\npotentially calls a startup method to allow them to connect with\nany children.</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"extensionModule": true,
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "optional",
						"summary": "<p>A default starting root node from which to start the parsing. Can be\nomitted, defaulting to the entire document. If omitted, the <code>options</code>\nobject can be passed in this place. If the <code>options</code> object has a\n<code>rootNode</code> member, that is used.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>A hash of options.\n\n</p>\n<ul>\n<li>noStart: Boolean?:\n  when set will prevent the parser from calling .startup()\n  when locating the nodes.</li>\n<li>rootNode: DomNode?:\n  identical to the function&#39;s <code>rootNode</code> argument, though\n  allowed to be passed in via this `options object.</li>\n<li>template: Boolean:\n  If true, ignores ContentPane&#39;s stopParser flag and parses contents inside of\n  a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes\n  nested inside the ContentPane to work.</li>\n<li>inherited: Object:\n  Hash possibly containing dir and lang settings to be applied to\n  parsed widgets, unless there&#39;s another setting on a sub-node that overrides</li>\n<li>scope: String:\n  Root for attribute names to search for.   If scopeName is dojo,\n  will search for data-dojo-type (or dojoType).   For backwards compatibility\n  reasons defaults to dojo._scopeName (which is &quot;dojo&quot; except when\n  multi-version support is used, when it will be something like dojo16, dojo20, etc.)</li>\n<li>propsThis: Object:\n  If specified, &quot;this&quot; referenced from data-dojo-props will refer to propsThis.\n  Intended for use from the widgets-in-template feature of <code>dijit._WidgetsInTemplateMixin</code></li>\n<li>contextRequire: Function:\n  If specified, this require is utilised for looking resolving modules instead of the\n  <code>dojo/parser</code> context <code>require()</code>.  Intended for use from the widgets-in-template feature of\n  <code>dijit._WidgetsInTemplateMixin</code>.</li>\n</ul>\n"
					}
				],
				"returnTypes": [
					"Mixed",
					"Array"
				],
				"returnDescription": "<p>Returns a blended object that is an array of the instantiated objects, but also can include\na promise that is resolved with the instantiated objects.  This is done for backwards\ncompatibility.  If the parser auto-requires modules, it will always behave in a promise\nfashion and <code>parser.parse().then(function(instances){...})</code> should be used.</p>\n",
				"summary": "<p>Scan the DOM for class instances, and instantiate them.</p>\n",
				"description": "<p>Search specified node (or root node) recursively for class instances,\nand instantiate them. Searches for either data-dojo-type=&quot;Class&quot; or\ndojoType=&quot;Class&quot; where &quot;Class&quot; is a a fully qualified class name,\nlike <code>dijit/form/Button</code>\n\n</p>\n<p>Using <code>data-dojo-type</code>:\nAttributes using can be mixed into the parameters used to instantiate the\nClass by using a <code>data-dojo-props</code> attribute on the node being converted.\n<code>data-dojo-props</code> should be a string attribute to be converted from JSON.\n\n</p>\n<p>Using <code>dojoType</code>:\nAttributes are read from the original domNode and converted to appropriate\ntypes by looking up the Class prototype values. This is the default behavior\nfrom Dojo 1.0 to Dojo 1.5. <code>dojoType</code> support is deprecated, and will\ngo away in Dojo 2.0.</p>\n",
				"examples": [
					"<p>Parse all widgets on a page:\n\n</p>\n<pre><code>parser.parse();</code></pre>\n",
					"<p>Parse all classes within the node with id=&quot;foo&quot;\n\n</p>\n<pre><code>parser.parse(dojo.byId(&#39;foo&#39;));</code></pre>\n",
					"<p>Parse all classes in a page, but do not call .startup() on any\nchild\n\n</p>\n<pre><code>parser.parse({ noStart: true })</code></pre>\n",
					"<p>Parse all classes in a node, but do not call .startup()\n\n</p>\n<pre><code>parser.parse(someNode, { noStart:true });\n// or\nparser.parse({ noStart:true, rootNode: someNode });</code></pre>\n"
				]
			},
			{
				"name": "scan",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"extensionModule": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"DomNode"
						],
						"usage": "optional",
						"summary": "<p>A default starting root node from which to start the parsing. Can be\nomitted, defaulting to the entire document. If omitted, the <code>options</code>\nobject can be passed in this place. If the <code>options</code> object has a\n<code>rootNode</code> member, that is used.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>a kwArgs options object, see parse() for details\n</p>\n"
					}
				],
				"returnTypes": [
					"Promise",
					"undefined"
				],
				"returnDescription": "<p>A promise that is resolved with the nodes that have been parsed.</p>\n",
				"summary": "<p>Scan a DOM tree and return an array of objects representing the DOMNodes\nthat need to be turned into widgets.</p>\n",
				"description": "<p>Search specified node (or document root node) recursively for class instances\nand return an array of objects that represent potential widgets to be\ninstantiated. Searches for either data-dojo-type=&quot;MID&quot; or dojoType=&quot;MID&quot; where\n&quot;MID&quot; is a module ID like &quot;dijit/form/Button&quot; or a fully qualified Class name\nlike &quot;dijit/form/Button&quot;.  If the MID is not currently available, scan will\nattempt to require() in the module.\n\n</p>\n<p>See parser.parse() for details of markup.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.window": {
		"location": "dojo/_base/kernel.window",
		"type": "object",
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "required",
						"summary": "<p>The document to get the associated window for.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get window object associated with document doc.</p>\n"
			},
			{
				"name": "getBox",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns the dimensions and scroll position of the viewable area of a browser window</p>\n"
			},
			{
				"name": "scrollIntoView",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/window",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DomNode"
						],
						"usage": "required"
					},
					{
						"name": "pos",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Scroll the passed node into view using minimal movement, if it is not already.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.i18n": {
		"location": "dojo/_base/kernel.i18n",
		"type": "object",
		"summary": "<p>This module implements the dojo/i18n! plugin and the v1.6- i18n API</p>\n",
		"description": "<p>We choose to include our own plugin to leverage functionality already contained in dojo\nand thereby reduce the size of the plugin compared to various loader implementations. Also, this\nallows foreign AMD loaders to be used without their plugins.</p>\n",
		"properties": [
			{
				"name": "cache",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/i18n",
				"extensionModule": true
			},
			{
				"name": "dynamic",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/i18n",
				"extensionModule": true
			},
			{
				"name": "unitTests",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/i18n",
				"extensionModule": true
			}
		],
		"methods": [
			{
				"name": "_preloadLocalizations",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "bundlePrefix",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "localesGenerated",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "guaranteedAmdFormat",
						"types": [
							"boolean"
						],
						"usage": "optional"
					},
					{
						"name": "contextRequire",
						"types": [
							"function"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)</p>\n",
				"description": "<p>Only called by built layer files. The entire locale hierarchy is loaded. For example,\nif locale==&quot;ab-cd&quot;, then ROOT, &quot;ab&quot;, and &quot;ab-cd&quot; are loaded. This is different than v1.6-\nin that the v1.6- would only load ab-cd...which was <em>always</em> flattened.\n\n</p>\n<p>If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm\nand the extra possible extra transaction.</p>\n"
			},
			{
				"name": "getL10nName",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"parameters": [
					{
						"name": "moduleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "bundleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "getLocalization",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"parameters": [
					{
						"name": "moduleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "bundleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "load",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>id is in one of the following formats\n\n</p>\n<ol>\n<li><p><path>/nls/<bundle>\n =&gt; load the bundle, localized to config.locale; load all bundles localized to\n config.extraLocale (if any); return the loaded bundle localized to config.locale.</p>\n</li>\n<li><p><path>/nls/<locale>/<bundle>\n =&gt; load then return the bundle localized to <locale></p>\n</li>\n<li><p><em>preload</em><path>/nls/<module>*<JSON array of available locales>\n =&gt; for config.locale and all config.extraLocale, load all bundles found\n in the best-matching bundle rollup. A value of 1 is returned, which\n is meaningless other than to say the plugin is executing the requested\n preloads</p>\n</li>\n</ol>\n<p>In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see\nnormalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.\n\n</p>\n<p>To load a bundle means to insert the bundle into the plugin&#39;s cache and publish the bundle\nvalue to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key\n\n</p>\n<pre><code>&lt;path&gt;/nls/&lt;bundle&gt;/&lt;locale&gt;</code></pre>\n<p>will hold the value. Similarly, then plugin will publish this value to the loader by\n\n</p>\n<pre><code>define(&quot;&lt;path&gt;/nls/&lt;bundle&gt;/&lt;locale&gt;&quot;, &lt;bundle-value&gt;);</code></pre>\n<p>Given this algorithm, other machinery can provide fast load paths be preplacing\nvalues in the plugin&#39;s cache, which is public. When a load is demanded the\ncache is inspected before starting any loading. Explicitly placing values in the plugin\ncache is an advanced/experimental feature that should not be needed; use at your own risk.\n\n</p>\n<p>For the normal AMD algorithm, the root bundle is loaded first, which instructs the\nplugin what additional localized bundles are required for a particular locale. These\nadditional locales are loaded and a mix of the root and each progressively-specific\nlocale is returned. For example:\n\n</p>\n<ol>\n<li><p>The client demands &quot;dojo/i18n!some/path/nls/someBundle</p>\n</li>\n<li><p>The loader demands load(some/path/nls/someBundle)</p>\n</li>\n<li><p>This plugin require&#39;s &quot;some/path/nls/someBundle&quot;, which is the root bundle.</p>\n</li>\n<li><p>Assuming config.locale is &quot;ab-cd-ef&quot; and the root bundle indicates that localizations\nare available for &quot;ab&quot; and &quot;ab-cd-ef&quot; (note the missing &quot;ab-cd&quot;, then the plugin\nrequires &quot;some/path/nls/ab/someBundle&quot; and &quot;some/path/nls/ab-cd-ef/someBundle&quot;</p>\n</li>\n<li><p>Upon receiving all required bundles, the plugin constructs the value of the bundle\nab-cd-ef as...</p>\n<pre><code> mixin(mixin(mixin({}, require(&quot;some/path/nls/someBundle&quot;),\n     require(&quot;some/path/nls/ab/someBundle&quot;)),\n     require(&quot;some/path/nls/ab-cd-ef/someBundle&quot;));</code></pre>\n</li>\n</ol>\n<p>This value is inserted into the cache and published to the loader at the\nkey/module-id some/path/nls/someBundle/ab-cd-ef.\n\n</p>\n<p>The special preload signature (case 3) instructs the plugin to stop servicing all normal requests\n(further preload requests will be serviced) until all ongoing preloading has completed.\n\n</p>\n<p>The preload signature instructs the plugin that a special rollup module is available that contains\none or more flattened, localized bundles. The JSON array of available locales indicates which locales\nare available. Here is an example:\n\n</p>\n<pre><code>*preload*some/path/nls/someModule*[&quot;root&quot;, &quot;ab&quot;, &quot;ab-cd-ef&quot;]</code></pre>\n<p>This indicates the following rollup modules are available:\n\n</p>\n<pre><code>some/path/nls/someModule_ROOT\nsome/path/nls/someModule_ab\nsome/path/nls/someModule_ab-cd-ef</code></pre>\n<p>Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.\nFor example, assume someModule contained the bundles some/bundle/path/someBundle and\nsome/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:\n\n</p>\n<pre><code>define({\n    some/bundle/path/someBundle:&lt;value of someBundle, flattened with respect to locale ab&gt;,\n    some/bundle/path/someOtherBundle:&lt;value of someOtherBundle, flattened with respect to locale ab&gt;,\n});</code></pre>\n<p>E.g., given this design, preloading for locale==&quot;ab&quot; can execute the following algorithm:\n\n</p>\n<pre><code>require([&quot;some/path/nls/someModule_ab&quot;], function(rollup){\n    for(var p in rollup){\n        var id = p + &quot;/ab&quot;,\n        cache[id] = rollup[p];\n        define(id, rollup[p]);\n    }\n});</code></pre>\n<p>Similarly, if &quot;ab-cd&quot; is requested, the algorithm can determine that &quot;ab&quot; is the best available and\nload accordingly.\n\n</p>\n<p>The builder will write such rollups for every layer if a non-empty localeList  profile property is\nprovided. Further, the builder will include the following cache entry in the cache associated with\nany layer.\n\n</p>\n<pre><code>&quot;*now&quot;:function(r){r([&#39;dojo/i18n!*preload*&lt;path&gt;/nls/&lt;module&gt;*&lt;JSON array of available locales&gt;&#39;]);}</code></pre>\n<p>The *now special cache module instructs the loader to apply the provided function to context-require\nwith respect to the particular layer being defined. This causes the plugin to hold all normal service\nrequests until all preloading is complete.\n\n</p>\n<p>Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case\nwhere the target locale has a single segment and a layer depends on a single bundle:\n\n</p>\n<p>Without Preloads:\n\n</p>\n<ol>\n<li>Layer loads root bundle.</li>\n<li>bundle is demanded; plugin loads single localized bundle.</li>\n</ol>\n<p>With Preloads:\n\n</p>\n<ol>\n<li>Layer causes preloading of target bundle.</li>\n<li>bundle is demanded; service is delayed until preloading complete; bundle is returned.</li>\n</ol>\n<p>In each case a single transaction is required to load the target bundle. In cases where multiple bundles\nare required and/or the locale has multiple segments, preloads still requires a single transaction whereas\nthe normal path requires an additional transaction for each additional bundle/locale-segment. However all\nof these additional transactions can be done concurrently. Owing to this analysis, the entire preloading\nalgorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.</p>\n"
			},
			{
				"name": "normalize",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "toAbsMid",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>id may be relative.\npreload has form <code>*preload*&lt;path&gt;/nls/&lt;module&gt;*&lt;flattened locales&gt;</code> and\ntherefore never looks like a relative</p>\n"
			},
			{
				"name": "normalizeLocale",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"extensionModule": true,
				"parameters": [
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"returnDescription": "<p>The locale to assume for loading localized resources in this page,\nspecified according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a>.\nMust be specified entirely in lowercase, e.g. <code>en-us</code> and <code>zh-cn</code>.\nSee the documentation for <code>dojo.i18n</code> and <code>dojo.requireLocalization</code>\nfor details on loading localized resources. If no locale is specified,\nDojo assumes the locale of the user agent, according to <code>navigator.userLanguage</code>\nor <code>navigator.language</code> properties.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.regexp": {
		"location": "dojo/_base/kernel.regexp",
		"type": "object",
		"summary": "<p>Regular expressions and Builder resources</p>\n",
		"methods": [
			{
				"name": "buildGroupRE",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/regexp",
				"extensionModule": true,
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Object",
							"Array"
						],
						"usage": "required",
						"summary": "<p>A single value or an array of values.</p>\n"
					},
					{
						"name": "re",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>A function. Takes one parameter and converts it to a regular\nexpression.</p>\n"
					},
					{
						"name": "nonCapture",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, uses non-capturing match, otherwise matches are retained\nby regular expression. Defaults to false</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Builds a regular expression that groups subexpressions</p>\n",
				"description": "<p>A utility function used by some of the RE generators. The\nsubexpressions are constructed by the function, re, in the second\nparameter.  re builds one subexpression for each elem in the array\na, in the first parameter. Returns a string for a regular\nexpression that groups all the subexpressions.</p>\n"
			},
			{
				"name": "escapeString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/regexp",
				"extensionModule": true,
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "except",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>a String with special characters to be left unescaped</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Adds escape sequences for special characters in regular expressions</p>\n"
			},
			{
				"name": "group",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/regexp",
				"extensionModule": true,
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "nonCapture",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, uses non-capturing match, otherwise matches are retained\nby regular expression.</p>\n"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>adds group match to expression</p>\n"
			}
		]
	},
	"dojo/_base/kernel.number": {
		"location": "dojo/_base/kernel.number",
		"type": "object",
		"summary": "<p>localized formatting and parsing routines for Number</p>\n",
		"properties": [
			{
				"name": "_numberPatternRE",
				"scope": "normal",
				"types": [
					"RegExp"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true
			}
		],
		"methods": [
			{
				"name": "__FormatAbsoluteOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__FormatOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__IntegerRegexpFlags",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__ParseOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__RealNumberRegexpFlags",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__RegexpOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyPattern",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted.</p>\n"
					},
					{
						"name": "pattern",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>a pattern string as described by\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">unicode.org TR35</a></p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>_applyPattern is usually called via <code>dojo/number.format()</code> which\npopulates an extra property in the options parameter, &quot;customs&quot;.\nThe customs object specifies group and decimal parameters if set.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Apply pattern to format value as a string using options. Gives no\nconsideration to local customs.</p>\n"
			},
			{
				"name": "_formatAbsolute",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted, ignores sign</p>\n"
					},
					{
						"name": "pattern",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the number portion of a pattern (e.g. <code>#,##0.00</code>)</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>decimal (String, optional): <p>the decimal separator</p>\n</li><li>group (String, optional): <p>the group separator</p>\n</li><li>places (Number|String, optional): <p>number of decimal places.  the range &quot;n,m&quot; will format to m places.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans don&#39;t round.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Apply numeric pattern to absolute value using options. Gives no\nconsideration to local customs.</p>\n"
			},
			{
				"name": "_integerRegexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "flags",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>signed (Boolean, optional): <p>The leading plus-or-minus sign. Can be true, false, or <code>[true,false]</code>.\nDefault is <code>[true, false]</code>, (i.e. will match if it is signed\nor unsigned).</p>\n</li><li>separator (String, optional): <p>The character used as the thousands separator. Default is no\nseparator. For more than one symbol use an array, e.g. <code>[&quot;,&quot;, &quot;&quot;]</code>,\nmakes &#39;,&#39; optional.</p>\n</li><li>groupSize (Number, optional): <p>group size between separators</p>\n</li><li>groupSize2 (Number, optional): <p>second grouping, where separators 2..n have a different interval than the first separator (for India)</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds a regular expression that matches an integer</p>\n"
			},
			{
				"name": "_parseInfo",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_realNumberRegexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "flags",
						"types": [
							"__RealNumberRegexpFlags"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds a regular expression to match a real number in exponential\nnotation</p>\n"
			},
			{
				"name": "format",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				],
				"summary": "<p>Format a Number as a String, using locale-specific settings</p>\n",
				"description": "<p>Create a string from a Number using a known localized pattern.\nFormatting patterns appropriate to the locale are chosen from the\n<a href=\"http://unicode.org/cldr\">Common Locale Data Repository</a> as well as the appropriate symbols and\ndelimiters.\nIf value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"extensionModule": true,
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representation of a Number</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by pattern\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Convert a properly formatted string to a primitive Number, using\nlocale-specific settings.</p>\n",
				"description": "<p>Create a Number from a string using a known localized pattern.\nFormatting patterns are chosen appropriate to the locale\nand follow the syntax described by\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">unicode.org TR35</a>\nNote that literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "regexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"extensionModule": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>places (Number|String, optional): <p>number of decimal places to accept: Infinity, a positive number, or\na range &quot;n,m&quot;.  Defined by pattern or Infinity if pattern not provided.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds the regular needed to parse a number</p>\n",
				"description": "<p>Returns regular expression with positive and negative match, group\nand decimal separators</p>\n"
			},
			{
				"name": "round",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The number to round</p>\n"
					},
					{
						"name": "places",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.\nMust be non-negative.</p>\n"
					},
					{
						"name": "increment",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>Rounds next place to nearest value of increment/10.  10 by default.</p>\n"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Rounds to the nearest value with the given number of decimal places, away from zero</p>\n",
				"description": "<p>Rounds to the nearest value with the given number of decimal places, away from zero if equal.\nSimilar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by\nfractional increments also, such as the nearest quarter.\nNOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.</p>\n",
				"examples": [
					"<pre><code>&gt;&gt;&gt; number.round(-0.5)\n-1\n&gt;&gt;&gt; number.round(162.295, 2)\n162.29  // note floating point error.  Should be 162.3\n&gt;&gt;&gt; number.round(10.71, 0, 2.5)\n10.75</code></pre>\n"
				]
			}
		]
	},
	"dojo/_base/kernel.cldr": {
		"location": "dojo/_base/kernel.cldr",
		"type": "object",
		"properties": [
			{
				"name": "monetary",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/cldr/monetary",
				"extensionModule": true,
				"summary": "<p>TODOC</p>\n"
			},
			{
				"name": "supplemental",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/cldr/supplemental",
				"extensionModule": true,
				"summary": "<p>TODOC</p>\n"
			}
		]
	},
	"dojo/_base/kernel.currency": {
		"location": "dojo/_base/kernel.currency",
		"type": "object",
		"summary": "<p>localized formatting and parsing routines for currencies</p>\n",
		"description": "<p>extends dojo.number to provide culturally-appropriate formatting of values\nin various world currencies, including use of a currency symbol.  The currencies are specified\nby a three-letter international symbol in all uppercase, and support for the currencies is\nprovided by the data in <code>dojo.cldr</code>.  The scripts generating dojo.cldr specify which\ncurrency support is included.  A fixed number of decimal places is determined based\non the currency type and is not determined by the &#39;pattern&#39; argument.  The fractional\nportion is optional, by default, and variable length decimals are not supported.</p>\n",
		"methods": [
			{
				"name": "__FormatOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/currency",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__ParseOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/currency",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_mixInDefaults",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "format",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"__FormatOptions"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Format a Number as a currency, using locale-specific settings\n</p>\n",
				"description": "<p>Create a string from a Number using a known, localized pattern.\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Elements\">Formatting patterns</a>\nappropriate to the locale are chosen from the <a href=\"http://unicode.org/cldr\">CLDR</a>\nas well as the appropriate symbols and delimiters and number of decimal places.\n</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"extensionModule": true,
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>type (String, optional): <p>Should not be set.  Value is assumed to be currency.</p>\n</li><li>currency (String, optional): <p>an <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code, a three letter sequence like &quot;USD&quot;.\nFor use with dojo.currency only.</p>\n</li><li>symbol (String, optional): <p>localized currency symbol. The default will be looked up in table of supported currencies in <code>dojo.cldr</code>\nA <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code will be used if not found.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to accept.  The default is determined based on which currency is used.</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by the currency\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.\nBy default for currencies, it the fractional portion is optional.</p>\n</li><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "regexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"extensionModule": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>places (Number|String, optional): <p>number of decimal places to accept: Infinity, a positive number, or\na range &quot;n,m&quot;.  Defined by pattern or Infinity if pattern not provided.</p>\n</li></ul>"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dojo/_base/kernel.fx": {
		"location": "dojo/_base/kernel.fx",
		"type": "object",
		"summary": "<p>Effects library on top of Base animations</p>\n",
		"properties": [
			{
				"name": "easing",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"summary": "<p>Collection of easing functions to use beyond the default\n<code>dojo._defaultEasing</code> function.</p>\n",
				"description": "<p>Easing functions are used to manipulate the iteration through\nan <code>dojo.Animation</code>s _Line. _Line being the properties of an Animation,\nand the easing function progresses through that Line determining\nhow quickly (or slowly) it should go. Or more accurately: modify\nthe value of the _Line based on the percentage of animation completed.\n\n</p>\n<p>All functions follow a simple naming convention of &quot;ease type&quot; + &quot;when&quot;.\nIf the name of the function ends in Out, the easing described appears\ntowards the end of the animation. &quot;In&quot; means during the beginning,\nand InOut means both ranges of the Animation will applied, both\nbeginning and end.\n\n</p>\n<p>One does not call the easing function directly, it must be passed to\nthe <code>easing</code> property of an animation.</p>\n",
				"examples": [
					"<pre><code>dojo.require(&quot;dojo.fx.easing&quot;);\nvar anim = dojo.fadeOut({\n    node: &#39;node&#39;,\n    duration: 2000,\n    //  note there is no ()\n    easing: dojo.fx.easing.quadIn\n}).play();</code></pre>\n"
				]
			}
		],
		"methods": [
			{
				"name": "chain",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "animations",
						"types": [
							"dojo/_base/fx.Animation[]"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Chain a list of <code>dojo.Animation</code>s to run in sequence\n</p>\n",
				"description": "<p>Return a <code>dojo.Animation</code> which will play all passed\n<code>dojo.Animation</code> instances in sequence, firing its own\nsynthesized events simulating a single animation. (eg:\nonEnd of this animation means the end of the chain,\nnot the individual animations within)\n</p>\n",
				"examples": [
					"<p>Once <code>node</code> is faded out, fade in <code>otherNode</code>\n\n</p>\n<pre><code>fx.chain([\n    dojo.fadeIn({ node:node }),\n    dojo.fadeOut({ node:otherNode })\n]).play();</code></pre>\n"
				]
			},
			{
				"name": "combine",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "animations",
						"types": [
							"dojo/_base/fx.Animation[]"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Combine a list of <code>dojo.Animation</code>s to run in parallel\n</p>\n",
				"description": "<p>Combine an array of <code>dojo.Animation</code>s to run in parallel,\nproviding a new <code>dojo.Animation</code> instance encompasing each\nanimation, firing standard animation events.\n</p>\n",
				"examples": [
					"<p>Fade out <code>node</code> while fading in <code>otherNode</code> simultaneously\n\n</p>\n<pre><code>fx.combine([\n    dojo.fadeIn({ node:node }),\n    dojo.fadeOut({ node:otherNode })\n]).play();</code></pre>\n",
					"<p>When the longest animation ends, execute a function:\n\n</p>\n<pre><code>var anim = fx.combine([\n    dojo.fadeIn({ node: n, duration:700 }),\n    dojo.fadeOut({ node: otherNode, duration: 300 })\n]);\naspect.after(anim, &quot;onEnd&quot;, function(){\n    // overall animation is done.\n}, true);\nanim.play(); // play the animation</code></pre>\n"
				]
			},
			{
				"name": "slideTo",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>A hash-map of standard <code>dojo.Animation</code> constructor properties\n(such as easing: node: duration: and so on). Special args members\nare <code>top</code> and <code>left</code>, which indicate the new position to slide to.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Slide a node to a new top/left position\n</p>\n",
				"description": "<p>Returns an animation that will slide &quot;node&quot;\ndefined in args Object from its current position to\nthe position defined by (args.left, args.top).\n</p>\n",
				"examples": [
					"<pre><code>.slideTo({ node: node, left:&quot;40&quot;, top:&quot;50&quot;, units:&quot;px&quot; }).play()</code></pre>\n"
				]
			},
			{
				"name": "wipeIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>A hash-map of standard <code>dojo.Animation</code> constructor properties\n(such as easing: node: duration: and so on)\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Expand a node to it&#39;s natural height.\n</p>\n",
				"description": "<p>Returns an animation that will expand the\nnode defined in &#39;args&#39; object from it&#39;s current height to\nit&#39;s natural height (with no scrollbar).\nNode must have no margin/border/padding.\n</p>\n",
				"examples": [
					"<pre><code>fx.wipeIn({\n    node:&quot;someId&quot;\n}).play()</code></pre>\n"
				]
			},
			{
				"name": "wipeOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"extensionModule": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>A hash-map of standard <code>dojo.Animation</code> constructor properties\n(such as easing: node: duration: and so on)\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Shrink a node to nothing and hide it.\n</p>\n",
				"description": "<p>Returns an animation that will shrink node defined in &quot;args&quot;\nfrom it&#39;s current height to 1px, and then hide it.\n</p>\n",
				"examples": [
					"<pre><code>fx.wipeOut({ node:&quot;someId&quot; }).play()</code></pre>\n"
				]
			}
		]
	},
	"dojo/_base/kernel.contentHandlers": {
		"location": "dojo/_base/kernel.contentHandlers",
		"type": "object",
		"summary": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls.</p>\n",
		"description": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls. Each contentHandler is\ncalled, passing the xhr object for manipulation. The return value\nfrom the contentHandler will be passed to the <code>load</code> or <code>handle</code>\nfunctions defined in the original xhr call.</p>\n",
		"examples": [
			"<p>Creating a custom content-handler:\n\n</p>\n<pre><code>xhr.contentHandlers.makeCaps = function(xhr){\n    return xhr.responseText.toUpperCase();\n}\n// and later:\ndojo.xhrGet({\n    url:&quot;foo.txt&quot;,\n    handleAs:&quot;makeCaps&quot;,\n    load: function(data){ /* data is a toUpper version of foo.txt */ }\n});</code></pre>\n"
		],
		"methods": [
			{
				"name": "javascript",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which evaluates the response data, expecting it to be valid JavaScript</p>\n"
			},
			{
				"name": "json",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which returns a JavaScript object created from the response data</p>\n"
			},
			{
				"name": "json-comment-filtered",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which expects comment-filtered JSON.</p>\n",
				"description": "<p>A contentHandler which expects comment-filtered JSON.\nthe json-comment-filtered option was implemented to prevent\n&quot;JavaScript Hijacking&quot;, but it is less secure than standard JSON. Use\nstandard JSON instead. JSON prefixing can be used to subvert hijacking.\n\n</p>\n<p>Will throw a notice suggesting to use application/json mimetype, as\njson-commenting can introduce security issues. To decrease the chances of hijacking,\nuse the standard <code>json</code> contentHandler, and prefix your &quot;JSON&quot; with: {}&amp;&amp;\n\n</p>\n<p>use djConfig.useCommentedJson = true to turn off the notice</p>\n"
			},
			{
				"name": "json-comment-optional",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which checks the presence of comment-filtered JSON and\nalternates between the <code>json</code> and <code>json-comment-filtered</code> contentHandlers.</p>\n"
			},
			{
				"name": "text",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which simply returns the plaintext response data</p>\n"
			},
			{
				"name": "xml",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler returning an XML Document parsed from the response data</p>\n"
			}
		]
	},
	"dojo/_base/kernel._contentHandlers": {
		"location": "dojo/_base/kernel._contentHandlers",
		"type": "object",
		"summary": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls.</p>\n",
		"description": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls. Each contentHandler is\ncalled, passing the xhr object for manipulation. The return value\nfrom the contentHandler will be passed to the <code>load</code> or <code>handle</code>\nfunctions defined in the original xhr call.</p>\n",
		"examples": [
			"<p>Creating a custom content-handler:\n\n</p>\n<pre><code>xhr.contentHandlers.makeCaps = function(xhr){\n    return xhr.responseText.toUpperCase();\n}\n// and later:\ndojo.xhrGet({\n    url:&quot;foo.txt&quot;,\n    handleAs:&quot;makeCaps&quot;,\n    load: function(data){ /* data is a toUpper version of foo.txt */ }\n});</code></pre>\n"
		],
		"methods": [
			{
				"name": "javascript",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which evaluates the response data, expecting it to be valid JavaScript</p>\n"
			},
			{
				"name": "json",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which returns a JavaScript object created from the response data</p>\n"
			},
			{
				"name": "json-comment-filtered",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which expects comment-filtered JSON.</p>\n",
				"description": "<p>A contentHandler which expects comment-filtered JSON.\nthe json-comment-filtered option was implemented to prevent\n&quot;JavaScript Hijacking&quot;, but it is less secure than standard JSON. Use\nstandard JSON instead. JSON prefixing can be used to subvert hijacking.\n\n</p>\n<p>Will throw a notice suggesting to use application/json mimetype, as\njson-commenting can introduce security issues. To decrease the chances of hijacking,\nuse the standard <code>json</code> contentHandler, and prefix your &quot;JSON&quot; with: {}&amp;&amp;\n\n</p>\n<p>use djConfig.useCommentedJson = true to turn off the notice</p>\n"
			},
			{
				"name": "json-comment-optional",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which checks the presence of comment-filtered JSON and\nalternates between the <code>json</code> and <code>json-comment-filtered</code> contentHandlers.</p>\n"
			},
			{
				"name": "text",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which simply returns the plaintext response data</p>\n"
			},
			{
				"name": "xml",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler returning an XML Document parsed from the response data</p>\n"
			}
		]
	},
	"dojo/_base/kernel.__IoArgs": {
		"location": "dojo/_base/kernel.__IoArgs",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "content",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n"
			},
			{
				"name": "form",
				"scope": "prototype",
				"types": [
					"DOMNode"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Acceptable values depend on the type of IO\ntransport (see specific IO calls for more information).</p>\n"
			},
			{
				"name": "ioPublish",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n"
			},
			{
				"name": "preventCache",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n"
			},
			{
				"name": "rawBody",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n"
			},
			{
				"name": "timeout",
				"scope": "prototype",
				"types": [
					"Integer"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n"
			},
			{
				"name": "url",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>URL to server endpoint.</p>\n"
			}
		],
		"methods": [
			{
				"name": "error",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The response in the format as defined with handleAs.</p>\n"
					},
					{
						"name": "ioArgs",
						"types": [
							"dojo/main.__IoCallbackArgs"
						],
						"usage": "required",
						"summary": "<p>Provides additional information about the request.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n"
			},
			{
				"name": "handle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "loadOrError",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Provides a string that tells you whether this function\nwas called because of success (load) or failure (error).</p>\n"
					},
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The response in the format as defined with handleAs.</p>\n"
					},
					{
						"name": "ioArgs",
						"types": [
							"dojo/main.__IoCallbackArgs"
						],
						"usage": "required",
						"summary": "<p>Provides additional information about the request.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n"
			},
			{
				"name": "load",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The response in the format as defined with handleAs.</p>\n"
					},
					{
						"name": "ioArgs",
						"types": [
							"dojo/main.__IoCallbackArgs"
						],
						"usage": "required",
						"summary": "<p>Provides additional information about the request.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function will be\ncalled on a successful HTTP response code.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.__IoCallbackArgs": {
		"location": "dojo/_base/kernel.__IoCallbackArgs",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "args",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>the original object argument to the IO call.</p>\n"
			},
			{
				"name": "canDelete",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>For dojo/io/script calls only, indicates\nwhether the script tag that represents the\nrequest can be deleted after callbacks have\nbeen called. Used internally to know when\ncleanup can happen on JSONP-type requests.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>The final indicator on how the response will be\nhandled.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>For dojo/io/script calls only, the internal\nscript ID used for the request.</p>\n"
			},
			{
				"name": "json",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>For dojo/io/script calls only: holds the JSON\nresponse for JSONP-type requests. Used\ninternally to hold on to the JSON responses.\nYou should not need to access it directly --\nthe same object should be passed to the success\ncallbacks directly.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>For non-GET requests, the\nname1=value1&amp;name2=value2 parameters sent up in\nthe request.</p>\n"
			},
			{
				"name": "url",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>The final URL used for the call. Many times it\nwill be different than the original args.url\nvalue.</p>\n"
			},
			{
				"name": "xhr",
				"scope": "prototype",
				"types": [
					"XMLHttpRequest"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>For XMLHttpRequest calls only, the\nXMLHttpRequest object that was used for the\nrequest.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.__IoPublish": {
		"location": "dojo/_base/kernel.__IoPublish",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>This is a list of IO topics that can be published\nif djConfig.ioPublish is set to true. IO topics can be\npublished for any Input/Output, network operation. So,\ndojo.xhr, dojo.io.script and dojo.io.iframe can all\ntrigger these topics to be published.</p>\n",
		"properties": [
			{
				"name": "done",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;/dojo/io/done&quot; is sent whenever an IO request has completed,\neither by loading or by erroring. It passes the error and\nthe dojo.Deferred for the request with the topic.</p>\n"
			},
			{
				"name": "error",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;/dojo/io/error&quot; is sent whenever an IO request has errored.\nIt passes the error and the dojo.Deferred\nfor the request with the topic.</p>\n"
			},
			{
				"name": "load",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;/dojo/io/load&quot; is sent whenever an IO request has loaded\nsuccessfully. It passes the response and the dojo.Deferred\nfor the request with the topic.</p>\n"
			},
			{
				"name": "send",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;/dojo/io/send&quot; is sent whenever a new IO request is started.\nIt passes the dojo.Deferred for the request with the topic.</p>\n"
			},
			{
				"name": "start",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;/dojo/io/start&quot; is sent when there are no outstanding IO\nrequests, and a new IO request is started. No arguments\nare passed with this topic.</p>\n"
			},
			{
				"name": "stop",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;/dojo/io/stop&quot; is sent when all outstanding IO requests have\nfinished. No arguments are passed with this topic.</p>\n"
			}
		]
	},
	"dojo/_base/kernel.__XhrArgs": {
		"location": "dojo/_base/kernel.__XhrArgs",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>In addition to the properties listed for the dojo._IoArgs type,\nthe following properties are allowed for dojo.xhr* methods.</p>\n",
		"properties": [
			{
				"name": "content",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n"
			},
			{
				"name": "contentType",
				"scope": "prototype",
				"types": [
					"String",
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n"
			},
			{
				"name": "failOk",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n"
			},
			{
				"name": "form",
				"scope": "prototype",
				"types": [
					"DOMNode"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n"
			},
			{
				"name": "headers",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Additional HTTP headers to send in the request.</p>\n"
			},
			{
				"name": "ioPublish",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n"
			},
			{
				"name": "preventCache",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n"
			},
			{
				"name": "rawBody",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n"
			},
			{
				"name": "sync",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n"
			},
			{
				"name": "timeout",
				"scope": "prototype",
				"types": [
					"Integer"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n"
			},
			{
				"name": "url",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"summary": "<p>URL to server endpoint.</p>\n"
			}
		],
		"methods": [
			{
				"name": "error",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The response in the format as defined with handleAs.</p>\n"
					},
					{
						"name": "ioArgs",
						"types": [
							"dojo/main.__IoCallbackArgs"
						],
						"usage": "required",
						"summary": "<p>Provides additional information about the request.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n"
			},
			{
				"name": "handle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "loadOrError",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Provides a string that tells you whether this function\nwas called because of success (load) or failure (error).</p>\n"
					},
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The response in the format as defined with handleAs.</p>\n"
					},
					{
						"name": "ioArgs",
						"types": [
							"dojo/main.__IoCallbackArgs"
						],
						"usage": "required",
						"summary": "<p>Provides additional information about the request.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n"
			},
			{
				"name": "load",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"extensionModule": true,
				"parameters": [
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The response in the format as defined with handleAs.</p>\n"
					},
					{
						"name": "ioArgs",
						"types": [
							"dojo/main.__IoCallbackArgs"
						],
						"usage": "required",
						"summary": "<p>Provides additional information about the request.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function will be\ncalled on a successful HTTP response code.</p>\n"
			}
		]
	},
	"dojo/has": {
		"location": "dojo/has",
		"type": "function",
		"parameters": [
			{
				"name": "name",
				"types": [
					"String",
					"Integer"
				],
				"usage": "required",
				"summary": "<p>The name (if a string) or identifier (if an integer) of the feature to test.\n</p>\n"
			}
		],
		"returnTypes": [
			"boolean"
		],
		"summary": "<p>Return the current value of the named feature.\n</p>\n",
		"description": "<p>Returns the value of the feature named by name. The feature must have been\npreviously added to the cache by has.add.</p>\n",
		"properties": [
			{
				"name": "cache",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/has"
			}
		],
		"methods": [
			{
				"name": "add",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/has",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String",
							"Integer"
						],
						"usage": "required",
						"summary": "<p>The name (if a string) or identifier (if an integer) of the feature to test.</p>\n"
					},
					{
						"name": "test",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>A test function to register. If a function, queued for testing until actually\nneeded. The test function should return a boolean indicating\nthe presence of a feature or bug.</p>\n"
					},
					{
						"name": "now",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Optional. Omit if <code>test</code> is not a function. Provides a way to immediately\nrun the test and cache the result.</p>\n"
					},
					{
						"name": "force",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Optional. If the test already exists and force is truthy, then the existing\ntest will be replaced; otherwise, add does not replace an existing test (that\nis, by default, the first test advice wins).</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Register a new feature test for some named feature.</p>\n",
				"examples": [
					"<p>A redundant test, testFn with immediate execution:\n\n</p>\n<pre><code>has.add(&quot;javascript&quot;, function(){ return true; }, true);</code></pre>\n",
					"<p>Again with the redundantness. You can do this in your tests, but we should\nnot be doing this in any internal has.js tests\n\n</p>\n<pre><code>has.add(&quot;javascript&quot;, true);</code></pre>\n",
					"<p>Three things are passed to the testFunction. <code>global</code>, <code>document</code>, and a generic element\nfrom which to work your test should the need arise.\n\n</p>\n<pre><code>has.add(&quot;bug-byid&quot;, function(g, d, el){\n    // g    == global, typically window, yadda yadda\n    // d    == document object\n    // el == the generic element. a `has` element.\n    return false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer\n});</code></pre>\n"
				]
			},
			{
				"name": "clearElement",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/has",
				"parameters": [
					{
						"name": "element",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deletes the contents of the element passed to test functions.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/has",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String",
							"Integer"
						],
						"usage": "required",
						"summary": "<p>The name (if a string) or identifier (if an integer) of the feature to test.\n</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Return the current value of the named feature.\n</p>\n",
				"description": "<p>Returns the value of the feature named by name. The feature must have been\npreviously added to the cache by has.add.</p>\n"
			},
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/has",
				"parameters": [
					{
						"name": "id",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Gives the resolved module id to load.</p>\n"
					},
					{
						"name": "parentRequire",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The loader require function with respect to the module that contained the plugin resource in it&#39;s\ndependency list.</p>\n"
					},
					{
						"name": "loaded",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback to loader that consumes result of plugin demand.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Conditional loading of AMD modules based on a has feature test value.</p>\n"
			},
			{
				"name": "normalize",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/has",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "toAbsMid",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Resolves a relative module id into an absolute module id</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).\n</p>\n"
			}
		]
	},
	"dojo/_base/config": {
		"location": "dojo/_base/config",
		"type": "object",
		"summary": "<p>This module defines the user configuration during bootstrap.</p>\n",
		"description": "<p>By defining user configuration as a module value, an entire configuration can be specified in a build,\nthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\nAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\nat an unique absolute module identifier as given by the package configuration. Implementing configuration\nas a module allows for specifying unique, per-instance configurations.</p>\n",
		"examples": [
			"<p>Create a second instance of dojo with a different, instance-unique configuration (assume the loader and\ndojo.js are already loaded).\n\n</p>\n<pre><code>// specify a configuration that creates a new instance of dojo at the absolute module identifier &quot;myDojo&quot;\nrequire({\n    packages:[{\n        name:&quot;myDojo&quot;,\n        location:&quot;.&quot;, //assume baseUrl points to dojo.js\n    }]\n});\n\n// specify a configuration for the myDojo instance\ndefine(&quot;myDojo/config&quot;, {\n    // normal configuration variables go here, e.g.,\n    locale:&quot;fr-ca&quot;\n});\n\n// load and use the new instance of dojo\nrequire([&quot;myDojo&quot;], function(dojo){\n    // dojo is the new instance of dojo\n    // use as required\n});</code></pre>\n"
		],
		"properties": [
			{
				"name": "addOnLoad",
				"scope": "normal",
				"types": [
					"Function",
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Adds a callback via dojo/ready. Useful when Dojo is added after\nthe page loads and djConfig.afterOnLoad is true. Supports the same\narguments as dojo/ready. When using a function reference, use\n<code>djConfig.addOnLoad = function(){};</code>. For object with function name use\n<code>djConfig.addOnLoad = [myObject, &quot;functionName&quot;];</code> and for object with\nfunction reference use\n<code>djConfig.addOnLoad = [myObject, function(){}];</code></p>\n"
			},
			{
				"name": "afterOnLoad",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/ready",
				"extensionModule": true
			},
			{
				"name": "baseUrl",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/_base/kernel",
				"extensionModule": true
			},
			{
				"name": "callback",
				"scope": "normal",
				"types": [
					"Function",
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Defines a callback to be used when dependencies are defined before \nthe loader has been loaded. When provided, they cause the loader to \nexecute require(deps, callback) once it has finished loading. \nShould be used with deps.</p>\n"
			},
			{
				"name": "defaultDuration",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Default duration, in milliseconds, for wipe and fade animations within dijits.\nAssigned to dijit.defaultDuration.</p>\n"
			},
			{
				"name": "deferredInstrumentation",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Whether deferred instrumentation should be loaded or included\nin builds.</p>\n"
			},
			{
				"name": "deps",
				"scope": "normal",
				"types": [
					"Function",
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Defines dependencies to be used before the loader has been loaded.\nWhen provided, they cause the loader to execute require(deps, callback) \nonce it has finished loading. Should be used with callback.</p>\n"
			},
			{
				"name": "dojoBlankHtmlUrl",
				"scope": "normal",
				"types": [
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Used by some modules to configure an empty iframe. Used by dojo/io/iframe and\ndojo/back, and dijit/popup support in IE where an iframe is needed to make sure native\ncontrols do not bleed through the popups. Normally this configuration variable\ndoes not need to be set, except when using cross-domain/CDN Dojo builds.\nSave dojo/resources/blank.html to your domain and set <code>djConfig.dojoBlankHtmlUrl</code>\nto the path on your domain your copy of blank.html.</p>\n"
			},
			{
				"name": "extraLocale",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>No default value. Specifies additional locales whose\nresources should also be loaded alongside the default locale when\ncalls to <code>dojo.requireLocalization()</code> are processed.</p>\n"
			},
			{
				"name": "ioPublish",
				"scope": "normal",
				"types": [
					"Boolean?"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Set this to true to enable publishing of topics for the different phases of\nIO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list\nof topics that are published.</p>\n"
			},
			{
				"name": "isDebug",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Defaults to <code>false</code>. If set to <code>true</code>, ensures that Dojo provides\nextended debugging feedback via Firebug. If Firebug is not available\non your platform, setting <code>isDebug</code> to <code>true</code> will force Dojo to\npull in (and display) the version of Firebug Lite which is\nintegrated into the Dojo distribution, thereby always providing a\ndebugging/logging console when <code>isDebug</code> is enabled. Note that\nFirebug&#39;s <code>console.*</code> methods are ALWAYS defined by Dojo. If\n<code>isDebug</code> is false and you are on a platform without Firebug, these\nmethods will be defined as no-ops.</p>\n"
			},
			{
				"name": "locale",
				"scope": "normal",
				"types": [
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>The locale to assume for loading localized resources in this page,\nspecified according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a>.\nMust be specified entirely in lowercase, e.g. <code>en-us</code> and <code>zh-cn</code>.\nSee the documentation for <code>dojo.i18n</code> and <code>dojo.requireLocalization</code>\nfor details on loading localized resources. If no locale is specified,\nDojo assumes the locale of the user agent, according to <code>navigator.userLanguage</code>\nor <code>navigator.language</code> properties.</p>\n"
			},
			{
				"name": "modulePaths",
				"scope": "normal",
				"types": [
					"Object"
				],
				"from": "dojo/_base/config",
				"tags": [
					"deprecated"
				],
				"summary": "<p>A map of module names to paths relative to <code>dojo.baseUrl</code>. The\nkey/value pairs correspond directly to the arguments which\n<code>dojo.registerModulePath</code> accepts. Specifying\n<code>djConfig.modulePaths = { &quot;foo&quot;: &quot;../../bar&quot; }</code> is the equivalent\nof calling <code>dojo.registerModulePath(&quot;foo&quot;, &quot;../../bar&quot;);</code>. Multiple\nmodules may be configured via <code>djConfig.modulePaths</code>.</p>\n"
			},
			{
				"name": "parseOnLoad",
				"scope": "normal",
				"types": [
					"Boolean"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Run the parser after the page is loaded</p>\n"
			},
			{
				"name": "require",
				"scope": "normal",
				"types": [
					"String[]"
				],
				"from": "dojo/_base/config",
				"summary": "<p>An array of module names to be loaded immediately after dojo.js has been included\nin a page.</p>\n"
			},
			{
				"name": "transparentColor",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Array containing the r, g, b components used as transparent color in dojo.Color;\nif undefined, [255,255,255] (white) will be used.</p>\n"
			},
			{
				"name": "useCustomLogger",
				"scope": "normal",
				"types": [
					"Anything?"
				],
				"from": "dojo/_base/config",
				"summary": "<p>If set to a value that evaluates to true such as a string or array and\nisDebug is true and Firebug is not available or running, then it bypasses\nthe creation of Firebug Lite allowing you to define your own console object.</p>\n"
			},
			{
				"name": "useDeferredInstrumentation",
				"scope": "normal",
				"types": [
					"Boolean",
					"String"
				],
				"from": "dojo/_base/config",
				"summary": "<p>Whether the deferred instrumentation should be used.\n\n</p>\n<ul>\n<li><code>&quot;report-rejections&quot;</code>: report each rejection as it occurs.</li>\n<li><code>true</code> or <code>1</code> or <code>&quot;report-unhandled-rejections&quot;</code>: wait 1 second\n  in an attempt to detect unhandled rejections.</li>\n</ul>\n"
			}
		]
	},
	"dojo/_base/config.modulePaths": {
		"location": "dojo/_base/config.modulePaths",
		"type": "object",
		"summary": "<p>A map of module names to paths relative to <code>dojo.baseUrl</code>. The\nkey/value pairs correspond directly to the arguments which\n<code>dojo.registerModulePath</code> accepts. Specifying\n<code>djConfig.modulePaths = { &quot;foo&quot;: &quot;../../bar&quot; }</code> is the equivalent\nof calling <code>dojo.registerModulePath(&quot;foo&quot;, &quot;../../bar&quot;);</code>. Multiple\nmodules may be configured via <code>djConfig.modulePaths</code>.</p>\n"
	},
	"dojo/_base/lang": {
		"location": "dojo/_base/lang",
		"type": "object",
		"summary": "<p>This module defines Javascript language extensions.</p>\n",
		"properties": [
			{
				"name": "_extraNames",
				"scope": "normal",
				"types": [
					"String[]"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"summary": "<p>Lists property names that must be explicitly processed during for-in iteration\nin environments that have has(&quot;bug-for-in-skips-shadowed&quot;) true.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_hitchArgs",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"parameters": [
					{
						"name": "scope",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				]
			},
			{
				"name": "_mixin",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"parameters": [
					{
						"name": "dest",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to which to copy/add all properties contained in source.</p>\n"
					},
					{
						"name": "source",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object from which to draw all properties to copy into dest.</p>\n"
					},
					{
						"name": "copyFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The process used to copy/add a property in source; defaults to the Javascript assignment operator.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"Object"
				],
				"returnDescription": "<p>dest, as modified</p>\n",
				"summary": "<p>Copies/adds all properties of source to dest; returns dest.</p>\n",
				"description": "<p>All properties, including functions (sometimes termed &quot;methods&quot;), excluding any non-standard extensions\nfound in Object.prototype, are copied/added to dest. Copying/adding each particular property is\ndelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\nNotice that by default, _mixin executes a so-called &quot;shallow copy&quot; and aggregate types are copied/added by reference.</p>\n"
			},
			{
				"name": "_toArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>the object to &quot;arrayify&quot;. We expect the object to have, at a\nminimum, a length property which corresponds to integer-indexed\nproperties.</p>\n"
					},
					{
						"name": "offset",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>the location in obj to start iterating from. Defaults to 0.\nOptional.</p>\n"
					},
					{
						"name": "startWith",
						"types": [
							"Array"
						],
						"usage": "optional",
						"summary": "<p>An array to pack with the properties of obj. If provided,\nproperties in obj are appended at the end of startWith and\nstartWith is the returned array.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Converts an array-like object (i.e. arguments, DOMCollection) to an\narray. Returns a new Array with the elements of obj.</p>\n"
			},
			{
				"name": "clone",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "src",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>The object to clone</p>\n"
					}
				],
				"returnTypes": [
					"anything",
					"undefined",
					"instance"
				],
				"returnDescription": "<p>The object to clone</p>\n",
				"summary": "<p>Clones objects (including DOM nodes) and all children.\nWarning: do not clone cyclic structures.</p>\n"
			},
			{
				"name": "countProperties",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/lang",
				"extensionModule": true,
				"parameters": [
					{
						"name": "object",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "delegate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to delegate to for properties not found directly on the\nreturn object or in props.</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object..."
						],
						"usage": "required",
						"summary": "<p>an object containing properties to assign to the returned object</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>an Object of anonymous type</p>\n",
				"summary": "<p>Returns a new object which &quot;looks&quot; to obj for properties which it\ndoes not have a value for. Optionally takes a bag of properties to\nseed the returned object with initially.</p>\n",
				"description": "<p>This is a small implementation of the Boodman/Crockford delegation\npattern in JavaScript. An intermediate object constructor mediates\nthe prototype chain for the returned object, using it to delegate\ndown to obj for property lookup when object-local lookup fails.\nThis can be thought of similarly to ES4&#39;s &quot;wrap&quot;, save that it does\nnot act on types but rather on pure objects.</p>\n",
				"examples": [
					"<pre><code>var foo = { bar: &quot;baz&quot; };\nvar thinger = lang.delegate(foo, { thud: &quot;xyzzy&quot;});\nthinger.bar == &quot;baz&quot;; // delegated to foo\nfoo.thud == undefined; // by definition\nthinger.thud == &quot;xyzzy&quot;; // mixed in from props\nfoo.bar = &quot;thonk&quot;;\nthinger.bar == &quot;thonk&quot;; // still delegated to foo&#39;s bar</code></pre>\n"
				]
			},
			{
				"name": "exists",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to an object, in the form &quot;A.B.C&quot;.</p>\n"
					},
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Object to use as root of path. Defaults to\n&#39;dojo.global&#39;. Null may be passed.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>determine if an object supports a given method</p>\n",
				"description": "<p>useful for longer api chains where you have to test each object in\nthe chain. Useful for object and method detection.</p>\n",
				"examples": [
					"<pre><code>// define an object\nvar foo = {\n      bar: { }\n};\n\n// search the global scope\nlang.exists(&quot;foo.bar&quot;); // true\nlang.exists(&quot;foo.bar.baz&quot;); // false\n\n// search from a particular scope\nlang.exists(&quot;bar&quot;, foo); // true\nlang.exists(&quot;bar.baz&quot;, foo); // false</code></pre>\n"
				]
			},
			{
				"name": "extend",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "ctor",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Target constructor to extend.</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>One or more objects to mix into ctor.prototype</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>Target constructor to extend.</p>\n",
				"summary": "<p>Adds all properties and methods of props to constructor&#39;s\nprototype, making them available to all instances created with\nconstructor.</p>\n"
			},
			{
				"name": "getObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to an property, in the form &quot;A.B.C&quot;.</p>\n"
					},
					{
						"name": "create",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Optional. Defaults to <code>false</code>. If <code>true</code>, Objects will be\ncreated at any point along the &#39;path&#39; that is undefined.</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Optional. Object to use as root of path. Defaults to\n&#39;dojo.global&#39;. Null may be passed.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a dot-separated string, such as &quot;A.B.C&quot;</p>\n",
				"description": "<p>Useful for longer api chains where you have to test each object in\nthe chain, or when you have an object reference in string format.</p>\n"
			},
			{
				"name": "hitch",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "scope",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The scope to use when method executes. If method is a string,\nscope is also the object containing method.</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function",
							"String..."
						],
						"usage": "required",
						"summary": "<p>A function to be hitched to scope, or the name of the method in\nscope to be hitched.</p>\n"
					}
				],
				"returnTypes": [
					"undefined",
					"function"
				],
				"summary": "<p>Returns a function that will only ever execute in the a given scope.\nThis allows for easy use of object member functions\nin callbacks and other places in which the &quot;this&quot; keyword may\notherwise not reference the expected scope.\nAny number of default positional arguments may be passed as parameters\nbeyond &quot;method&quot;.\nEach of these values will be used to &quot;placehold&quot; (similar to curry)\nfor the hitched function.</p>\n",
				"examples": [
					"<pre><code>lang.hitch(foo, &quot;bar&quot;)();</code></pre>\n<p>runs foo.bar() in the scope of foo\n</p>\n",
					"<pre><code>lang.hitch(foo, myFunction);</code></pre>\n<p>returns a function that runs myFunction in the scope of foo\n</p>\n",
					"<p>Expansion on the default positional arguments passed along from\nhitch. Passed args are mixed first, additional args after.\n\n</p>\n<pre><code>var foo = { bar: function(a, b, c){ console.log(a, b, c); } };\nvar fn = lang.hitch(foo, &quot;bar&quot;, 1, 2);\nfn(3); // logs &quot;1, 2, 3&quot;</code></pre>\n",
					"<pre><code>var foo = { bar: 2 };\nlang.hitch(foo, function(){ this.bar = 10; })();</code></pre>\n<p>execute an anonymous function in scope of foo\n</p>\n"
				]
			},
			{
				"name": "isAlien",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns true if it is a built-in function or some other kind of\noddball that <em>should</em> report as a function but doesn&#39;t</p>\n"
			},
			{
				"name": "isArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if it is an Array.\nDoes not work on Arrays created in other windows.</p>\n"
			},
			{
				"name": "isArrayLike",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"Boolean"
				],
				"returnDescription": "<p>If it walks like a duck and quacks like a duck, return <code>true</code></p>\n",
				"summary": "<p>similar to isArray() but more permissive</p>\n",
				"description": "<p>Doesn&#39;t strongly test for &quot;arrayness&quot;.  Instead, settles for &quot;isn&#39;t\na string or number and has a length property&quot;. Arguments objects\nand DOM collections will return true when passed to\nisArrayLike(), but will return false when passed to\nisArray().</p>\n"
			},
			{
				"name": "isFunction",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Return true if it is a Function</p>\n"
			},
			{
				"name": "isObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if it is a JavaScript object (or an Array, a Function\nor null)</p>\n"
			},
			{
				"name": "isString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Return true if it is a String</p>\n"
			},
			{
				"name": "mixin",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "dest",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to which to copy/add all properties contained in source. If dest is falsy, then\na new object is manufactured before copying/adding properties begins.</p>\n"
					},
					{
						"name": "sources",
						"types": [
							"Object..."
						],
						"usage": "required",
						"summary": "<p>One of more objects from which to draw all properties to copy into dest. sources are processed\nleft-to-right and if more than one of these objects contain the same property name, the right-most\nvalue &quot;wins&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"Object",
					"object"
				],
				"returnDescription": "<p>dest, as modified</p>\n",
				"summary": "<p>Copies/adds all properties of one or more sources to dest; returns dest.</p>\n",
				"description": "<p>All properties, including functions (sometimes termed &quot;methods&quot;), excluding any non-standard extensions\nfound in Object.prototype, are copied/added from sources to dest. sources are processed left to right.\nThe Javascript assignment operator is used to copy/add each property; therefore, by default, mixin\nexecutes a so-called &quot;shallow copy&quot; and aggregate types are copied/added by reference.</p>\n",
				"examples": [
					"<p>make a shallow copy of an object\n\n</p>\n<pre><code>var copy = lang.mixin({}, source);</code></pre>\n",
					"<p>many class constructors often take an object which specifies\nvalues to be configured on the object. In this case, it is\noften simplest to call <code>lang.mixin</code> on the <code>this</code> object:\n\n</p>\n<pre><code>declare(&quot;acme.Base&quot;, null, {\n    constructor: function(properties){\n        // property configuration:\n        lang.mixin(this, properties);\n\n        console.log(this.quip);\n        //  ...\n    },\n    quip: &quot;I wasn&#39;t born yesterday, you know - I&#39;ve seen movies.&quot;,\n    // ...\n});\n\n// create an instance of the class and configure it\nvar b = new acme.Base({quip: &quot;That&#39;s what it does!&quot; });</code></pre>\n",
					"<p>copy in properties from multiple objects\n\n</p>\n<pre><code>var flattened = lang.mixin(\n    {\n        name: &quot;Frylock&quot;,\n        braces: true\n    },\n    {\n        name: &quot;Carl Brutanananadilewski&quot;\n    }\n);\n\n// will print &quot;Carl Brutanananadilewski&quot;\nconsole.log(flattened.name);\n// will print &quot;true&quot;\nconsole.log(flattened.braces);</code></pre>\n"
				]
			},
			{
				"name": "mixinDeep",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/lang",
				"extensionModule": true,
				"parameters": [
					{
						"name": "dest",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "source",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Recursively mix the properties of two objects</p>\n"
			},
			{
				"name": "partial",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "method",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>The function to &quot;wrap&quot;</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>similar to hitch() except that the scope object is left to be\nwhatever the execution context eventually becomes.</p>\n",
				"description": "<p>Calling lang.partial is the functional equivalent of calling:\n\n</p>\n<pre><code>lang.hitch(null, funcName, ...);</code></pre>\n"
			},
			{
				"name": "replace",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be used as a template.</p>\n"
					},
					{
						"name": "map",
						"types": [
							"Object",
							"Function"
						],
						"usage": "required",
						"summary": "<p>If an object, it is used as a dictionary to look up substitutions.\nIf a function, it is called for every substitution with following parameters:\na whole match, a name, an offset, and the whole template\nstring (see <a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace</a>\nfor more details).</p>\n"
					},
					{
						"name": "pattern",
						"types": [
							"RegEx"
						],
						"usage": "optional",
						"summary": "<p>Optional regular expression objects that overrides the default pattern.\nMust be global and match one item. The default is: /{([^}]+)}/g,\nwhich matches patterns like that: &quot;{xxx}&quot;, where &quot;xxx&quot; is any sequence\nof characters, which doesn&#39;t include &quot;}&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"returnDescription": "<p>Returns the substituted string.</p>\n",
				"summary": "<p>Performs parameterized substitutions on a string. Throws an\nexception if any parameter is unmatched.</p>\n",
				"examples": [
					"<pre><code>// uses a dictionary for substitutions:\nlang.replace(&quot;Hello, {name.first} {name.last} AKA {nick}!&quot;,\n    {\n        nick: &quot;Bob&quot;,\n        name: {\n            first:  &quot;Robert&quot;,\n            middle: &quot;X&quot;,\n            last:       &quot;Cringely&quot;\n        }\n    });\n// returns: Hello, Robert Cringely AKA Bob!</code></pre>\n",
					"<pre><code>// uses an array for substitutions:\nlang.replace(&quot;Hello, {0} {2}!&quot;,\n    [&quot;Robert&quot;, &quot;X&quot;, &quot;Cringely&quot;]);\n// returns: Hello, Robert Cringely!</code></pre>\n",
					"<pre><code>// uses a function for substitutions:\nfunction sum(a){\n    var t = 0;\n    arrayforEach(a, function(x){ t += x; });\n    return t;\n}\nlang.replace(\n    &quot;{count} payments averaging {avg} USD per payment.&quot;,\n    lang.hitch(\n        { payments: [11, 16, 12] },\n        function(_, key){\n            switch(key){\n                case &quot;count&quot;: return this.payments.length;\n                case &quot;min&quot;:     return Math.min.apply(Math, this.payments);\n                case &quot;max&quot;:     return Math.max.apply(Math, this.payments);\n                case &quot;sum&quot;:     return sum(this.payments);\n                case &quot;avg&quot;:     return sum(this.payments) / this.payments.length;\n            }\n        }\n    )\n);\n// prints: 3 payments averaging 13 USD per payment.</code></pre>\n",
					"<pre><code>// uses an alternative PHP-like pattern for substitutions:\nlang.replace(&quot;Hello, ${0} ${2}!&quot;,\n    [&quot;Robert&quot;, &quot;X&quot;, &quot;Cringely&quot;], /\\$\\{([^\\}]+)\\}/g);\n// returns: Hello, Robert Cringely!</code></pre>\n"
				]
			},
			{
				"name": "setObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to a property, in the form &quot;A.B.C&quot;.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>value or object to place at location given by name</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Optional. Object to use as root of path. Defaults to\n<code>dojo.global</code>.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Set a property from a dot-separated string, such as &quot;A.B.C&quot;</p>\n",
				"description": "<p>Useful for longer api chains where you have to test each object in\nthe chain, or when you have an object reference in string format.\nObjects are created as needed along <code>path</code>. Returns the passed\nvalue if setting is successful or <code>undefined</code> if not.</p>\n",
				"examples": [
					"<p>set the value of <code>foo.bar.baz</code>, regardless of whether\nintermediate objects already exist:\n\n</p>\n<pre><code>lang.setObject(&quot;foo.bar.baz&quot;, value);</code></pre>\n",
					"<p>without <code>lang.setObject</code>, we often see code like this:\n\n</p>\n<pre><code>// ensure that intermediate objects are available\nif(!obj[&quot;parent&quot;]){ obj.parent = {}; }\nif(!obj.parent[&quot;child&quot;]){ obj.parent.child = {}; }\n// now we can safely set the property\nobj.parent.child.prop = &quot;some value&quot;;</code></pre>\n<p>whereas with <code>lang.setObject</code>, we can shorten that to:\n\n\n</p>\n<pre><code>lang.setObject(&quot;parent.child.prop&quot;, &quot;some value&quot;, obj);</code></pre>\n"
				]
			},
			{
				"name": "trim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be trimmed</p>\n"
					}
				],
				"returnTypes": [
					"String"
				],
				"returnDescription": "<p>Returns the trimmed string</p>\n",
				"summary": "<p>Trims whitespace from both sides of the string</p>\n",
				"description": "<p>This version of trim() was selected for inclusion into the base due\nto its compact size and relatively good performance\n(see <a href=\"http://blog.stevenlevithan.com/archives/faster-trim-javascript\">Steven Levithan&#39;s blog</a>\nUses String.prototype.trim instead, if available.\nThe fastest but longest version of this function is located at\nlang.string.trim()</p>\n"
			}
		]
	},
	"dojo/sniff": {
		"location": "dojo/sniff",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>This module sets has() flags based on the current browser.\nIt returns the has() function.</p>\n",
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/sniff",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This module sets has() flags based on the current browser.\nIt returns the has() function.</p>\n"
			}
		]
	},
	"havok/config/exception/notStatic": {
		"location": "havok/config/exception/notStatic",
		"type": "undefined"
	},
	"dojo/errors/create": {
		"location": "dojo/errors/create",
		"type": "function",
		"parameters": [
			{
				"name": "name",
				"types": [
					"undefined"
				],
				"usage": "required"
			},
			{
				"name": "ctor",
				"types": [
					"undefined"
				],
				"usage": "required"
			},
			{
				"name": "base",
				"types": [
					"undefined"
				],
				"usage": "required"
			},
			{
				"name": "props",
				"types": [
					"undefined"
				],
				"usage": "required"
			}
		],
		"returnTypes": [
			"function"
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/errors/create",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "ctor",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "base",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "props",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				]
			}
		]
	},
	"havok/exception/Base": {
		"location": "havok/exception/Base",
		"type": "undefined"
	},
	"havok/exception/severity": {
		"location": "havok/exception/severity",
		"type": "object",
		"properties": [
			{
				"name": "ERROR",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "havok/exception/severity"
			},
			{
				"name": "NOTICE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "havok/exception/severity"
			},
			{
				"name": "WARNING",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "havok/exception/severity"
			}
		],
		"methods": [
			{
				"name": "codeToString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/exception/severity",
				"parameters": [
					{
						"name": "code",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string",
					"undefined"
				]
			}
		]
	},
	"havok/config/main": {
		"location": "havok/config/main",
		"type": "undefined"
	},
	"havok/config/manager": {
		"location": "havok/config/manager",
		"type": "object",
		"summary": "<p>Allows the merging of multiple config objects into dojo config.</p>\n",
		"methods": [
			{
				"name": "merge",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/config/manager",
				"parameters": [
					{
						"name": "mergeConfigs",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "target",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>optional. Object.\nAn object to merged the config objects into.\nIf null, dojoConfig itself will be used.</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Merges multiple config modules\n</p>\n"
			}
		]
	},
	"dojo/Deferred": {
		"location": "dojo/Deferred",
		"type": "function",
		"parameters": [
			{
				"name": "canceler",
				"types": [
					"Function"
				],
				"usage": "optional",
				"summary": "<p>Will be invoked if the deferred is canceled. The canceler\nreceives the reason the deferred was canceled as its argument.\nThe deferred is rejected with its return value, or a new\n<code>dojo/errors/CancelError</code> instance.</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Creates a new deferred. This API is preferred over\n<code>dojo/_base/Deferred</code>.</p>\n",
		"description": "<p>Creates a new deferred, as an abstraction over (primarily)\nasynchronous operations. The deferred is the private interface\nthat should not be returned to calling code. That&#39;s what the\n<code>promise</code> is for. See <code>dojo/promise/Promise</code>.</p>\n",
		"properties": [
			{
				"name": "promise",
				"scope": "normal",
				"types": [
					"instance"
				],
				"from": "dojo/Deferred"
			}
		],
		"methods": [
			{
				"name": "cancel",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [
					{
						"name": "reason",
						"types": [
							"any"
						],
						"usage": "required",
						"summary": "<p>A message that may be sent to the deferred&#39;s canceler,\nexplaining why it&#39;s being canceled.</p>\n"
					},
					{
						"name": "strict",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If strict, will throw an error if the deferred has already\nbeen fulfilled and consequently cannot be canceled.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>Returns the rejection reason if the deferred was canceled\nnormally.</p>\n",
				"summary": "<p>Inform the deferred it may cancel its asynchronous operation.</p>\n",
				"description": "<p>Inform the deferred it may cancel its asynchronous operation.\nThe deferred&#39;s (optional) canceler is invoked and the\ndeferred will be left in a rejected state. Can affect other\npromises that originate with the same deferred.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [
					{
						"name": "canceler",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Will be invoked if the deferred is canceled. The canceler\nreceives the reason the deferred was canceled as its argument.\nThe deferred is rejected with its return value, or a new\n<code>dojo/errors/CancelError</code> instance.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Creates a new deferred. This API is preferred over\n<code>dojo/_base/Deferred</code>.</p>\n",
				"description": "<p>Creates a new deferred, as an abstraction over (primarily)\nasynchronous operations. The deferred is the private interface\nthat should not be returned to calling code. That&#39;s what the\n<code>promise</code> is for. See <code>dojo/promise/Promise</code>.</p>\n"
			},
			{
				"name": "isCanceled",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been canceled.</p>\n"
			},
			{
				"name": "isFulfilled",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been resolved or rejected.</p>\n"
			},
			{
				"name": "isRejected",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been rejected.</p>\n"
			},
			{
				"name": "isResolved",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been resolved.</p>\n"
			},
			{
				"name": "progress",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [
					{
						"name": "update",
						"types": [
							"any"
						],
						"usage": "required",
						"summary": "<p>The progress update. Passed to progbacks.</p>\n"
					},
					{
						"name": "strict",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If strict, will throw an error if the deferred has already\nbeen fulfilled and consequently no progress can be emitted.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise"
				],
				"returnDescription": "<p>Returns the original promise for the deferred.</p>\n",
				"summary": "<p>Emit a progress update on the deferred.</p>\n",
				"description": "<p>Emit a progress update on the deferred. Progress updates\ncan be used to communicate updates about the asynchronous\noperation before it has finished.</p>\n"
			},
			{
				"name": "reject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [
					{
						"name": "error",
						"types": [
							"any"
						],
						"usage": "required",
						"summary": "<p>The error result of the deferred. Passed to errbacks.</p>\n"
					},
					{
						"name": "strict",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If strict, will throw an error if the deferred has already\nbeen fulfilled and consequently cannot be rejected.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"instance"
				],
				"returnDescription": "<p>Returns the original promise for the deferred.</p>\n",
				"summary": "<p>Reject the deferred.</p>\n",
				"description": "<p>Reject the deferred, putting it in an error state.</p>\n"
			},
			{
				"name": "resolve",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [
					{
						"name": "value",
						"types": [
							"any"
						],
						"usage": "required",
						"summary": "<p>The result of the deferred. Passed to callbacks.</p>\n"
					},
					{
						"name": "strict",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If strict, will throw an error if the deferred has already\nbeen fulfilled and consequently cannot be resolved.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise"
				],
				"returnDescription": "<p>Returns the original promise for the deferred.</p>\n",
				"summary": "<p>Resolve the deferred.</p>\n",
				"description": "<p>Resolve the deferred, putting it in a success state.</p>\n"
			},
			{
				"name": "then",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is resolved.\nReceives the resolution value.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.\nReceives the rejection error.</p>\n"
					},
					{
						"name": "progback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise emits a progress\nupdate. Receives the progress update.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise"
				],
				"returnDescription": "<p>Returns a new promise for the result of the callback(s).\nThis can be used for chaining many asynchronous operations.</p>\n",
				"summary": "<p>Add new callbacks to the deferred.</p>\n",
				"description": "<p>Add new callbacks to the deferred. Callbacks can be added\nbefore or after the deferred is fulfilled.</p>\n"
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Deferred",
				"parameters": [],
				"returnTypes": [
					"String"
				],
				"returnDescription": "<p>Returns <code>[object Deferred]</code>.</p>\n"
			}
		]
	},
	"dojo/errors/CancelError": {
		"location": "dojo/errors/CancelError",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>Default error if a promise is canceled without a reason.</p>\n",
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/errors/CancelError",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Default error if a promise is canceled without a reason.</p>\n"
			}
		]
	},
	"dojo/promise/Promise": {
		"location": "dojo/promise/Promise",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>The public interface to a deferred.</p>\n",
		"description": "<p>The public interface to a deferred. All promises in Dojo are\ninstances of this class.</p>\n",
		"methods": [
			{
				"name": "always",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "callbackOrErrback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>A function that is used both as a callback and errback.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Returns a new promise for the result of the callback/errback.</p>\n",
				"summary": "<p>Add a callback to be invoked when the promise is resolved\nor rejected.</p>\n"
			},
			{
				"name": "cancel",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "reason",
						"types": [
							"any"
						],
						"usage": "required",
						"summary": "<p>A message that may be sent to the deferred&#39;s canceler,\nexplaining why it&#39;s being canceled.</p>\n"
					},
					{
						"name": "strict",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If strict, will throw an error if the deferred has already\nbeen fulfilled and consequently cannot be canceled.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>Returns the rejection reason if the deferred was canceled\nnormally.</p>\n",
				"summary": "<p>Inform the deferred it may cancel its asynchronous operation.</p>\n",
				"description": "<p>Inform the deferred it may cancel its asynchronous operation.\nThe deferred&#39;s (optional) canceler is invoked and the\ndeferred will be left in a rejected state. Can affect other\npromises that originate with the same deferred.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>The public interface to a deferred.</p>\n",
				"description": "<p>The public interface to a deferred. All promises in Dojo are\ninstances of this class.</p>\n"
			},
			{
				"name": "isCanceled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been canceled.</p>\n"
			},
			{
				"name": "isFulfilled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been resolved or rejected.</p>\n"
			},
			{
				"name": "isRejected",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been rejected.</p>\n"
			},
			{
				"name": "isResolved",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been resolved.</p>\n"
			},
			{
				"name": "otherwise",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Returns a new promise for the result of the errback.</p>\n",
				"summary": "<p>Add new errbacks to the promise.</p>\n"
			},
			{
				"name": "then",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is resolved.\nReceives the resolution value.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.\nReceives the rejection error.</p>\n"
					},
					{
						"name": "progback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise emits a progress\nupdate. Receives the progress update.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise"
				],
				"returnDescription": "<p>Returns a new promise for the result of the callback(s).\nThis can be used for chaining many asynchronous operations.</p>\n",
				"summary": "<p>Add new callbacks to the promise.</p>\n",
				"description": "<p>Add new callbacks to the deferred. Callbacks can be added\nbefore or after the deferred is fulfilled.</p>\n"
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"returnDescription": "<p>Returns <code>[object Promise]</code>.</p>\n"
			},
			{
				"name": "trace",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"function"
				]
			},
			{
				"name": "traceRejected",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"function"
				]
			}
		]
	},
	"dojo/DeferredList": {
		"location": "dojo/DeferredList",
		"type": "function",
		"parameters": [
			{
				"name": "list",
				"types": [
					"Array"
				],
				"usage": "required",
				"summary": "<p>The list of deferreds to be synchronizied with this DeferredList</p>\n"
			},
			{
				"name": "fireOnOneCallback",
				"types": [
					"Boolean"
				],
				"usage": "optional",
				"summary": "<p>Will cause the DeferredLists callback to be fired as soon as any\nof the deferreds in its list have been fired instead of waiting until\nthe entire list has finished</p>\n"
			},
			{
				"name": "fireOnOneErrback",
				"types": [
					"Boolean"
				],
				"usage": "optional"
			},
			{
				"name": "consumeErrors",
				"types": [
					"Boolean"
				],
				"usage": "optional"
			},
			{
				"name": "canceller",
				"types": [
					"Function"
				],
				"usage": "optional",
				"summary": "<p>A deferred canceller function, see dojo.Deferred</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Deprecated, use dojo/promise/all instead.\nProvides event handling for a group of Deferred objects.</p>\n",
		"description": "<p>DeferredList takes an array of existing deferreds and returns a new deferred of its own\nthis new deferred will typically have its callback fired when all of the deferreds in\nthe given list have fired their own deferreds.  The parameters <code>fireOnOneCallback</code> and\nfireOnOneErrback, will fire before all the deferreds as appropriate</p>\n",
		"methods": [
			{
				"name": "gatherResults",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/DeferredList",
				"parameters": [
					{
						"name": "deferredList",
						"types": [
							"dojo/DeferredList"
						],
						"usage": "required",
						"summary": "<p>The deferred list from which this function gathers results.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/DeferredList"
				],
				"returnDescription": "<p>The newly created deferred list which packs results as\nparameters to its callback.</p>\n",
				"summary": "<p>Gathers the results of the deferreds for packaging\nas the parameters to the Deferred Lists&#39; callback</p>\n"
			}
		]
	},
	"dojo/_base/Deferred": {
		"location": "dojo/_base/Deferred",
		"type": "function",
		"parameters": [
			{
				"name": "canceller",
				"types": [
					"Function"
				],
				"usage": "optional"
			}
		],
		"returnTypes": [],
		"summary": "<p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.\nNew code should use dojo/Deferred instead.</p>\n",
		"description": "<p>The Deferred API is based on the concept of promises that provide a\ngeneric interface into the eventual completion of an asynchronous action.\nThe motivation for promises fundamentally is about creating a\nseparation of concerns that allows one to achieve the same type of\ncall patterns and logical data flow in asynchronous code as can be\nachieved in synchronous code. Promises allows one\nto be able to call a function purely with arguments needed for\nexecution, without conflating the call with concerns of whether it is\nsync or async. One shouldn&#39;t need to alter a call&#39;s arguments if the\nimplementation switches from sync to async (or vice versa). By having\nasync functions return promises, the concerns of making the call are\nseparated from the concerns of asynchronous interaction (which are\nhandled by the promise).\n\n</p>\n<p>The Deferred is a type of promise that provides methods for fulfilling the\npromise with a successful result or an error. The most important method for\nworking with Dojo&#39;s promises is the then() method, which follows the\nCommonJS proposed promise API. An example of using a Dojo promise:\n\n\n</p>\n<pre><code>var resultingPromise = someAsyncOperation.then(function(result){\n    ... handle result ...\n},\nfunction(error){\n    ... handle error ...\n});</code></pre>\n<p>The .then() call returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.\n\n</p>\n<p>The Deferred instances also provide the following functions for backwards compatibility:\n\n</p>\n<ul>\n<li>addCallback(handler)</li>\n<li>addErrback(handler)</li>\n<li>callback(result)</li>\n<li>errback(result)</li>\n</ul>\n<p>Callbacks are allowed to return promises themselves, so\nyou can build complicated sequences of events with ease.\n\n</p>\n<p>The creator of the Deferred may specify a canceller.  The canceller\nis a function that will be called if Deferred.cancel is called\nbefore the Deferred fires. You can use this to implement clean\naborting of an XMLHttpRequest, etc. Note that cancel will fire the\ndeferred with a CancelledError (unless your canceller returns\nanother kind of error), so the errbacks should be prepared to\nhandle that error for cancellable Deferreds.</p>\n",
		"examples": [
			"<pre><code>var deferred = new Deferred();\nsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\nreturn deferred;</code></pre>\n",
			"<p>Deferred objects are often used when making code asynchronous. It\nmay be easiest to write functions in a synchronous manner and then\nsplit code using a deferred to trigger a response to a long-lived\noperation. For example, instead of register a callback function to\ndenote when a rendering operation completes, the function can\nsimply return a deferred:\n\n\n</p>\n<pre><code>// callback style:\nfunction renderLotsOfData(data, callback){\n    var success = false\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        success = true;\n    }catch(e){ }\n    if(callback){\n        callback(success);\n    }\n}\n\n\n// using callback style\nrenderLotsOfData(someDataObj, function(success){\n    // handles success or failure\n    if(!success){\n        promptUserToRecover();\n    }\n});\n// NOTE: no way to add another callback here!!</code></pre>\n",
			"<p>Using a Deferred doesn&#39;t simplify the sending code any, but it\nprovides a standard interface for callers and senders alike,\nproviding both with a simple way to service multiple callbacks for\nan operation and freeing both sides from worrying about details\nsuch as &quot;did this get called already?&quot;. With Deferreds, new\ncallbacks can be added at any time.\n\n\n</p>\n<pre><code>// Deferred style:\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        d.callback(true);\n    }catch(e){\n        d.errback(new Error(&quot;rendering failed&quot;));\n    }\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n// NOTE: addErrback and addCallback both return the Deferred\n// again, so we could chain adding callbacks or save the\n// deferred for later should we need to be notified again.</code></pre>\n",
			"<p>In this example, renderLotsOfData is synchronous and so both\nversions are pretty artificial. Putting the data display on a\ntimeout helps show why Deferreds rock:\n\n\n</p>\n<pre><code>// Deferred style and async func\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    setTimeout(function(){\n        try{\n            for(var x in data){\n                renderDataitem(data[x]);\n            }\n            d.callback(true);\n        }catch(e){\n            d.errback(new Error(&quot;rendering failed&quot;));\n        }\n    }, 100);\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});</code></pre>\n<p>Note that the caller doesn&#39;t have to change his code at all to\nhandle the asynchronous case.</p>\n"
		],
		"properties": [
			{
				"name": "fired",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Deferred"
			},
			{
				"name": "promise",
				"scope": "normal",
				"types": [
					"instance"
				],
				"from": "dojo/_base/Deferred"
			}
		],
		"methods": [
			{
				"name": "addBoth",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Returns this deferred object.</p>\n",
				"summary": "<p>Add handler as both successful callback and error callback for this deferred instance.</p>\n"
			},
			{
				"name": "addCallback",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Returns this deferred object.</p>\n",
				"summary": "<p>Adds successful callback for this deferred instance.</p>\n"
			},
			{
				"name": "addCallbacks",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The callback attached to this deferred object.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The error callback attached to this deferred object.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>Returns this deferred object.</p>\n",
				"summary": "<p>Adds callback and error callback for this deferred instance.</p>\n"
			},
			{
				"name": "addErrback",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Returns this deferred object.</p>\n",
				"summary": "<p>Adds error callback for this deferred instance.</p>\n"
			},
			{
				"name": "callback",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fulfills the Deferred instance successfully with the provide value</p>\n"
			},
			{
				"name": "cancel",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Cancels the asynchronous operation</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "canceller",
						"types": [
							"Function"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated.   This module defines the legacy dojo/_base/Deferred API.\nNew code should use dojo/Deferred instead.</p>\n",
				"description": "<p>The Deferred API is based on the concept of promises that provide a\ngeneric interface into the eventual completion of an asynchronous action.\nThe motivation for promises fundamentally is about creating a\nseparation of concerns that allows one to achieve the same type of\ncall patterns and logical data flow in asynchronous code as can be\nachieved in synchronous code. Promises allows one\nto be able to call a function purely with arguments needed for\nexecution, without conflating the call with concerns of whether it is\nsync or async. One shouldn&#39;t need to alter a call&#39;s arguments if the\nimplementation switches from sync to async (or vice versa). By having\nasync functions return promises, the concerns of making the call are\nseparated from the concerns of asynchronous interaction (which are\nhandled by the promise).\n\n</p>\n<p>The Deferred is a type of promise that provides methods for fulfilling the\npromise with a successful result or an error. The most important method for\nworking with Dojo&#39;s promises is the then() method, which follows the\nCommonJS proposed promise API. An example of using a Dojo promise:\n\n\n</p>\n<pre><code>var resultingPromise = someAsyncOperation.then(function(result){\n    ... handle result ...\n},\nfunction(error){\n    ... handle error ...\n});</code></pre>\n<p>The .then() call returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.\n\n</p>\n<p>The Deferred instances also provide the following functions for backwards compatibility:\n\n</p>\n<ul>\n<li>addCallback(handler)</li>\n<li>addErrback(handler)</li>\n<li>callback(result)</li>\n<li>errback(result)</li>\n</ul>\n<p>Callbacks are allowed to return promises themselves, so\nyou can build complicated sequences of events with ease.\n\n</p>\n<p>The creator of the Deferred may specify a canceller.  The canceller\nis a function that will be called if Deferred.cancel is called\nbefore the Deferred fires. You can use this to implement clean\naborting of an XMLHttpRequest, etc. Note that cancel will fire the\ndeferred with a CancelledError (unless your canceller returns\nanother kind of error), so the errbacks should be prepared to\nhandle that error for cancellable Deferreds.</p>\n",
				"examples": [
					"<pre><code>var deferred = new Deferred();\nsetTimeout(function(){ deferred.callback({success: true}); }, 1000);\nreturn deferred;</code></pre>\n",
					"<p>Deferred objects are often used when making code asynchronous. It\nmay be easiest to write functions in a synchronous manner and then\nsplit code using a deferred to trigger a response to a long-lived\noperation. For example, instead of register a callback function to\ndenote when a rendering operation completes, the function can\nsimply return a deferred:\n\n\n</p>\n<pre><code>// callback style:\nfunction renderLotsOfData(data, callback){\n    var success = false\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        success = true;\n    }catch(e){ }\n    if(callback){\n        callback(success);\n    }\n}\n\n\n// using callback style\nrenderLotsOfData(someDataObj, function(success){\n    // handles success or failure\n    if(!success){\n        promptUserToRecover();\n    }\n});\n// NOTE: no way to add another callback here!!</code></pre>\n",
					"<p>Using a Deferred doesn&#39;t simplify the sending code any, but it\nprovides a standard interface for callers and senders alike,\nproviding both with a simple way to service multiple callbacks for\nan operation and freeing both sides from worrying about details\nsuch as &quot;did this get called already?&quot;. With Deferreds, new\ncallbacks can be added at any time.\n\n\n</p>\n<pre><code>// Deferred style:\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    try{\n        for(var x in data){\n            renderDataitem(data[x]);\n        }\n        d.callback(true);\n    }catch(e){\n        d.errback(new Error(&quot;rendering failed&quot;));\n    }\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});\n// NOTE: addErrback and addCallback both return the Deferred\n// again, so we could chain adding callbacks or save the\n// deferred for later should we need to be notified again.</code></pre>\n",
					"<p>In this example, renderLotsOfData is synchronous and so both\nversions are pretty artificial. Putting the data display on a\ntimeout helps show why Deferreds rock:\n\n\n</p>\n<pre><code>// Deferred style and async func\nfunction renderLotsOfData(data){\n    var d = new Deferred();\n    setTimeout(function(){\n        try{\n            for(var x in data){\n                renderDataitem(data[x]);\n            }\n            d.callback(true);\n        }catch(e){\n            d.errback(new Error(&quot;rendering failed&quot;));\n        }\n    }, 100);\n    return d;\n}\n\n\n// using Deferred style\nrenderLotsOfData(someDataObj).then(null, function(){\n    promptUserToRecover();\n});</code></pre>\n<p>Note that the caller doesn&#39;t have to change his code at all to\nhandle the asynchronous case.</p>\n"
				]
			},
			{
				"name": "errback",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "error",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fulfills the Deferred instance as an error with the provided error</p>\n"
			},
			{
				"name": "isCanceled",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been canceled.</p>\n"
			},
			{
				"name": "isFulfilled",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been resolved or rejected.</p>\n"
			},
			{
				"name": "isRejected",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been rejected.</p>\n"
			},
			{
				"name": "isResolved",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the deferred has been resolved.</p>\n"
			},
			{
				"name": "progress",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "update",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Send progress events to all listeners</p>\n"
			},
			{
				"name": "reject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "error",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fulfills the Deferred instance as an error with the provided error</p>\n"
			},
			{
				"name": "resolve",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fulfills the Deferred instance successfully with the provide value</p>\n"
			},
			{
				"name": "then",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Deferred",
				"parameters": [
					{
						"name": "resolvedCallback",
						"types": [
							"Function"
						],
						"usage": "optional"
					},
					{
						"name": "errorCallback",
						"types": [
							"Function"
						],
						"usage": "optional"
					},
					{
						"name": "progressCallback",
						"types": [
							"Function"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>Returns a new promise that represents the result of the\nexecution of the callback. The callbacks will never affect the original promises value.</p>\n",
				"summary": "<p>Adds a fulfilledHandler, errorHandler, and progressHandler to be called for\ncompletion of a promise. The fulfilledHandler is called when the promise\nis fulfilled. The errorHandler is called when a promise fails. The\nprogressHandler is called for progress events. All arguments are optional\nand non-function values are ignored. The progressHandler is not only an\noptional argument, but progress events are purely optional. Promise\nproviders are not required to ever create progress events.\n\n</p>\n<p>This function will return a new promise that is fulfilled when the given\nfulfilledHandler or errorHandler callback is finished. This allows promise\noperations to be chained together. The value returned from the callback\nhandler is the fulfillment value for the returned promise. If the callback\nthrows an error, the returned promise will be moved to failed state.\n</p>\n",
				"examples": [
					"<p>An example of using a CommonJS compliant promise:\n\n</p>\n<pre><code>asyncComputeTheAnswerToEverything().\n    then(addTwo).\n    then(printResult, onError);\n&gt;44</code></pre>\n"
				]
			},
			{
				"name": "when",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/when",
				"parameters": [
					{
						"name": "valueOrPromise",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Either a regular value or an object with a <code>then()</code> method that\nfollows the Promises/A specification.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is resolved, or a non-promise\nis received.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
					},
					{
						"name": "progback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise emits a progress update.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Promise, or if a callback is provided, the result of the callback.</p>\n",
				"summary": "<p>Transparently applies callbacks to values and/or promises.</p>\n",
				"description": "<p>Accepts promises but also transparently handles non-promises. If no\ncallbacks are provided returns a promise, regardless of the initial\nvalue. Foreign promises are converted.\n\n</p>\n<p>If callbacks are provided and the initial value is not a promise,\nthe callback is executed immediately with no error handling. Returns\na promise if the initial value is a promise, or the result of the\ncallback otherwise.</p>\n"
			}
		]
	},
	"dojo/when": {
		"location": "dojo/when",
		"type": "function",
		"parameters": [
			{
				"name": "valueOrPromise",
				"types": [
					"undefined"
				],
				"usage": "required",
				"summary": "<p>Either a regular value or an object with a <code>then()</code> method that\nfollows the Promises/A specification.</p>\n"
			},
			{
				"name": "callback",
				"types": [
					"Function"
				],
				"usage": "optional",
				"summary": "<p>Callback to be invoked when the promise is resolved, or a non-promise\nis received.</p>\n"
			},
			{
				"name": "errback",
				"types": [
					"Function"
				],
				"usage": "optional",
				"summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
			},
			{
				"name": "progback",
				"types": [
					"Function"
				],
				"usage": "optional",
				"summary": "<p>Callback to be invoked when the promise emits a progress update.</p>\n"
			}
		],
		"returnTypes": [
			"dojo/promise/Promise",
			"undefined"
		],
		"returnDescription": "<p>Promise, or if a callback is provided, the result of the callback.</p>\n",
		"summary": "<p>Transparently applies callbacks to values and/or promises.</p>\n",
		"description": "<p>Accepts promises but also transparently handles non-promises. If no\ncallbacks are provided returns a promise, regardless of the initial\nvalue. Foreign promises are converted.\n\n</p>\n<p>If callbacks are provided and the initial value is not a promise,\nthe callback is executed immediately with no error handling. Returns\na promise if the initial value is a promise, or the result of the\ncallback otherwise.</p>\n",
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/when",
				"parameters": [
					{
						"name": "valueOrPromise",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Either a regular value or an object with a <code>then()</code> method that\nfollows the Promises/A specification.</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is resolved, or a non-promise\nis received.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
					},
					{
						"name": "progback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise emits a progress update.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Promise, or if a callback is provided, the result of the callback.</p>\n",
				"summary": "<p>Transparently applies callbacks to values and/or promises.</p>\n",
				"description": "<p>Accepts promises but also transparently handles non-promises. If no\ncallbacks are provided returns a promise, regardless of the initial\nvalue. Foreign promises are converted.\n\n</p>\n<p>If callbacks are provided and the initial value is not a promise,\nthe callback is executed immediately with no error handling. Returns\na promise if the initial value is a promise, or the result of the\ncallback otherwise.</p>\n"
			}
		]
	},
	"havok/lang": {
		"location": "havok/lang",
		"type": "object",
		"summary": "<p>This module defines Javascript language extensions.</p>\n",
		"properties": [
			{
				"name": "_extraNames",
				"scope": "normal",
				"types": [
					"String[]"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"summary": "<p>Lists property names that must be explicitly processed during for-in iteration\nin environments that have has(&quot;bug-for-in-skips-shadowed&quot;) true.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_hitchArgs",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"parameters": [
					{
						"name": "scope",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				]
			},
			{
				"name": "_mixin",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"parameters": [
					{
						"name": "dest",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to which to copy/add all properties contained in source.</p>\n"
					},
					{
						"name": "source",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object from which to draw all properties to copy into dest.</p>\n"
					},
					{
						"name": "copyFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The process used to copy/add a property in source; defaults to the Javascript assignment operator.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"Object"
				],
				"returnDescription": "<p>dest, as modified</p>\n",
				"summary": "<p>Copies/adds all properties of source to dest; returns dest.</p>\n",
				"description": "<p>All properties, including functions (sometimes termed &quot;methods&quot;), excluding any non-standard extensions\nfound in Object.prototype, are copied/added to dest. Copying/adding each particular property is\ndelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\nNotice that by default, _mixin executes a so-called &quot;shallow copy&quot; and aggregate types are copied/added by reference.</p>\n"
			},
			{
				"name": "_toArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>the object to &quot;arrayify&quot;. We expect the object to have, at a\nminimum, a length property which corresponds to integer-indexed\nproperties.</p>\n"
					},
					{
						"name": "offset",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>the location in obj to start iterating from. Defaults to 0.\nOptional.</p>\n"
					},
					{
						"name": "startWith",
						"types": [
							"Array"
						],
						"usage": "optional",
						"summary": "<p>An array to pack with the properties of obj. If provided,\nproperties in obj are appended at the end of startWith and\nstartWith is the returned array.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Converts an array-like object (i.e. arguments, DOMCollection) to an\narray. Returns a new Array with the elements of obj.</p>\n"
			},
			{
				"name": "clone",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "src",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>The object to clone</p>\n"
					}
				],
				"returnTypes": [
					"anything",
					"undefined",
					"instance"
				],
				"returnDescription": "<p>The object to clone</p>\n",
				"summary": "<p>Clones objects (including DOM nodes) and all children.\nWarning: do not clone cyclic structures.</p>\n"
			},
			{
				"name": "countProperties",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/lang",
				"parameters": [
					{
						"name": "object",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "delegate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to delegate to for properties not found directly on the\nreturn object or in props.</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object..."
						],
						"usage": "required",
						"summary": "<p>an object containing properties to assign to the returned object</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>an Object of anonymous type</p>\n",
				"summary": "<p>Returns a new object which &quot;looks&quot; to obj for properties which it\ndoes not have a value for. Optionally takes a bag of properties to\nseed the returned object with initially.</p>\n",
				"description": "<p>This is a small implementation of the Boodman/Crockford delegation\npattern in JavaScript. An intermediate object constructor mediates\nthe prototype chain for the returned object, using it to delegate\ndown to obj for property lookup when object-local lookup fails.\nThis can be thought of similarly to ES4&#39;s &quot;wrap&quot;, save that it does\nnot act on types but rather on pure objects.</p>\n",
				"examples": [
					"<pre><code>var foo = { bar: &quot;baz&quot; };\nvar thinger = lang.delegate(foo, { thud: &quot;xyzzy&quot;});\nthinger.bar == &quot;baz&quot;; // delegated to foo\nfoo.thud == undefined; // by definition\nthinger.thud == &quot;xyzzy&quot;; // mixed in from props\nfoo.bar = &quot;thonk&quot;;\nthinger.bar == &quot;thonk&quot;; // still delegated to foo&#39;s bar</code></pre>\n"
				]
			},
			{
				"name": "exists",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to an object, in the form &quot;A.B.C&quot;.</p>\n"
					},
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Object to use as root of path. Defaults to\n&#39;dojo.global&#39;. Null may be passed.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>determine if an object supports a given method</p>\n",
				"description": "<p>useful for longer api chains where you have to test each object in\nthe chain. Useful for object and method detection.</p>\n",
				"examples": [
					"<pre><code>// define an object\nvar foo = {\n      bar: { }\n};\n\n// search the global scope\nlang.exists(&quot;foo.bar&quot;); // true\nlang.exists(&quot;foo.bar.baz&quot;); // false\n\n// search from a particular scope\nlang.exists(&quot;bar&quot;, foo); // true\nlang.exists(&quot;bar.baz&quot;, foo); // false</code></pre>\n"
				]
			},
			{
				"name": "extend",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "ctor",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Target constructor to extend.</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>One or more objects to mix into ctor.prototype</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>Target constructor to extend.</p>\n",
				"summary": "<p>Adds all properties and methods of props to constructor&#39;s\nprototype, making them available to all instances created with\nconstructor.</p>\n"
			},
			{
				"name": "getObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to an property, in the form &quot;A.B.C&quot;.</p>\n"
					},
					{
						"name": "create",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>Optional. Defaults to <code>false</code>. If <code>true</code>, Objects will be\ncreated at any point along the &#39;path&#39; that is undefined.</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Optional. Object to use as root of path. Defaults to\n&#39;dojo.global&#39;. Null may be passed.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a dot-separated string, such as &quot;A.B.C&quot;</p>\n",
				"description": "<p>Useful for longer api chains where you have to test each object in\nthe chain, or when you have an object reference in string format.</p>\n"
			},
			{
				"name": "hitch",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "scope",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The scope to use when method executes. If method is a string,\nscope is also the object containing method.</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function",
							"String..."
						],
						"usage": "required",
						"summary": "<p>A function to be hitched to scope, or the name of the method in\nscope to be hitched.</p>\n"
					}
				],
				"returnTypes": [
					"undefined",
					"function"
				],
				"summary": "<p>Returns a function that will only ever execute in the a given scope.\nThis allows for easy use of object member functions\nin callbacks and other places in which the &quot;this&quot; keyword may\notherwise not reference the expected scope.\nAny number of default positional arguments may be passed as parameters\nbeyond &quot;method&quot;.\nEach of these values will be used to &quot;placehold&quot; (similar to curry)\nfor the hitched function.</p>\n",
				"examples": [
					"<pre><code>lang.hitch(foo, &quot;bar&quot;)();</code></pre>\n<p>runs foo.bar() in the scope of foo\n</p>\n",
					"<pre><code>lang.hitch(foo, myFunction);</code></pre>\n<p>returns a function that runs myFunction in the scope of foo\n</p>\n",
					"<p>Expansion on the default positional arguments passed along from\nhitch. Passed args are mixed first, additional args after.\n\n</p>\n<pre><code>var foo = { bar: function(a, b, c){ console.log(a, b, c); } };\nvar fn = lang.hitch(foo, &quot;bar&quot;, 1, 2);\nfn(3); // logs &quot;1, 2, 3&quot;</code></pre>\n",
					"<pre><code>var foo = { bar: 2 };\nlang.hitch(foo, function(){ this.bar = 10; })();</code></pre>\n<p>execute an anonymous function in scope of foo\n</p>\n"
				]
			},
			{
				"name": "isAlien",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns true if it is a built-in function or some other kind of\noddball that <em>should</em> report as a function but doesn&#39;t</p>\n"
			},
			{
				"name": "isArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if it is an Array.\nDoes not work on Arrays created in other windows.</p>\n"
			},
			{
				"name": "isArrayLike",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"Boolean"
				],
				"returnDescription": "<p>If it walks like a duck and quacks like a duck, return <code>true</code></p>\n",
				"summary": "<p>similar to isArray() but more permissive</p>\n",
				"description": "<p>Doesn&#39;t strongly test for &quot;arrayness&quot;.  Instead, settles for &quot;isn&#39;t\na string or number and has a length property&quot;. Arguments objects\nand DOM collections will return true when passed to\nisArrayLike(), but will return false when passed to\nisArray().</p>\n"
			},
			{
				"name": "isFunction",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Return true if it is a Function</p>\n"
			},
			{
				"name": "isObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if it is a JavaScript object (or an Array, a Function\nor null)</p>\n"
			},
			{
				"name": "isString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "it",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>Item to test.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Return true if it is a String</p>\n"
			},
			{
				"name": "mixin",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "dest",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to which to copy/add all properties contained in source. If dest is falsy, then\na new object is manufactured before copying/adding properties begins.</p>\n"
					},
					{
						"name": "sources",
						"types": [
							"Object..."
						],
						"usage": "required",
						"summary": "<p>One of more objects from which to draw all properties to copy into dest. sources are processed\nleft-to-right and if more than one of these objects contain the same property name, the right-most\nvalue &quot;wins&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"Object",
					"object"
				],
				"returnDescription": "<p>dest, as modified</p>\n",
				"summary": "<p>Copies/adds all properties of one or more sources to dest; returns dest.</p>\n",
				"description": "<p>All properties, including functions (sometimes termed &quot;methods&quot;), excluding any non-standard extensions\nfound in Object.prototype, are copied/added from sources to dest. sources are processed left to right.\nThe Javascript assignment operator is used to copy/add each property; therefore, by default, mixin\nexecutes a so-called &quot;shallow copy&quot; and aggregate types are copied/added by reference.</p>\n",
				"examples": [
					"<p>make a shallow copy of an object\n\n</p>\n<pre><code>var copy = lang.mixin({}, source);</code></pre>\n",
					"<p>many class constructors often take an object which specifies\nvalues to be configured on the object. In this case, it is\noften simplest to call <code>lang.mixin</code> on the <code>this</code> object:\n\n</p>\n<pre><code>declare(&quot;acme.Base&quot;, null, {\n    constructor: function(properties){\n        // property configuration:\n        lang.mixin(this, properties);\n\n        console.log(this.quip);\n        //  ...\n    },\n    quip: &quot;I wasn&#39;t born yesterday, you know - I&#39;ve seen movies.&quot;,\n    // ...\n});\n\n// create an instance of the class and configure it\nvar b = new acme.Base({quip: &quot;That&#39;s what it does!&quot; });</code></pre>\n",
					"<p>copy in properties from multiple objects\n\n</p>\n<pre><code>var flattened = lang.mixin(\n    {\n        name: &quot;Frylock&quot;,\n        braces: true\n    },\n    {\n        name: &quot;Carl Brutanananadilewski&quot;\n    }\n);\n\n// will print &quot;Carl Brutanananadilewski&quot;\nconsole.log(flattened.name);\n// will print &quot;true&quot;\nconsole.log(flattened.braces);</code></pre>\n"
				]
			},
			{
				"name": "mixinDeep",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/lang",
				"parameters": [
					{
						"name": "dest",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "source",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Recursively mix the properties of two objects</p>\n"
			},
			{
				"name": "partial",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "method",
						"types": [
							"Function",
							"String"
						],
						"usage": "required",
						"summary": "<p>The function to &quot;wrap&quot;</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>similar to hitch() except that the scope object is left to be\nwhatever the execution context eventually becomes.</p>\n",
				"description": "<p>Calling lang.partial is the functional equivalent of calling:\n\n</p>\n<pre><code>lang.hitch(null, funcName, ...);</code></pre>\n"
			},
			{
				"name": "replace",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be used as a template.</p>\n"
					},
					{
						"name": "map",
						"types": [
							"Object",
							"Function"
						],
						"usage": "required",
						"summary": "<p>If an object, it is used as a dictionary to look up substitutions.\nIf a function, it is called for every substitution with following parameters:\na whole match, a name, an offset, and the whole template\nstring (see <a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace</a>\nfor more details).</p>\n"
					},
					{
						"name": "pattern",
						"types": [
							"RegEx"
						],
						"usage": "optional",
						"summary": "<p>Optional regular expression objects that overrides the default pattern.\nMust be global and match one item. The default is: /{([^}]+)}/g,\nwhich matches patterns like that: &quot;{xxx}&quot;, where &quot;xxx&quot; is any sequence\nof characters, which doesn&#39;t include &quot;}&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"returnDescription": "<p>Returns the substituted string.</p>\n",
				"summary": "<p>Performs parameterized substitutions on a string. Throws an\nexception if any parameter is unmatched.</p>\n",
				"examples": [
					"<pre><code>// uses a dictionary for substitutions:\nlang.replace(&quot;Hello, {name.first} {name.last} AKA {nick}!&quot;,\n    {\n        nick: &quot;Bob&quot;,\n        name: {\n            first:  &quot;Robert&quot;,\n            middle: &quot;X&quot;,\n            last:       &quot;Cringely&quot;\n        }\n    });\n// returns: Hello, Robert Cringely AKA Bob!</code></pre>\n",
					"<pre><code>// uses an array for substitutions:\nlang.replace(&quot;Hello, {0} {2}!&quot;,\n    [&quot;Robert&quot;, &quot;X&quot;, &quot;Cringely&quot;]);\n// returns: Hello, Robert Cringely!</code></pre>\n",
					"<pre><code>// uses a function for substitutions:\nfunction sum(a){\n    var t = 0;\n    arrayforEach(a, function(x){ t += x; });\n    return t;\n}\nlang.replace(\n    &quot;{count} payments averaging {avg} USD per payment.&quot;,\n    lang.hitch(\n        { payments: [11, 16, 12] },\n        function(_, key){\n            switch(key){\n                case &quot;count&quot;: return this.payments.length;\n                case &quot;min&quot;:     return Math.min.apply(Math, this.payments);\n                case &quot;max&quot;:     return Math.max.apply(Math, this.payments);\n                case &quot;sum&quot;:     return sum(this.payments);\n                case &quot;avg&quot;:     return sum(this.payments) / this.payments.length;\n            }\n        }\n    )\n);\n// prints: 3 payments averaging 13 USD per payment.</code></pre>\n",
					"<pre><code>// uses an alternative PHP-like pattern for substitutions:\nlang.replace(&quot;Hello, ${0} ${2}!&quot;,\n    [&quot;Robert&quot;, &quot;X&quot;, &quot;Cringely&quot;], /\\$\\{([^\\}]+)\\}/g);\n// returns: Hello, Robert Cringely!</code></pre>\n"
				]
			},
			{
				"name": "setObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to a property, in the form &quot;A.B.C&quot;.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required",
						"summary": "<p>value or object to place at location given by name</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Optional. Object to use as root of path. Defaults to\n<code>dojo.global</code>.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Set a property from a dot-separated string, such as &quot;A.B.C&quot;</p>\n",
				"description": "<p>Useful for longer api chains where you have to test each object in\nthe chain, or when you have an object reference in string format.\nObjects are created as needed along <code>path</code>. Returns the passed\nvalue if setting is successful or <code>undefined</code> if not.</p>\n",
				"examples": [
					"<p>set the value of <code>foo.bar.baz</code>, regardless of whether\nintermediate objects already exist:\n\n</p>\n<pre><code>lang.setObject(&quot;foo.bar.baz&quot;, value);</code></pre>\n",
					"<p>without <code>lang.setObject</code>, we often see code like this:\n\n</p>\n<pre><code>// ensure that intermediate objects are available\nif(!obj[&quot;parent&quot;]){ obj.parent = {}; }\nif(!obj.parent[&quot;child&quot;]){ obj.parent.child = {}; }\n// now we can safely set the property\nobj.parent.child.prop = &quot;some value&quot;;</code></pre>\n<p>whereas with <code>lang.setObject</code>, we can shorten that to:\n\n\n</p>\n<pre><code>lang.setObject(&quot;parent.child.prop&quot;, &quot;some value&quot;, obj);</code></pre>\n"
				]
			},
			{
				"name": "trim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/lang",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be trimmed</p>\n"
					}
				],
				"returnTypes": [
					"String"
				],
				"returnDescription": "<p>Returns the trimmed string</p>\n",
				"summary": "<p>Trims whitespace from both sides of the string</p>\n",
				"description": "<p>This version of trim() was selected for inclusion into the base due\nto its compact size and relatively good performance\n(see <a href=\"http://blog.stevenlevithan.com/archives/faster-trim-javascript\">Steven Levithan&#39;s blog</a>\nUses String.prototype.trim instead, if available.\nThe fastest but longest version of this function is located at\nlang.string.trim()</p>\n"
			}
		]
	},
	"havok/is": {
		"location": "havok/is",
		"type": "object",
		"methods": [
			{
				"name": "isDate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/is",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks if a value is a date object. Will not attempt to cast a string\ninto a date. If you need to cast strings to dates, look at dojo/date</p>\n"
			},
			{
				"name": "isDeferred",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/is",
				"parameters": [
					{
						"name": "object",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "isFilter",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/filter/Base",
				"extensionModule": true,
				"parameters": [
					{
						"name": "filter",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "isFloat",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/is",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks if a value is a float or can be cast into an integer</p>\n"
			},
			{
				"name": "isInt",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/is",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Checks if a value is an integer or can be cast into an integer</p>\n"
			},
			{
				"name": "isStatic",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/is",
				"parameters": [
					{
						"name": "value",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"havok/config/ready": {
		"location": "havok/config/ready",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/config/ready",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/config": {
		"location": "havok/config",
		"type": "object",
		"properties": [
			{
				"name": "less",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/config"
			},
			{
				"name": "merge",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "havok/config"
			}
		]
	},
	"havok/config.less": {
		"location": "havok/config.less",
		"type": "object",
		"properties": [
			{
				"name": "havok/less/havok-defs.less",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/config"
			},
			{
				"name": "havok/less/havok-rank1.less",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/config"
			},
			{
				"name": "havok/less/havok-rank3.less",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/config"
			}
		]
	},
	"havok/cssfx": {
		"location": "havok/cssfx",
		"type": "object",
		"methods": [
			{
				"name": "transitionEndEvent",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/cssfx",
				"parameters": [],
				"returnTypes": [
					"string"
				]
			}
		]
	},
	"havok/di/Di": {
		"location": "havok/di/Di",
		"type": "constructor",
		"classlike": true,
		"parameters": [
			{
				"name": "config",
				"types": [
					"object"
				],
				"usage": "required"
			}
		],
		"returnTypes": [],
		"summary": "<p>An object used for dependency injection.\n</p>\n",
		"description": "<p>The config property may be populated with a config object that\ndefines what to inject.\n</p>\n",
		"methods": [
			{
				"name": "_create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"mixed"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"instance"
				],
				"summary": "<p>Used to create an object with the supplied identifier</p>\n"
			},
			{
				"name": "_createProxy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"mixed"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"mixed"
				],
				"summary": "<p>Used to get an object with the supplied identifier</p>\n"
			},
			{
				"name": "_getCached",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"null"
				],
				"summary": "<p>Will return an instance of object with the supplied identifier\nif it already exists. If not, will return null.</p>\n"
			},
			{
				"name": "_inject",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "object",
						"types": [
							"object"
						],
						"usage": "required"
					},
					{
						"name": "config",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object",
					"instance"
				],
				"summary": "<p>Used to inject an object with the objects defined in the\nsupplied config\n</p>\n"
			},
			{
				"name": "_proxy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Used to get a proxy to the object with the supplied identifier.\nIf a cache already exists, that will be returned instead of the\nproxy.</p>\n"
			},
			{
				"name": "_proxyMethod",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"private": true,
				"parameters": [
					{
						"name": "method",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				]
			},
			{
				"name": "clearCache",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Empties the cache</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "config",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return a deferred that will resolve to the identifier requested.\nWill return cached object if one exists.</p>\n"
			},
			{
				"name": "getConfig",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return the complete config object</p>\n"
			},
			{
				"name": "getIdentifierConfig",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"null"
				],
				"summary": "<p>Return the config object for a particular identifier</p>\n"
			},
			{
				"name": "inject",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "object",
						"types": [
							"object"
						],
						"usage": "required"
					},
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Use inject to inject an object created outside the di\nwith the di config</p>\n"
			},
			{
				"name": "mergeConfig",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "merge",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Merge a config object with the existing config object.</p>\n"
			},
			{
				"name": "proxy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return a Proxy object that will proxy the identifier requested.</p>\n"
			},
			{
				"name": "setConfig",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "config",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "setIdentifierConfig",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Di",
				"parameters": [
					{
						"name": "identifier",
						"types": [
							"string"
						],
						"usage": "required"
					},
					{
						"name": "config",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Set the config object for a particular identifier</p>\n"
			}
		]
	},
	"dojo/_base/declare": {
		"location": "dojo/_base/declare",
		"type": "function",
		"parameters": [
			{
				"name": "className",
				"types": [
					"String"
				],
				"usage": "optional",
				"summary": "<p>The optional name of the constructor (loosely, a &quot;class&quot;)\nstored in the &quot;declaredClass&quot; property in the created prototype.\nIt will be used as a global name for a created constructor.</p>\n"
			},
			{
				"name": "superclass",
				"types": [
					"Function",
					"Function[]"
				],
				"usage": "required",
				"summary": "<p>May be null, a Function, or an Array of Functions. This argument\nspecifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
			},
			{
				"name": "props",
				"types": [
					"Object"
				],
				"usage": "required",
				"summary": "<p>An object whose properties are copied to the created prototype.\nAdd an instance-initialization function by making it a property\nnamed &quot;constructor&quot;.</p>\n"
			}
		],
		"returnTypes": [
			"dojo/_base/declare.__DeclareCreatedObject",
			"undefined"
		],
		"returnDescription": "<p>New constructor function.</p>\n",
		"summary": "<p>Create a feature-rich constructor from compact notation.</p>\n",
		"description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n\n</p>\n<p>Ancestors can be compound classes created by this version of\ndeclare(). In complex cases all base classes are going to be\nlinearized according to C3 MRO algorithm\n(see <a href=\"http://www.python.org/download/releases/2.3/mro/\">http://www.python.org/download/releases/2.3/mro/</a> for more\ndetails).\n\n</p>\n<p>&quot;className&quot; is cached in &quot;declaredClass&quot; property of the new class,\nif it was supplied. The immediate super class will be cached in\n&quot;superclass&quot; property of the new class.\n\n</p>\n<p>Methods in &quot;props&quot; will be copied and modified: &quot;nom&quot; property\n(the declared name of the method) will be added to all copied\nfunctions to help identify them for the internal machinery. Be\nvery careful, while reusing methods: if you use the same\nfunction under different names, it can produce errors in some\ncases.\n\n</p>\n<p>It is possible to use constructors created &quot;manually&quot; (without\ndeclare()) as bases. They will be called as usual during the\ncreation of an instance, their methods will be chained, and even\ncalled by &quot;this.inherited()&quot;.\n\n</p>\n<p>Special property &quot;-chains-&quot; governs how to chain methods. It is\na dictionary, which uses method names as keys, and hint strings\nas values. If a hint string is &quot;after&quot;, this method will be\ncalled after methods of its base classes. If a hint string is\n&quot;before&quot;, this method will be called before methods of its base\nclasses.\n\n</p>\n<p>If &quot;constructor&quot; is not mentioned in &quot;-chains-&quot; property, it will\nbe chained using the legacy mode: using &quot;after&quot; chaining,\ncalling preamble() method before each constructor, if available,\nand calling postscript() after all constructors were executed.\nIf the hint is &quot;after&quot;, it is chained as a regular method, but\npostscript() will be called after the chain of constructors.\n&quot;constructor&quot; cannot be chained &quot;before&quot;, but it allows\na special hint string: &quot;manual&quot;, which means that constructors\nare not going to be chained in any way, and programmer will call\nthem manually using this.inherited(). In the latter case\npostscript() will be called after the construction.\n\n</p>\n<p>All chaining hints are &quot;inherited&quot; from base classes and\npotentially can be overridden. Be very careful when overriding\nhints! Make sure that all chained methods can work in a proposed\nmanner of chaining.\n\n</p>\n<p>Once a method was chained, it is impossible to unchain it. The\nonly exception is &quot;constructor&quot;. You don&#39;t need to define a\nmethod in order to supply a chaining hint.\n\n</p>\n<p>If a method is chained, it cannot use this.inherited() because\nall other methods in the hierarchy will be called automatically.\n\n</p>\n<p>Usually constructors and initializers of any kind are chained\nusing &quot;after&quot; and destructors of any kind are chained as\n&quot;before&quot;. Note that chaining assumes that chained methods do not\nreturn any value: any returned value will be discarded.\n</p>\n",
		"examples": [
			"<pre><code>declare(&quot;my.classes.bar&quot;, my.classes.foo, {\n    // properties to be added to the class prototype\n    someValue: 2,\n    // initialization function\n    constructor: function(){\n        this.myComplicatedObject = new ReallyComplicatedObject();\n    },\n    // other functions\n    someMethod: function(){\n        doStuff();\n    }\n});</code></pre>\n",
			"<pre><code>var MyBase = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass1 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass2 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyDiamond = declare([MyClass1, MyClass2], {\n    // constructor, properties, and methods go here\n    // ...\n});</code></pre>\n",
			"<pre><code>var F = function(){ console.log(&quot;raw constructor&quot;); };\nF.prototype.method = function(){\n    console.log(&quot;raw method&quot;);\n};\nvar A = declare(F, {\n    constructor: function(){\n        console.log(&quot;A.constructor&quot;);\n    },\n    method: function(){\n        console.log(&quot;before calling F.method...&quot;);\n        this.inherited(arguments);\n        console.log(&quot;...back in A&quot;);\n    }\n});\nnew A().method();\n// will print:\n// raw constructor\n// A.constructor\n// before calling F.method...\n// raw method\n// ...back in A</code></pre>\n",
			"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        destroy: &quot;before&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        console.log(&quot;B.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;B.destroy&quot;);\n    }\n});\nvar C = declare(B, {\n    constructor: function(){\n        console.log(&quot;C.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;C.destroy&quot;);\n    }\n});\nnew C().destroy();\n// prints:\n// B.constructor\n// C.constructor\n// C.destroy\n// B.destroy</code></pre>\n",
			"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        constructor: &quot;manual&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        // ...\n        // call the base constructor with new parameters\n        this.inherited(arguments, [1, 2, 3]);\n        // ...\n    }\n});</code></pre>\n",
			"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        m1: &quot;before&quot;\n    },\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    &quot;-chains-&quot;: {\n        m2: &quot;after&quot;\n    },\n    m1: function(){\n        console.log(&quot;B.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\nx.m1();\n// prints:\n// B.m1\n// A.m1\nx.m2();\n// prints:\n// A.m2\n// B.m2</code></pre>\n"
		],
		"properties": [
			{
				"name": "__DeclareCreatedObject",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/declare",
				"private": true,
				"summary": "<p>dojo/_base/declare() returns a constructor <code>C</code>.   <code>new C()</code> returns an Object with the following\nmethods, in addition to the methods and properties specified via the arguments passed to declare().</p>\n"
			}
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "className",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>The optional name of the constructor (loosely, a &quot;class&quot;)\nstored in the &quot;declaredClass&quot; property in the created prototype.\nIt will be used as a global name for a created constructor.</p>\n"
					},
					{
						"name": "superclass",
						"types": [
							"Function",
							"Function[]"
						],
						"usage": "required",
						"summary": "<p>May be null, a Function, or an Array of Functions. This argument\nspecifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object whose properties are copied to the created prototype.\nAdd an instance-initialization function by making it a property\nnamed &quot;constructor&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/_base/declare.__DeclareCreatedObject",
					"undefined"
				],
				"returnDescription": "<p>New constructor function.</p>\n",
				"summary": "<p>Create a feature-rich constructor from compact notation.</p>\n",
				"description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n\n</p>\n<p>Ancestors can be compound classes created by this version of\ndeclare(). In complex cases all base classes are going to be\nlinearized according to C3 MRO algorithm\n(see <a href=\"http://www.python.org/download/releases/2.3/mro/\">http://www.python.org/download/releases/2.3/mro/</a> for more\ndetails).\n\n</p>\n<p>&quot;className&quot; is cached in &quot;declaredClass&quot; property of the new class,\nif it was supplied. The immediate super class will be cached in\n&quot;superclass&quot; property of the new class.\n\n</p>\n<p>Methods in &quot;props&quot; will be copied and modified: &quot;nom&quot; property\n(the declared name of the method) will be added to all copied\nfunctions to help identify them for the internal machinery. Be\nvery careful, while reusing methods: if you use the same\nfunction under different names, it can produce errors in some\ncases.\n\n</p>\n<p>It is possible to use constructors created &quot;manually&quot; (without\ndeclare()) as bases. They will be called as usual during the\ncreation of an instance, their methods will be chained, and even\ncalled by &quot;this.inherited()&quot;.\n\n</p>\n<p>Special property &quot;-chains-&quot; governs how to chain methods. It is\na dictionary, which uses method names as keys, and hint strings\nas values. If a hint string is &quot;after&quot;, this method will be\ncalled after methods of its base classes. If a hint string is\n&quot;before&quot;, this method will be called before methods of its base\nclasses.\n\n</p>\n<p>If &quot;constructor&quot; is not mentioned in &quot;-chains-&quot; property, it will\nbe chained using the legacy mode: using &quot;after&quot; chaining,\ncalling preamble() method before each constructor, if available,\nand calling postscript() after all constructors were executed.\nIf the hint is &quot;after&quot;, it is chained as a regular method, but\npostscript() will be called after the chain of constructors.\n&quot;constructor&quot; cannot be chained &quot;before&quot;, but it allows\na special hint string: &quot;manual&quot;, which means that constructors\nare not going to be chained in any way, and programmer will call\nthem manually using this.inherited(). In the latter case\npostscript() will be called after the construction.\n\n</p>\n<p>All chaining hints are &quot;inherited&quot; from base classes and\npotentially can be overridden. Be very careful when overriding\nhints! Make sure that all chained methods can work in a proposed\nmanner of chaining.\n\n</p>\n<p>Once a method was chained, it is impossible to unchain it. The\nonly exception is &quot;constructor&quot;. You don&#39;t need to define a\nmethod in order to supply a chaining hint.\n\n</p>\n<p>If a method is chained, it cannot use this.inherited() because\nall other methods in the hierarchy will be called automatically.\n\n</p>\n<p>Usually constructors and initializers of any kind are chained\nusing &quot;after&quot; and destructors of any kind are chained as\n&quot;before&quot;. Note that chaining assumes that chained methods do not\nreturn any value: any returned value will be discarded.\n</p>\n",
				"examples": [
					"<pre><code>declare(&quot;my.classes.bar&quot;, my.classes.foo, {\n    // properties to be added to the class prototype\n    someValue: 2,\n    // initialization function\n    constructor: function(){\n        this.myComplicatedObject = new ReallyComplicatedObject();\n    },\n    // other functions\n    someMethod: function(){\n        doStuff();\n    }\n});</code></pre>\n",
					"<pre><code>var MyBase = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass1 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyClass2 = declare(MyBase, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar MyDiamond = declare([MyClass1, MyClass2], {\n    // constructor, properties, and methods go here\n    // ...\n});</code></pre>\n",
					"<pre><code>var F = function(){ console.log(&quot;raw constructor&quot;); };\nF.prototype.method = function(){\n    console.log(&quot;raw method&quot;);\n};\nvar A = declare(F, {\n    constructor: function(){\n        console.log(&quot;A.constructor&quot;);\n    },\n    method: function(){\n        console.log(&quot;before calling F.method...&quot;);\n        this.inherited(arguments);\n        console.log(&quot;...back in A&quot;);\n    }\n});\nnew A().method();\n// will print:\n// raw constructor\n// A.constructor\n// before calling F.method...\n// raw method\n// ...back in A</code></pre>\n",
					"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        destroy: &quot;before&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        console.log(&quot;B.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;B.destroy&quot;);\n    }\n});\nvar C = declare(B, {\n    constructor: function(){\n        console.log(&quot;C.constructor&quot;);\n    },\n    destroy: function(){\n        console.log(&quot;C.destroy&quot;);\n    }\n});\nnew C().destroy();\n// prints:\n// B.constructor\n// C.constructor\n// C.destroy\n// B.destroy</code></pre>\n",
					"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        constructor: &quot;manual&quot;\n    }\n});\nvar B = declare(A, {\n    constructor: function(){\n        // ...\n        // call the base constructor with new parameters\n        this.inherited(arguments, [1, 2, 3]);\n        // ...\n    }\n});</code></pre>\n",
					"<pre><code>var A = declare(null, {\n    &quot;-chains-&quot;: {\n        m1: &quot;before&quot;\n    },\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    &quot;-chains-&quot;: {\n        m2: &quot;after&quot;\n    },\n    m1: function(){\n        console.log(&quot;B.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\nx.m1();\n// prints:\n// B.m1\n// A.m1\nx.m2();\n// prints:\n// A.m2\n// B.m2</code></pre>\n"
				]
			},
			{
				"name": "safeMixin",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "target",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Target object to accept new properties.</p>\n"
					},
					{
						"name": "source",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Source object for new properties.</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>Target object to accept new properties.</p>\n",
				"summary": "<p>Mix in properties skipping a constructor and decorating functions\nlike it is done by declare().</p>\n",
				"description": "<p>This function is used to mix in properties like lang.mixin does,\nbut it skips a constructor property and decorates functions like\ndeclare() does.\n\n</p>\n<p>It is meant to be used with classes and objects produced with\ndeclare. Functions mixed in with dojo.safeMixin can use\nthis.inherited() like normal methods.\n\n</p>\n<p>This function is used to implement extend() method of a constructor\nproduced with declare().\n</p>\n",
				"examples": [
					"<pre><code>var A = declare(null, {\n    m1: function(){\n        console.log(&quot;A.m1&quot;);\n    },\n    m2: function(){\n        console.log(&quot;A.m2&quot;);\n    }\n});\nvar B = declare(A, {\n    m1: function(){\n        this.inherited(arguments);\n        console.log(&quot;B.m1&quot;);\n    }\n});\nB.extend({\n    m2: function(){\n        this.inherited(arguments);\n        console.log(&quot;B.m2&quot;);\n    }\n});\nvar x = new B();\ndojo.safeMixin(x, {\n    m1: function(){\n        this.inherited(arguments);\n        console.log(&quot;X.m1&quot;);\n    },\n    m2: function(){\n        this.inherited(arguments);\n        console.log(&quot;X.m2&quot;);\n    }\n});\nx.m2();\n// prints:\n// A.m1\n// B.m1\n// X.m1</code></pre>\n"
				]
			}
		]
	},
	"dojo/_base/declare.__DeclareCreatedObject": {
		"location": "dojo/_base/declare.__DeclareCreatedObject",
		"type": "object",
		"summary": "<p>dojo/_base/declare() returns a constructor <code>C</code>.   <code>new C()</code> returns an Object with the following\nmethods, in addition to the methods and properties specified via the arguments passed to declare().</p>\n",
		"methods": [
			{
				"name": "createSubclass",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "mixins",
						"types": [
							"Function[]"
						],
						"usage": "required",
						"summary": "<p>Specifies a list of bases (the left-most one is the most deepest\nbase).</p>\n"
					},
					{
						"name": "props",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An optional object whose properties are copied to the created prototype.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/_base/declare.__DeclareCreatedObject"
				],
				"returnDescription": "<p>New constructor function.</p>\n",
				"summary": "<p>Create a subclass of the declared class from a list of base classes.</p>\n",
				"description": "<p>Create a constructor using a compact notation for inheritance and\nprototype extension.\n\n</p>\n<p>Mixin ancestors provide a type of multiple inheritance.\nPrototypes of mixin ancestors are copied to the new class:\nchanges to mixin prototypes will not affect classes to which\nthey have been mixed in.\n</p>\n",
				"examples": [
					"<pre><code>var A = declare(null, {\n    m1: function(){},\n    s1: &quot;bar&quot;\n});\nvar B = declare(null, {\n    m2: function(){},\n    s2: &quot;foo&quot;\n});\nvar C = declare(null, {\n});\nvar D1 = A.createSubclass([B, C], {\n    m1: function(){},\n    d1: 42\n});\nvar d1 = new D1();\n\n// this is equivalent to:\nvar D2 = declare([A, B, C], {\n    m1: function(){},\n    d1: 42\n});\nvar d2 = new D2();</code></pre>\n"
				]
			},
			{
				"name": "extend",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "source",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>Source object which properties are going to be copied to the\nconstructor&#39;s prototype.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Adds all properties and methods of source to constructor&#39;s\nprototype, making them available to all instances created with\nconstructor. This method is specific to constructors created with\ndeclare().</p>\n",
				"description": "<p>Adds source properties to the constructor&#39;s prototype. It can\noverride existing properties.\n\n</p>\n<p>This method is similar to dojo.extend function, but it is specific\nto constructors produced by declare(). It is implemented\nusing dojo.safeMixin, and it skips a constructor property,\nand properly decorates copied functions.\n</p>\n",
				"examples": [
					"<pre><code>var A = declare(null, {\n    m1: function(){},\n    s1: &quot;Popokatepetl&quot;\n});\nA.extend({\n    m1: function(){},\n    m2: function(){},\n    f1: true,\n    d1: 42\n});</code></pre>\n"
				]
			},
			{
				"name": "getInherited",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>The optional method name. Should be the same as the caller&#39;s\nname. Usually &quot;name&quot; is specified in complex dynamic cases, when\nthe calling method was dynamically added, undecorated by\ndeclare(), and it cannot be determined.</p>\n"
					},
					{
						"name": "args",
						"types": [
							"Arguments"
						],
						"usage": "required",
						"summary": "<p>The caller supply this argument, which should be the original\n&quot;arguments&quot;.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>Returns a super method (Function) or &quot;undefined&quot;.</p>\n",
				"summary": "<p>Returns a super method.</p>\n",
				"description": "<p>This method is a convenience method for &quot;this.inherited()&quot;.\nIt uses the same algorithm but instead of executing a super\nmethod, it returns it, or &quot;undefined&quot; if not found.\n</p>\n",
				"examples": [
					"<pre><code>var B = declare(A, {\n    method: function(a, b){\n        var super = this.getInherited(arguments);\n        // ...\n        if(!super){\n            console.log(&quot;there is no super method&quot;);\n            return 0;\n        }\n        return super.apply(this, arguments);\n    }\n});</code></pre>\n"
				]
			},
			{
				"name": "inherited",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>The optional method name. Should be the same as the caller&#39;s\nname. Usually &quot;name&quot; is specified in complex dynamic cases, when\nthe calling method was dynamically added, undecorated by\ndeclare(), and it cannot be determined.</p>\n"
					},
					{
						"name": "args",
						"types": [
							"Arguments"
						],
						"usage": "required",
						"summary": "<p>The caller supply this argument, which should be the original\n&quot;arguments&quot;.</p>\n"
					},
					{
						"name": "newArgs",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>If &quot;true&quot;, the found function will be returned without\nexecuting it.\nIf Array, it will be used to call a super method. Otherwise\n&quot;args&quot; will be used.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>Whatever is returned by a super method, or a super method itself,\nif &quot;true&quot; was specified as newArgs.</p>\n",
				"summary": "<p>Calls a super method.</p>\n",
				"description": "<p>This method is used inside method of classes produced with\ndeclare() to call a super method (next in the chain). It is\nused for manually controlled chaining. Consider using the regular\nchaining, because it is faster. Use &quot;this.inherited()&quot; only in\ncomplex cases.\n\n</p>\n<p>This method cannot me called from automatically chained\nconstructors including the case of a special (legacy)\nconstructor chaining. It cannot be called from chained methods.\n\n</p>\n<p>If &quot;this.inherited()&quot; cannot find the next-in-chain method, it\ndoes nothing and returns &quot;undefined&quot;. The last method in chain\ncan be a default method implemented in Object, which will be\ncalled last.\n\n</p>\n<p>If &quot;name&quot; is specified, it is assumed that the method that\nreceived &quot;args&quot; is the parent method for this call. It is looked\nup in the chain list and if it is found the next-in-chain method\nis called. If it is not found, the first-in-chain method is\ncalled.\n\n</p>\n<p>If &quot;name&quot; is not specified, it will be derived from the calling\nmethod (using a methoid property &quot;nom&quot;).\n</p>\n",
				"examples": [
					"<pre><code>var B = declare(A, {\n    method1: function(a, b, c){\n        this.inherited(arguments);\n    },\n    method2: function(a, b){\n        return this.inherited(arguments, [a + b]);\n    }\n});\n// next method is not in the chain list because it is added\n// manually after the class was created.\nB.prototype.method3 = function(){\n    console.log(&quot;This is a dynamically-added method.&quot;);\n    this.inherited(&quot;method3&quot;, arguments);\n};</code></pre>\n",
					"<pre><code>var B = declare(A, {\n    method: function(a, b){\n        var super = this.inherited(arguments, true);\n        // ...\n        if(!super){\n            console.log(&quot;there is no super method&quot;);\n            return 0;\n        }\n        return super.apply(this, arguments);\n    }\n});</code></pre>\n"
				]
			},
			{
				"name": "isInstanceOf",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/declare",
				"parameters": [
					{
						"name": "cls",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Class constructor.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>&quot;true&quot;, if this object is inherited from this class, &quot;false&quot;\notherwise.</p>\n",
				"summary": "<p>Checks the inheritance chain to see if it is inherited from this\nclass.</p>\n",
				"description": "<p>This method is used with instances of classes produced with\ndeclare() to determine of they support a certain interface or\nnot. It models &quot;instanceof&quot; operator.\n</p>\n",
				"examples": [
					"<pre><code>var A = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar B = declare(null, {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar C = declare([A, B], {\n    // constructor, properties, and methods go here\n    // ...\n});\nvar D = declare(A, {\n    // constructor, properties, and methods go here\n    // ...\n});\n\nvar a = new A(), b = new B(), c = new C(), d = new D();\n\nconsole.log(a.isInstanceOf(A)); // true\nconsole.log(b.isInstanceOf(A)); // false\nconsole.log(c.isInstanceOf(A)); // true\nconsole.log(d.isInstanceOf(A)); // true\n\nconsole.log(a.isInstanceOf(B)); // false\nconsole.log(b.isInstanceOf(B)); // true\nconsole.log(c.isInstanceOf(B)); // true\nconsole.log(d.isInstanceOf(B)); // false\n\nconsole.log(a.isInstanceOf(C)); // false\nconsole.log(b.isInstanceOf(C)); // false\nconsole.log(c.isInstanceOf(C)); // true\nconsole.log(d.isInstanceOf(C)); // false\n\nconsole.log(a.isInstanceOf(D)); // false\nconsole.log(b.isInstanceOf(D)); // false\nconsole.log(c.isInstanceOf(D)); // false\nconsole.log(d.isInstanceOf(D)); // true</code></pre>\n"
				]
			}
		]
	},
	"havok/di/Proxy": {
		"location": "havok/di/Proxy",
		"type": "constructor",
		"classlike": true,
		"parameters": [
			{
				"name": "identity",
				"types": [
					"undefined"
				],
				"usage": "required"
			},
			{
				"name": "di",
				"types": [
					"undefined"
				],
				"usage": "required"
			}
		],
		"returnTypes": [],
		"summary": "<p>A proxy to get or use an object.</p>\n",
		"properties": [
			{
				"name": "_di",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/di/Proxy",
				"private": true
			},
			{
				"name": "_identity",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/di/Proxy",
				"private": true
			}
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Proxy",
				"parameters": [
					{
						"name": "identity",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "di",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "diGet",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/di/Proxy",
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"havok/di/main": {
		"location": "havok/di/main",
		"type": "undefined"
	},
	"havok/get": {
		"location": "havok/get",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/get",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/di/sharedDi": {
		"location": "havok/di/sharedDi",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/di/sharedDi",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/proxy": {
		"location": "havok/proxy",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/proxy",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/exception/Application": {
		"location": "havok/exception/Application",
		"type": "undefined"
	},
	"havok/exception/Handler": {
		"location": "havok/exception/Handler",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/Stateful",
		"mixins": [
			"dojo/Stateful"
		],
		"summary": "<p>Module providing exception display and logging</p>\n",
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_exceptionSetter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/Handler",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "handle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/Handler",
				"parameters": [
					{
						"name": "exception",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				]
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/Handler",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"dojo/Stateful": {
		"location": "dojo/Stateful",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Base class for objects that provide named properties with optional getter/setter\ncontrol and the ability to watch for property changes\n\n</p>\n<p>The class also provides the functionality to auto-magically manage getters\nand setters for object attributes/properties.\n\n</p>\n<p>Getters and Setters should follow the format of _xxxGetter or _xxxSetter where \nthe xxx is a name of the attribute to handle.  So an attribute of &quot;foo&quot; \nwould have a custom getter of _fooGetter and a custom setter of _fooSetter.\n</p>\n",
		"examples": [
			"<pre><code>var obj = new dojo.Stateful();\nobj.watch(&quot;foo&quot;, function(){\n    console.log(&quot;foo changed to &quot; + this.get(&quot;foo&quot;));\n});\nobj.set(&quot;foo&quot;,&quot;bar&quot;);</code></pre>\n"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/exception/config": {
		"location": "havok/exception/config",
		"type": "object",
		"properties": [
			{
				"name": "di",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/exception/config"
			}
		]
	},
	"havok/exception/config.di": {
		"location": "havok/exception/config.di",
		"type": "object",
		"properties": [
			{
				"name": "havok/exception/Handler",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/exception/config"
			}
		]
	},
	"havok/exception/main": {
		"location": "havok/exception/main",
		"type": "undefined"
	},
	"havok/exception/started": {
		"location": "havok/exception/started",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/exception/started",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/exception/renderer/Console": {
		"location": "havok/exception/renderer/Console",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "minSeverity",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/exception/renderer/Console"
			}
		],
		"methods": [
			{
				"name": "render",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/renderer/Console",
				"parameters": [
					{
						"name": "exceptionModel",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/exception/renderer/Store": {
		"location": "havok/exception/renderer/Store",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "minSeverity",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/exception/renderer/Store"
			}
		],
		"methods": [
			{
				"name": "getStore",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/renderer/Store",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "render",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/renderer/Store",
				"parameters": [
					{
						"name": "exceptionModel",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dojo/store/Memory": {
		"location": "dojo/store/Memory",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/store/api/Store",
		"mixins": [
			"dojo/store/api/Store"
		],
		"parameters": [
			{
				"name": "options",
				"types": [
					"dojo/store/Memory"
				],
				"usage": "required",
				"summary": "<p>This provides any configuration information that will be mixed into the store.\nThis should generally include the data property to provide the starting set of data.</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>This is a basic in-memory object store. It implements dojo/store/api/Store.</p>\n",
		"properties": [
			{
				"name": "data",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "dojo/store/Memory",
				"summary": "<p>The array of all the objects in the memory store</p>\n"
			},
			{
				"name": "idProperty",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/Memory",
				"summary": "<p>Indicates the property to use as the identity property. The values of this\nproperty should be unique.</p>\n"
			},
			{
				"name": "index",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/store/Memory",
				"summary": "<p>An index of data indices into the data array by id</p>\n"
			}
		],
		"methods": [
			{
				"name": "add",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.PutDirectives"
						],
						"usage": "optional",
						"summary": "<p>Additional metadata for storing the data.  Includes an &quot;id&quot;\nproperty if a specific id is to be used.</p>\n"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Creates an object, throws an error if the object already exists</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "options",
						"types": [
							"dojo/store/Memory"
						],
						"usage": "required",
						"summary": "<p>This provides any configuration information that will be mixed into the store.\nThis should generally include the data property to provide the starting set of data.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Creates a memory object store.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to lookup the object</p>\n"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"returnDescription": "<p>The object in the store that matches the given id.</p>\n",
				"summary": "<p>Retrieves an object by its identity</p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "parent",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to find the children of.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>Additional options to apply to the retrieval of the children.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"returnDescription": "<p>A result set of the children of the parent object.</p>\n",
				"summary": "<p>Retrieves the children of an object.</p>\n"
			},
			{
				"name": "getIdentity",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to get the identity from</p>\n"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Returns an object&#39;s identity</p>\n"
			},
			{
				"name": "getMetadata",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to return metadata for.</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>An object containing metadata.</p>\n",
				"summary": "<p>Returns any metadata about the object. This may include attribution,\ncache directives, history, or version information.</p>\n"
			},
			{
				"name": "put",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.PutDirectives"
						],
						"usage": "optional",
						"summary": "<p>Additional metadata for storing the data.  Includes an &quot;id&quot;\nproperty if a specific id is to be used.</p>\n"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Stores an object</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "query",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The query to use for retrieving objects from the store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>The optional arguments to apply to the resultset.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults",
					"undefined"
				],
				"returnDescription": "<p>The results of the query, extended with iterative methods.\n</p>\n",
				"summary": "<p>Queries the store for objects.</p>\n",
				"examples": [
					"<p>Given the following store:\n\n\n</p>\n<pre><code>var store = new Memory({\n    data: [\n        {id: 1, name: &quot;one&quot;, prime: false },\n        {id: 2, name: &quot;two&quot;, even: true, prime: true},\n        {id: 3, name: &quot;three&quot;, prime: true},\n        {id: 4, name: &quot;four&quot;, even: true, prime: false},\n        {id: 5, name: &quot;five&quot;, prime: true}\n    ]\n});</code></pre>\n<p>...find all items where &quot;prime&quot; is true:\n\n\n</p>\n<pre><code>var results = store.query({ prime: true });</code></pre>\n<p>...or find all items where &quot;even&quot; is true:\n\n\n</p>\n<pre><code>var results = store.query({ even: true });</code></pre>\n"
				]
			},
			{
				"name": "queryEngine",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "query",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object hash with fields that may match fields of items in the store.\nValues in the hash will be compared by normal == operator, but regular expressions\nor any object that provides a test() method are also supported and can be\nused to match strings by more complex expressions\n(and then the regex&#39;s or object&#39;s test() method will be used to match values).\n</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>An object that contains optional information such as sort, start, and count.\n</p>\n"
					}
				],
				"returnTypes": [
					"Function",
					"function"
				],
				"returnDescription": "<p>A function that caches the passed query under the field &quot;matches&quot;.  See any\nof the &quot;query&quot; methods on dojo.stores.\n</p>\n",
				"summary": "<p>Defines the query engine to use for querying the data store</p>\n"
			},
			{
				"name": "remove",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to delete the object</p>\n"
					}
				],
				"returnTypes": [
					"Boolean",
					"boolean"
				],
				"returnDescription": "<p>Returns true if an object was removed, falsy (undefined) if no object matched the id</p>\n",
				"summary": "<p>Deletes an object by its identity</p>\n"
			},
			{
				"name": "setData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/Memory",
				"parameters": [
					{
						"name": "data",
						"types": [
							"Object[]"
						],
						"usage": "required",
						"summary": "<p>An array of objects to use as the source of data.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the given data as the source for this store, and indexes it</p>\n"
			},
			{
				"name": "transaction",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": [
					"dojo/store/api/Store.Transaction"
				],
				"returnDescription": "<p>This represents the new current transaction.</p>\n",
				"summary": "<p>Starts a new transaction.\nNote that a store user might not call transaction() prior to using put,\ndelete, etc. in which case these operations effectively could be thought of\nas &quot;auto-commit&quot; style actions.</p>\n"
			}
		]
	},
	"dojo/store/util/QueryResults": {
		"location": "dojo/store/util/QueryResults",
		"type": "function",
		"parameters": [
			{
				"name": "results",
				"types": [
					"Array",
					"dojo/promise/Promise"
				],
				"usage": "required",
				"summary": "<p>The result set as an array, or a promise for an array.</p>\n"
			}
		],
		"returnTypes": [
			"any",
			"Array|dojo/promise/Promise",
			"undefined"
		],
		"returnDescription": "<p>An array-like object that can be used for iterating over.</p>\n",
		"summary": "<p>A function that wraps the results of a store query with additional\nmethods.</p>\n",
		"description": "<p>QueryResults is a basic wrapper that allows for array-like iteration\nover any kind of returned data from a query.  While the simplest store\nwill return a plain array of data, other stores may return deferreds or\npromises; this wrapper makes sure that <em>all</em> results can be treated\nthe same.\n\n</p>\n<p>Additional methods include <code>forEach</code>, <code>filter</code> and <code>map</code>.</p>\n",
		"examples": [
			"<p>Query a store and iterate over the results.\n\n\n</p>\n<pre><code>store.query({ prime: true }).forEach(function(item){\n    //  do something\n});</code></pre>\n"
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/util/QueryResults",
				"parameters": [
					{
						"name": "results",
						"types": [
							"Array",
							"dojo/promise/Promise"
						],
						"usage": "required",
						"summary": "<p>The result set as an array, or a promise for an array.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"Array|dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>An array-like object that can be used for iterating over.</p>\n",
				"summary": "<p>A function that wraps the results of a store query with additional\nmethods.</p>\n",
				"description": "<p>QueryResults is a basic wrapper that allows for array-like iteration\nover any kind of returned data from a query.  While the simplest store\nwill return a plain array of data, other stores may return deferreds or\npromises; this wrapper makes sure that <em>all</em> results can be treated\nthe same.\n\n</p>\n<p>Additional methods include <code>forEach</code>, <code>filter</code> and <code>map</code>.</p>\n",
				"examples": [
					"<p>Query a store and iterate over the results.\n\n\n</p>\n<pre><code>store.query({ prime: true }).forEach(function(item){\n    //  do something\n});</code></pre>\n"
				]
			}
		]
	},
	"dojo/store/util/SimpleQueryEngine": {
		"location": "dojo/store/util/SimpleQueryEngine",
		"type": "function",
		"parameters": [
			{
				"name": "query",
				"types": [
					"Object"
				],
				"usage": "required",
				"summary": "<p>An object hash with fields that may match fields of items in the store.\nValues in the hash will be compared by normal == operator, but regular expressions\nor any object that provides a test() method are also supported and can be\nused to match strings by more complex expressions\n(and then the regex&#39;s or object&#39;s test() method will be used to match values).\n</p>\n"
			},
			{
				"name": "options",
				"types": [
					"dojo/store/api/Store.QueryOptions"
				],
				"usage": "optional",
				"summary": "<p>An object that contains optional information such as sort, start, and count.\n</p>\n"
			}
		],
		"returnTypes": [
			"Function",
			"function"
		],
		"returnDescription": "<p>A function that caches the passed query under the field &quot;matches&quot;.  See any\nof the &quot;query&quot; methods on dojo.stores.\n</p>\n",
		"summary": "<p>Simple query engine that matches using filter functions, named filter\nfunctions or objects by name-value on a query object hash\n</p>\n",
		"description": "<p>The SimpleQueryEngine provides a way of getting a QueryResults through\nthe use of a simple object hash as a filter.  The hash will be used to\nmatch properties on data objects with the corresponding value given. In\nother words, only exact matches will be returned.\n\n</p>\n<p>This function can be used as a template for more complex query engines;\nfor example, an engine can be created that accepts an object hash that\ncontains filtering functions, or a string that gets evaluated, etc.\n\n</p>\n<p>When creating a new dojo.store, simply set the store&#39;s queryEngine\nfield as a reference to this function.\n</p>\n",
		"examples": [
			"<p>Define a store with a reference to this engine, and set up a query method.\n\n\n</p>\n<pre><code>var myStore = function(options){\n    //  ...more properties here\n    this.queryEngine = SimpleQueryEngine;\n    //  define our query method\n    this.query = function(query, options){\n        return QueryResults(this.queryEngine(query, options)(this.data));\n    };\n};</code></pre>\n"
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/util/SimpleQueryEngine",
				"parameters": [
					{
						"name": "query",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object hash with fields that may match fields of items in the store.\nValues in the hash will be compared by normal == operator, but regular expressions\nor any object that provides a test() method are also supported and can be\nused to match strings by more complex expressions\n(and then the regex&#39;s or object&#39;s test() method will be used to match values).\n</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>An object that contains optional information such as sort, start, and count.\n</p>\n"
					}
				],
				"returnTypes": [
					"Function",
					"function"
				],
				"returnDescription": "<p>A function that caches the passed query under the field &quot;matches&quot;.  See any\nof the &quot;query&quot; methods on dojo.stores.\n</p>\n",
				"summary": "<p>Simple query engine that matches using filter functions, named filter\nfunctions or objects by name-value on a query object hash\n</p>\n",
				"description": "<p>The SimpleQueryEngine provides a way of getting a QueryResults through\nthe use of a simple object hash as a filter.  The hash will be used to\nmatch properties on data objects with the corresponding value given. In\nother words, only exact matches will be returned.\n\n</p>\n<p>This function can be used as a template for more complex query engines;\nfor example, an engine can be created that accepts an object hash that\ncontains filtering functions, or a string that gets evaluated, etc.\n\n</p>\n<p>When creating a new dojo.store, simply set the store&#39;s queryEngine\nfield as a reference to this function.\n</p>\n",
				"examples": [
					"<p>Define a store with a reference to this engine, and set up a query method.\n\n\n</p>\n<pre><code>var myStore = function(options){\n    //  ...more properties here\n    this.queryEngine = SimpleQueryEngine;\n    //  define our query method\n    this.query = function(query, options){\n        return QueryResults(this.queryEngine(query, options)(this.data));\n    };\n};</code></pre>\n"
				]
			}
		]
	},
	"dojo/store/api/Store": {
		"location": "dojo/store/api/Store",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>This is an abstract API that data provider implementations conform to.\nThis file defines methods signatures and intentionally leaves all the\nmethods unimplemented.  For more information on the ,\nplease visit: <a href=\"http://dojotoolkit.org/reference-guide/dojo/store.html\">http://dojotoolkit.org/reference-guide/dojo/store.html</a>\nEvery method and property is optional, and is only needed if the functionality\nit provides is required.\nEvery method may return a promise for the specified return value if the\nexecution of the operation is asynchronous (except\nfor query() which already defines an async return value).</p>\n",
		"properties": [
			{
				"name": "idProperty",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If the store has a single primary key, this indicates the property to use as the\nidentity property. The values of this property should be unique.</p>\n"
			},
			{
				"name": "queryEngine",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If the store can be queried locally (on the client side in JS), this defines\nthe query engine to use for querying the data store.\nThis takes a query and query options and returns a function that can execute\nthe provided query on a JavaScript array. The queryEngine may be replace to\nprovide more sophisticated querying capabilities. For example:\n\n</p>\n<pre><code>var query = store.queryEngine({foo:&quot;bar&quot;}, {count:10});\nquery(someArray) -&gt; filtered array</code></pre>\n<p>The returned query function may have a &quot;matches&quot; property that can be\n\n</p>\n<p>used to determine if an object matches the query. For example:\n\n</p>\n<pre><code>query.matches({id:&quot;some-object&quot;, foo:&quot;bar&quot;}) -&gt; true\nquery.matches({id:&quot;some-object&quot;, foo:&quot;something else&quot;}) -&gt; false</code></pre>\n"
			}
		],
		"methods": [
			{
				"name": "add",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "directives",
						"types": [
							"dojo/store/api/Store.PutDirectives"
						],
						"usage": "optional",
						"summary": "<p>Additional directives for creating objects.</p>\n"
					}
				],
				"returnTypes": [
					"Number|String"
				],
				"summary": "<p>Creates an object, throws an error if the object already exists</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to lookup the object</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>The object in the store that matches the given id.</p>\n",
				"summary": "<p>Retrieves an object by its identity</p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "parent",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to find the children of.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>Additional options to apply to the retrieval of the children.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"returnDescription": "<p>A result set of the children of the parent object.</p>\n",
				"summary": "<p>Retrieves the children of an object.</p>\n"
			},
			{
				"name": "getIdentity",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to get the identity from</p>\n"
					}
				],
				"returnTypes": [
					"String|Number"
				],
				"summary": "<p>Returns an object&#39;s identity</p>\n"
			},
			{
				"name": "getMetadata",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to return metadata for.</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>An object containing metadata.</p>\n",
				"summary": "<p>Returns any metadata about the object. This may include attribution,\ncache directives, history, or version information.</p>\n"
			},
			{
				"name": "put",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "directives",
						"types": [
							"dojo/store/api/Store.PutDirectives"
						],
						"usage": "optional",
						"summary": "<p>Additional directives for storing objects.</p>\n"
					}
				],
				"returnTypes": [
					"Number|String"
				],
				"summary": "<p>Stores an object</p>\n"
			},
			{
				"name": "PutDirectives",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "query",
						"types": [
							"String",
							"Object",
							"Function"
						],
						"usage": "required",
						"summary": "<p>The query to use for retrieving objects from the store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "required",
						"summary": "<p>The optional arguments to apply to the resultset.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"returnDescription": "<p>The results of the query, extended with iterative methods.\n</p>\n",
				"summary": "<p>Queries the store for objects. This does not alter the store, but returns a\nset of data from the store.</p>\n",
				"examples": [
					"<p>Given the following store:\n\n</p>\n<p>...find all items where &quot;prime&quot; is true:\n\n\n</p>\n<pre><code>store.query({ prime: true }).forEach(function(object){\n    // handle each object\n});</code></pre>\n"
				]
			},
			{
				"name": "QueryOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "QueryResults",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "remove",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to delete the object</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deletes an object by its identity</p>\n"
			},
			{
				"name": "SortInformation",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "transaction",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": [
					"dojo/store/api/Store.Transaction"
				],
				"returnDescription": "<p>This represents the new current transaction.</p>\n",
				"summary": "<p>Starts a new transaction.\nNote that a store user might not call transaction() prior to using put,\ndelete, etc. in which case these operations effectively could be thought of\nas &quot;auto-commit&quot; style actions.</p>\n"
			},
			{
				"name": "Transaction",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/store/api/Store.PutDirectives": {
		"location": "dojo/store/api/Store.PutDirectives",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Directives passed to put() and add() handlers for guiding the update and\ncreation of stored objects.</p>\n",
		"properties": [
			{
				"name": "before",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String",
					"Number"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>Indicates the identity of the object if a new object is created</p>\n"
			},
			{
				"name": "overwrite",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n"
			},
			{
				"name": "parent",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n"
			}
		]
	},
	"dojo/store/api/Store.SortInformation": {
		"location": "dojo/store/api/Store.SortInformation",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>An object describing what attribute to sort on, and the direction of the sort.</p>\n",
		"properties": [
			{
				"name": "attribute",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>The name of the attribute to sort on.</p>\n"
			},
			{
				"name": "descending",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>The direction of the sort.  Default is false.</p>\n"
			}
		]
	},
	"dojo/store/api/Store.QueryOptions": {
		"location": "dojo/store/api/Store.QueryOptions",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Optional object with additional parameters for query results.</p>\n",
		"properties": [
			{
				"name": "count",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>The number of how many results should be returned.</p>\n"
			},
			{
				"name": "sort",
				"scope": "prototype",
				"types": [
					"dojo/store/api/Store.SortInformation[]"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n"
			},
			{
				"name": "start",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>The first result to begin iteration on</p>\n"
			}
		]
	},
	"dojo/store/api/Store.QueryResults": {
		"location": "dojo/store/api/Store.QueryResults",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>This is an object returned from query() calls that provides access to the results\nof a query. Queries may be executed asynchronously.</p>\n",
		"properties": [
			{
				"name": "total",
				"scope": "prototype",
				"types": [
					"Number",
					"Promise?"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>This property should be included in if the query options included the &quot;count&quot;\nproperty limiting the result set. This property indicates the total number of objects\nmatching the query (as if &quot;start&quot; and &quot;count&quot; weren&#39;t present). This may be\na promise if the query is asynchronous.</p>\n"
			}
		],
		"methods": [
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Function that is called for each object in the query results</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The object to use as |this| in the callback.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"summary": "<p>Filters the query results, based on\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</a>.\nNote that this may executed asynchronously. The callback may be called\nafter this function returns.</p>\n"
			},
			{
				"name": "forEach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Function that is called for each object in the query results</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The object to use as |this| in the callback.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterates over the query results, based on\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</a>.\nNote that this may executed asynchronously. The callback may be called\nafter this function returns.</p>\n"
			},
			{
				"name": "map",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Function that is called for each object in the query results</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The object to use as |this| in the callback.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"summary": "<p>Maps the query results, based on\n<a href=\"https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\">https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</a>.\nNote that this may executed asynchronously. The callback may be called\nafter this function returns.</p>\n"
			},
			{
				"name": "observe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The listener function is called when objects in the query results are modified\nto affect the query result. The listener function is called with the following arguments:\n\n</p>\n<pre><code>listener(object, removedFrom, insertedInto);</code></pre>\n<ul>\n<li>The object parameter indicates the object that was create, modified, or deleted.</li>\n<li>The removedFrom parameter indicates the index in the result array where\nthe object used to be. If the value is -1, then the object is an addition to\nthis result set (due to a new object being created, or changed such that it\nis a part of the result set).</li>\n<li>The insertedInto parameter indicates the index in the result array where\nthe object should be now. If the value is -1, then the object is a removal\nfrom this result set (due to an object being deleted, or changed such that it\nis not a part of the result set).</li>\n</ul>\n"
					},
					{
						"name": "includeAllUpdates",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>This indicates whether or not to include object updates that do not affect\nthe inclusion or order of the object in the query results. By default this is false,\nwhich means that if any object is updated in such a way that it remains\nin the result set and it&#39;s position in result sets is not affected, then the listener\nwill not be fired.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This registers a callback for notification of when data is modified in the query results.\nThis is an optional method, and is usually provided by dojo/store/Observable.</p>\n"
			},
			{
				"name": "then",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>This is called when the query is completed successfully, and is passed a single argument\nthat is an array representing the query results.</p>\n"
					},
					{
						"name": "errorHandler",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>This is called if the query failed, and is passed a single argument that is the error\nfor the failure.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This registers a callback for when the query is complete, if the query is asynchronous.\nThis is an optional method, and may not be present for synchronous queries.</p>\n"
			}
		]
	},
	"dojo/store/api/Store.Transaction": {
		"location": "dojo/store/api/Store.Transaction",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>This is an object returned from transaction() calls that represents the current\ntransaction.</p>\n",
		"methods": [
			{
				"name": "abort",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Aborts the transaction. This may throw an error if it fails. Of if the operation\nis asynchronous, it may return a promise that represents the eventual success\nor failure of the abort.</p>\n"
			},
			{
				"name": "commit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Commits the transaction. This may throw an error if it fails. Of if the operation\nis asynchronous, it may return a promise that represents the eventual success\nor failure of the commit.</p>\n"
			}
		]
	},
	"havok/exception/renderer/UI": {
		"location": "havok/exception/renderer/UI",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "minSeverity",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/exception/renderer/UI"
			}
		],
		"methods": [
			{
				"name": "render",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/exception/renderer/UI",
				"parameters": [
					{
						"name": "exceptionModel",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dojo/dom-construct": {
		"location": "dojo/dom-construct",
		"type": "object",
		"methods": [
			{
				"name": "create",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-construct",
				"parameters": [
					{
						"name": "tag",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>A string of the element to create (eg: &quot;div&quot;, &quot;a&quot;, &quot;p&quot;, &quot;li&quot;, &quot;script&quot;, &quot;br&quot;),\nor an existing DOM node to process.</p>\n"
					},
					{
						"name": "attrs",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object-hash of attributes to set on the newly created node.\nCan be null, if you don&#39;t want to set any attributes/styles.\nSee: <code>dojo.setAttr</code> for a description of available attributes.</p>\n"
					},
					{
						"name": "refNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>Optional reference node. Used by <code>dojo.place</code> to place the newly created\nnode somewhere in the dom relative to refNode. Can be a DomNode reference\nor String ID of a node.</p>\n"
					},
					{
						"name": "pos",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Optional positional reference. Defaults to &quot;last&quot; by way of <code>dojo.place</code>,\nthough can be set to &quot;first&quot;,&quot;after&quot;,&quot;before&quot;,&quot;last&quot;, &quot;replace&quot; or &quot;only&quot;\nto further control the placement of the new node relative to the refNode.\n&#39;refNode&#39; is required if a &#39;pos&#39; is specified.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Create an element, allowing for optional attribute decoration\nand placement.</p>\n",
				"description": "<p>A DOM Element creation function. A shorthand method for creating a node or\na fragment, and allowing for a convenient optional attribute setting step,\nas well as an optional DOM placement reference.\n\n</p>\n<p>Attributes are set by passing the optional object through <code>dojo.setAttr</code>.\nSee <code>dojo.setAttr</code> for noted caveats and nuances, and API if applicable.\n\n</p>\n<p>Placement is done via <code>dojo.place</code>, assuming the new node to be the action\nnode, passing along the optional reference node and position.</p>\n",
				"examples": [
					"<p>Create a DIV:\n\n</p>\n<pre><code>var n = dojo.create(&quot;div&quot;);</code></pre>\n",
					"<p>Create a DIV with content:\n\n</p>\n<pre><code>var n = dojo.create(&quot;div&quot;, { innerHTML:&quot;&lt;p&gt;hi&lt;/p&gt;&quot; });</code></pre>\n",
					"<p>Place a new DIV in the BODY, with no attributes set\n\n</p>\n<pre><code>var n = dojo.create(&quot;div&quot;, null, dojo.body());</code></pre>\n",
					"<p>Create an UL, and populate it with LI&#39;s. Place the list as the first-child of a\nnode with id=&quot;someId&quot;:\n\n</p>\n<pre><code>var ul = dojo.create(&quot;ul&quot;, null, &quot;someId&quot;, &quot;first&quot;);\nvar items = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];\ndojo.forEach(items, function(data){\n    dojo.create(&quot;li&quot;, { innerHTML: data }, ul);\n});</code></pre>\n",
					"<p>Create an anchor, with an href. Place in BODY:\n\n</p>\n<pre><code>dojo.create(&quot;a&quot;, { href:&quot;foo.html&quot;, title:&quot;Goto FOO!&quot; }, dojo.body());</code></pre>\n",
					"<p>Create a <code>dojo/NodeList()</code> from a new element (for syntactic sugar):\n\n</p>\n<pre><code>dojo.query(dojo.create(&#39;div&#39;))\n    .addClass(&quot;newDiv&quot;)\n    .onclick(function(e){ console.log(&#39;clicked&#39;, e.target) })\n    .place(&quot;#someNode&quot;); // redundant, but cleaner.</code></pre>\n"
				]
			},
			{
				"name": "destroy",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-construct",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>A String ID or DomNode reference of the element to be destroyed\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Removes a node from its parent, clobbering it and all of its\nchildren.\n</p>\n",
				"description": "<p>Removes a node from its parent, clobbering it and all of its\nchildren. Function only works with DomNodes, and returns nothing.\n</p>\n",
				"examples": [
					"<p>Destroy a node byId:\n\n</p>\n<pre><code>dojo.destroy(&quot;someId&quot;);</code></pre>\n",
					"<p>Destroy all nodes in a list by reference:\n\n</p>\n<pre><code>dojo.query(&quot;.someNode&quot;).forEach(dojo.destroy);</code></pre>\n"
				]
			},
			{
				"name": "empty",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-construct",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>a reference to a DOM node or an id.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>safely removes all children of the node.</p>\n",
				"examples": [
					"<p>Destroy node&#39;s children byId:\n\n</p>\n<pre><code>dojo.empty(&quot;someId&quot;);</code></pre>\n",
					"<p>Destroy all nodes&#39; children in a list by reference:\n\n</p>\n<pre><code>dojo.query(&quot;.someNode&quot;).forEach(dojo.empty);</code></pre>\n"
				]
			},
			{
				"name": "place",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-construct",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or node reference, or HTML fragment starting with &quot;&lt;&quot; to place relative to refNode</p>\n"
					},
					{
						"name": "refNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or node reference to use as basis for placement</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Number"
						],
						"usage": "optional",
						"summary": "<p>string noting the position of node relative to refNode or a\nnumber indicating the location in the childNodes collection of refNode.\nAccepted string values are:\n\n</p>\n<ul>\n<li>before</li>\n<li>after</li>\n<li>replace</li>\n<li>only</li>\n<li>first</li>\n<li>last</li>\n</ul>\n<p>&quot;first&quot; and &quot;last&quot; indicate positions as children of refNode, &quot;replace&quot; replaces refNode,\n&quot;only&quot; replaces all children.  position defaults to &quot;last&quot; if not specified</p>\n"
					}
				],
				"returnTypes": [
					"DOMNode",
					"undefined"
				],
				"returnDescription": "<p>Returned values is the first argument resolved to a DOM node.\n\n</p>\n<p>.place() is also a method of <code>dojo/NodeList</code>, allowing <code>dojo.query</code> node lookups.</p>\n",
				"summary": "<p>Attempt to insert node into the DOM, choosing from various positioning options.\nReturns the first argument resolved to a DOM node.</p>\n",
				"examples": [
					"<p>Place a node by string id as the last child of another node by string id:\n\n</p>\n<pre><code>dojo.place(&quot;someNode&quot;, &quot;anotherNode&quot;);</code></pre>\n",
					"<p>Place a node by string id before another node by string id\n\n</p>\n<pre><code>dojo.place(&quot;someNode&quot;, &quot;anotherNode&quot;, &quot;before&quot;);</code></pre>\n",
					"<p>Create a Node, and place it in the body element (last child):\n\n</p>\n<pre><code>dojo.place(&quot;&lt;div&gt;&lt;/div&gt;&quot;, dojo.body());</code></pre>\n",
					"<p>Put a new LI as the first child of a list by id:\n\n</p>\n<pre><code>dojo.place(&quot;&lt;li&gt;&lt;/li&gt;&quot;, &quot;someUl&quot;, &quot;first&quot;);</code></pre>\n"
				]
			},
			{
				"name": "toDom",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-construct",
				"parameters": [
					{
						"name": "frag",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the HTML fragment</p>\n"
					},
					{
						"name": "doc",
						"types": [
							"DocumentNode"
						],
						"usage": "optional",
						"summary": "<p>optional document to use when creating DOM nodes, defaults to\ndojo.doc if not specified.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Document fragment, unless it&#39;s a single node in which case it returns the node itself</p>\n",
				"summary": "<p>instantiates an HTML fragment returning the corresponding DOM.</p>\n",
				"examples": [
					"<p>Create a table row:\n\n</p>\n<pre><code>var tr = dojo.toDom(&quot;&lt;tr&gt;&lt;td&gt;First!&lt;/td&gt;&lt;/tr&gt;&quot;);</code></pre>\n"
				]
			}
		]
	},
	"dojo/_base/window": {
		"location": "dojo/_base/window",
		"type": "object",
		"summary": "<p>API to save/set/restore the global/document scope.</p>\n",
		"properties": [
			{
				"name": "doc",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/window",
				"summary": "<p>Alias for the current document. &#39;doc&#39; can be modified\nfor temporary context shifting. See also withDoc().</p>\n",
				"description": "<p>Use this rather than referring to &#39;window.document&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n",
				"examples": [
					"<pre><code>n.appendChild(dojo.doc.createElement(&#39;div&#39;));</code></pre>\n"
				]
			},
			{
				"name": "global",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/window",
				"summary": "<p>Alias for the current window. &#39;global&#39; can be modified\nfor temporary context shifting. See also withGlobal().</p>\n",
				"description": "<p>Use this rather than referring to &#39;window&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n"
			}
		],
		"methods": [
			{
				"name": "body",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return the body element of the specified document or of dojo/_base/window::doc.</p>\n",
				"examples": [
					"<pre><code>win.body().appendChild(dojo.doc.createElement(&#39;div&#39;));</code></pre>\n"
				]
			},
			{
				"name": "setContext",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"parameters": [
					{
						"name": "globalObject",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "globalDocument",
						"types": [
							"DocumentElement"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>changes the behavior of many core Dojo functions that deal with\nnamespace and DOM lookup, changing them to work in a new global\ncontext (e.g., an iframe). The varibles dojo.global and dojo.doc\nare modified as a result of calling this function and the result of\n<code>dojo.body()</code> likewise differs.</p>\n"
			},
			{
				"name": "withDoc",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"parameters": [
					{
						"name": "documentObject",
						"types": [
							"DocumentElement"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "cbArguments",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Invoke callback with documentObject as dojo/_base/window::doc.</p>\n",
				"description": "<p>Invoke callback with documentObject as dojo/_base/window::doc. If provided,\ncallback will be executed in the context of object thisObject\nWhen callback() returns or throws an error, the dojo/_base/window::doc will\nbe restored to its previous state.</p>\n"
			},
			{
				"name": "withGlobal",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/window",
				"parameters": [
					{
						"name": "globalObject",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "cbArguments",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Invoke callback with globalObject as dojo.global and\nglobalObject.document as dojo.doc.</p>\n",
				"description": "<p>Invoke callback with globalObject as dojo.global and\nglobalObject.document as dojo.doc. If provided, globalObject\nwill be executed in the context of object thisObject\nWhen callback() returns or throws an error, the dojo.global\nand dojo.doc will be restored to its previous state.</p>\n"
			}
		]
	},
	"dojo/_base/window.global": {
		"location": "dojo/_base/window.global",
		"type": "object",
		"summary": "<p>Alias for the current window. &#39;global&#39; can be modified\nfor temporary context shifting. See also withGlobal().</p>\n",
		"description": "<p>Use this rather than referring to &#39;window&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n"
	},
	"dojo/_base/window.doc": {
		"location": "dojo/_base/window.doc",
		"type": "object",
		"summary": "<p>Alias for the current document. &#39;doc&#39; can be modified\nfor temporary context shifting. See also withDoc().</p>\n",
		"description": "<p>Use this rather than referring to &#39;window.document&#39; to ensure your code runs\ncorrectly in managed contexts.</p>\n",
		"examples": [
			"<pre><code>n.appendChild(dojo.doc.createElement(&#39;div&#39;));</code></pre>\n"
		]
	},
	"dojo/dom": {
		"location": "dojo/dom",
		"type": "object",
		"summary": "<p>This module defines the core dojo DOM API.</p>\n",
		"methods": [
			{
				"name": "byId",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom",
				"parameters": [
					{
						"name": "id",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>A string to match an HTML id attribute or a reference to a DOM Node\n</p>\n"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional",
						"summary": "<p>Document to work in. Defaults to the current value of\ndojo.doc.  Can be used to retrieve\nnode references from other documents.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns DOM node with matching <code>id</code> attribute or falsy value (ex: null or undefined)\nif not found.  If <code>id</code> is a DomNode, this function is a no-op.\n</p>\n",
				"examples": [
					"<p>Look up a node by ID:\n\n</p>\n<pre><code>var n = dojo.byId(&quot;foo&quot;);</code></pre>\n",
					"<p>Check if a node exists, and use it.\n\n</p>\n<pre><code>var n = dojo.byId(&quot;bar&quot;);\nif(n){ doStuff() ... }</code></pre>\n",
					"<p>Allow string or DomNode references to be passed to a custom function:\n\n</p>\n<pre><code>var foo = function(nodeOrId){\n    nodeOrId = dojo.byId(nodeOrId);\n    // ... more stuff\n}</code></pre>\n"
				]
			},
			{
				"name": "isDescendant",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>string id or node reference to test</p>\n"
					},
					{
						"name": "ancestor",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>string id or node reference of potential parent to test against\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns true if node is a descendant of ancestor</p>\n",
				"examples": [
					"<p>Test is node id=&quot;bar&quot; is a descendant of node id=&quot;foo&quot;\n\n</p>\n<pre><code>if(dojo.isDescendant(&quot;bar&quot;, &quot;foo&quot;)){ ... }</code></pre>\n"
				]
			},
			{
				"name": "setSelectable",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "selectable",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dojo/dom-attr": {
		"location": "dojo/dom-attr",
		"type": "object",
		"methods": [
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-attr",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to get the attribute on</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the name of the attribute to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined",
					"null"
				],
				"returnDescription": "<p>the value of the requested attribute or null if that attribute does not have a specified or\ndefault value;\n</p>\n",
				"summary": "<p>Gets an attribute on an HTML element.</p>\n",
				"description": "<p>Handles normalized getting of attributes on DOM Nodes.</p>\n",
				"examples": [
					"<pre><code>// get the current value of the &quot;foo&quot; attribute on a node\ndojo.getAttr(dojo.byId(&quot;nodeId&quot;), &quot;foo&quot;);\n// or we can just pass the id:\ndojo.getAttr(&quot;nodeId&quot;, &quot;foo&quot;);</code></pre>\n"
				]
			},
			{
				"name": "getNodeProp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-attr",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to remove the attribute from</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the name of the attribute</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>the value of the attribute</p>\n",
				"summary": "<p>Returns an effective value of a property or an attribute.</p>\n"
			},
			{
				"name": "has",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-attr",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to check</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the name of the attribute</p>\n"
					}
				],
				"returnTypes": [
					"Boolean",
					"undefined"
				],
				"returnDescription": "<p>true if the requested attribute is specified on the\ngiven element, and false otherwise</p>\n",
				"summary": "<p>Returns true if the requested attribute is specified on the\ngiven element, and false otherwise.</p>\n"
			},
			{
				"name": "remove",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-attr",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to remove the attribute from</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the name of the attribute to remove</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Removes an attribute from an HTML element.</p>\n"
			},
			{
				"name": "set",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-attr",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to set the attribute on</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String",
							"Object"
						],
						"usage": "required",
						"summary": "<p>the name of the attribute to set, or a hash of key-value pairs to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>the value to set for the attribute, if the name is a string.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>the DOM node\n</p>\n",
				"summary": "<p>Sets an attribute on an HTML element.</p>\n",
				"description": "<p>Handles normalized setting of attributes on DOM Nodes.\n\n</p>\n<p>When passing functions as values, note that they will not be\ndirectly assigned to slots on the node, but rather the default\nbehavior will be removed and the new behavior will be added\nusing <code>dojo.connect()</code>, meaning that event handler properties\nwill be normalized and that some caveats with regards to\nnon-standard behaviors for onsubmit apply. Namely that you\nshould cancel form submission using <code>dojo.stopEvent()</code> on the\npassed event object instead of returning a boolean value from\nthe handler itself.</p>\n",
				"examples": [
					"<pre><code>// use attr() to set the tab index\ndojo.setAttr(&quot;nodeId&quot;, &quot;tabIndex&quot;, 3);</code></pre>\n",
					"<p>Set multiple values at once, including event handlers:\n\n</p>\n<pre><code>dojo.setAttr(&quot;formId&quot;, {\n    &quot;foo&quot;: &quot;bar&quot;,\n    &quot;tabIndex&quot;: -1,\n    &quot;method&quot;: &quot;POST&quot;,\n    &quot;onsubmit&quot;: function(e){\n        // stop submitting the form. Note that the IE behavior\n        // of returning true or false will have no effect here\n        // since our handler is connect()ed to the built-in\n        // onsubmit behavior and so we need to use\n        // dojo.stopEvent() to ensure that the submission\n        // doesn&#39;t proceed.\n        dojo.stopEvent(e);\n\n        // submit the form with Ajax\n        dojo.xhrPost({ form: &quot;formId&quot; });\n    }\n});</code></pre>\n",
					"<p>Style is s special case: Only set with an object hash of styles\n\n</p>\n<pre><code>dojo.setAttr(&quot;someNode&quot;,{\n    id:&quot;bar&quot;,\n    style:{\n        width:&quot;200px&quot;, height:&quot;100px&quot;, color:&quot;#000&quot;\n    }\n});</code></pre>\n",
					"<p>Again, only set style as an object hash of styles:\n\n</p>\n<pre><code>var obj = { color:&quot;#fff&quot;, backgroundColor:&quot;#000&quot; };\ndojo.setAttr(&quot;someNode&quot;, &quot;style&quot;, obj);\n\n// though shorter to use `dojo.style()` in this case:\ndojo.setStyle(&quot;someNode&quot;, obj);</code></pre>\n"
				]
			}
		]
	},
	"dojo/dom-style": {
		"location": "dojo/dom-style",
		"type": "object",
		"summary": "<p>This module defines the core dojo DOM style API.</p>\n",
		"methods": [
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-style",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to node to get style for</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>the style property to get</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Accesses styles on a node.</p>\n",
				"description": "<p>Getting the style value uses the computed style for the node, so the value\nwill be a calculated value, not just the immediate node.style value.\nAlso when getting values, use specific style names,\nlike &quot;borderBottomWidth&quot; instead of &quot;border&quot; since compound values like\n&quot;border&quot; are not necessarily reflected as expected.\nIf you want to get node dimensions, use <code>dojo.marginBox()</code>,\n<code>dojo.contentBox()</code> or <code>dojo.position()</code>.</p>\n",
				"examples": [
					"<p>Passing only an ID or node returns the computed style object of\nthe node:\n\n</p>\n<pre><code>dojo.getStyle(&quot;thinger&quot;);</code></pre>\n",
					"<p>Passing a node and a style property returns the current\nnormalized, computed value for that property:\n\n</p>\n<pre><code>dojo.getStyle(&quot;thinger&quot;, &quot;opacity&quot;); // 1 by default</code></pre>\n"
				]
			},
			{
				"name": "getComputedStyle",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-style",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>A reference to a DOM node. Does NOT support taking an\nID string for speed reasons.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a &quot;computed style&quot; object.\n</p>\n",
				"description": "<p>Gets a &quot;computed style&quot; object which can be used to gather\ninformation about the current state of the rendered node.\n\n</p>\n<p>Note that this may behave differently on different browsers.\nValues may have different formats and value encodings across\nbrowsers.\n\n</p>\n<p>Note also that this method is expensive.  Wherever possible,\nreuse the returned object.\n\n</p>\n<p>Use the dojo.style() method for more consistent (pixelized)\nreturn values.\n</p>\n",
				"examples": [
					"<pre><code>dojo.getComputedStyle(dojo.byId(&#39;foo&#39;)).borderWidth;</code></pre>\n",
					"<p>Reusing the returned object, avoiding multiple lookups:\n\n</p>\n<pre><code>var cs = dojo.getComputedStyle(dojo.byId(&quot;someNode&quot;));\nvar w = cs.width, h = cs.height;</code></pre>\n"
				]
			},
			{
				"name": "set",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-style",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to node to set style for</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String",
							"Object"
						],
						"usage": "required",
						"summary": "<p>the style property to set in DOM-accessor format\n(&quot;borderWidth&quot;, not &quot;border-width&quot;) or an object with key/value\npairs suitable for setting each property.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>If passed, sets value on the node for style, handling\ncross-browser concerns.  When setting a pixel value,\nbe sure to include &quot;px&quot; in the value. For instance, top: &quot;200px&quot;.\nOtherwise, in some cases, some browsers will not apply the style.\n</p>\n"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"returnDescription": "<p>If passed, sets value on the node for style, handling\ncross-browser concerns.  When setting a pixel value,\nbe sure to include &quot;px&quot; in the value. For instance, top: &quot;200px&quot;.\nOtherwise, in some cases, some browsers will not apply the style.\n</p>\n",
				"summary": "<p>Sets styles on a node.</p>\n",
				"examples": [
					"<p>Passing a node, a style property, and a value changes the\ncurrent display of the node and returns the new computed value\n\n</p>\n<pre><code>dojo.setStyle(&quot;thinger&quot;, &quot;opacity&quot;, 0.5); // == 0.5</code></pre>\n",
					"<p>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:\n\n</p>\n<pre><code>dojo.setStyle(&quot;thinger&quot;, {\n    &quot;opacity&quot;: 0.5,\n    &quot;border&quot;: &quot;3px solid black&quot;,\n    &quot;height&quot;: &quot;300px&quot;\n});</code></pre>\n",
					"<p>When the CSS style property is hyphenated, the JavaScript property is camelCased.\nfont-size becomes fontSize, and so on.\n\n</p>\n<pre><code>dojo.setStyle(&quot;thinger&quot;,{\n    fontSize:&quot;14pt&quot;,\n    letterSpacing:&quot;1.2em&quot;\n});</code></pre>\n",
					"<p>dojo/NodeList implements .style() using the same syntax, omitting the &quot;node&quot; parameter, calling\ndojo.style() on every element of the list. See: <code>dojo.query()</code> and <code>dojo/NodeList</code>\n\n</p>\n<pre><code>dojo.query(&quot;.someClassName&quot;).style(&quot;visibility&quot;,&quot;hidden&quot;);\n// or\ndojo.query(&quot;#baz &gt; div&quot;).style({\n    opacity:0.75,\n    fontSize:&quot;13pt&quot;\n});</code></pre>\n"
				]
			},
			{
				"name": "toPixelValue",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-style",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Number"
				],
				"summary": "<p>converts style value to pixels on IE or return a numeric value.</p>\n"
			}
		]
	},
	"dojo/dom-prop": {
		"location": "dojo/dom-prop",
		"type": "object",
		"properties": [
			{
				"name": "names",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/dom-prop"
			}
		],
		"methods": [
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-prop",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to get the property on</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the name of the property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>the value of the requested property or its default value\n</p>\n",
				"summary": "<p>Gets a property on an HTML element.</p>\n",
				"description": "<p>Handles normalized getting of properties on DOM nodes.\n</p>\n",
				"examples": [
					"<pre><code>// get the current value of the &quot;foo&quot; property on a node\ndojo.getProp(dojo.byId(&quot;nodeId&quot;), &quot;foo&quot;);\n// or we can just pass the id:\ndojo.getProp(&quot;nodeId&quot;, &quot;foo&quot;);</code></pre>\n"
				]
			},
			{
				"name": "set",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-prop",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>id or reference to the element to set the property on</p>\n"
					},
					{
						"name": "name",
						"types": [
							"String",
							"Object"
						],
						"usage": "required",
						"summary": "<p>the name of the property to set, or a hash object to set\nmultiple properties at once.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>The value to set for the property</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>the DOM node\n</p>\n",
				"summary": "<p>Sets a property on an HTML element.</p>\n",
				"description": "<p>Handles normalized setting of properties on DOM nodes.\n\n</p>\n<p>When passing functions as values, note that they will not be\ndirectly assigned to slots on the node, but rather the default\nbehavior will be removed and the new behavior will be added\nusing <code>dojo.connect()</code>, meaning that event handler properties\nwill be normalized and that some caveats with regards to\nnon-standard behaviors for onsubmit apply. Namely that you\nshould cancel form submission using <code>dojo.stopEvent()</code> on the\npassed event object instead of returning a boolean value from\nthe handler itself.</p>\n",
				"examples": [
					"<pre><code>// use prop() to set the tab index\ndojo.setProp(&quot;nodeId&quot;, &quot;tabIndex&quot;, 3);</code></pre>\n",
					"<p>Set multiple values at once, including event handlers:\n\n</p>\n<pre><code>dojo.setProp(&quot;formId&quot;, {\n    &quot;foo&quot;: &quot;bar&quot;,\n    &quot;tabIndex&quot;: -1,\n    &quot;method&quot;: &quot;POST&quot;,\n    &quot;onsubmit&quot;: function(e){\n        // stop submitting the form. Note that the IE behavior\n        // of returning true or false will have no effect here\n        // since our handler is connect()ed to the built-in\n        // onsubmit behavior and so we need to use\n        // dojo.stopEvent() to ensure that the submission\n        // doesn&#39;t proceed.\n        dojo.stopEvent(e);\n\n        // submit the form with Ajax\n        dojo.xhrPost({ form: &quot;formId&quot; });\n    }\n});</code></pre>\n",
					"<p>Style is s special case: Only set with an object hash of styles\n\n</p>\n<pre><code>dojo.setProp(&quot;someNode&quot;,{\n    id:&quot;bar&quot;,\n    style:{\n        width:&quot;200px&quot;, height:&quot;100px&quot;, color:&quot;#000&quot;\n    }\n});</code></pre>\n",
					"<p>Again, only set style as an object hash of styles:\n\n</p>\n<pre><code>var obj = { color:&quot;#fff&quot;, backgroundColor:&quot;#000&quot; };\ndojo.setProp(&quot;someNode&quot;, &quot;style&quot;, obj);\n\n// though shorter to use `dojo.style()` in this case:\ndojo.style(&quot;someNode&quot;, obj);</code></pre>\n"
				]
			}
		]
	},
	"dojo/dom-prop.names": {
		"location": "dojo/dom-prop.names",
		"type": "object",
		"properties": [
			{
				"name": "class",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "colspan",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "for",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "frameborder",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "readonly",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "rowspan",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "tabindex",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			},
			{
				"name": "valuetype",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-prop"
			}
		]
	},
	"dojo/_base/connect": {
		"location": "dojo/_base/connect",
		"type": "object",
		"summary": "<p>This module defines the dojo.connect API.\nThis modules also provides keyboard event handling helpers.\nThis module exports an extension event for emulating Firefox&#39;s keypress handling.\nHowever, this extension event exists primarily for backwards compatibility and\nis not recommended. WebKit and IE uses an alternate keypress handling (only\nfiring for printable characters, to distinguish from keydown events), and most\nconsider the WebKit/IE behavior more desirable.</p>\n",
		"methods": [
			{
				"name": "_keypress",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"private": true,
				"parameters": [
					{
						"name": "object",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "connect",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The source object for the event function.\nDefaults to <code>kernel.global</code> if null.\nIf obj is a DOM node, the connection is delegated\nto the DOM event manager (unless dontFix is true).\n</p>\n"
					},
					{
						"name": "event",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String name of the event function in obj.\nI.e. identifies a property <code>obj[event]</code>.\n</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>The object that method will receive as &quot;this&quot;.\n\n</p>\n<p>If context is null and method is a function, then method\ninherits the context of event.\n\n</p>\n<p>If method is a string then context must be the source\nobject object for method (context[method]). If context is null,\nkernel.global is used.\n</p>\n"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>A function reference, or name of a function in context.\nThe function identified by method fires after event does.\nmethod receives the same arguments as the event.\nSee context argument comments for information on method&#39;s scope.\n</p>\n"
					},
					{
						"name": "dontFix",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If obj is a DOM node, set dontFix to true to prevent delegation\nof this connection to the DOM event manager.\n</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p><code>dojo.connect</code> is a deprecated event handling and delegation method in\nDojo. It allows one function to &quot;listen in&quot; on the execution of\nany other, triggering the second whenever the first is called. Many\nlisteners may be attached to a function, and source functions may\nbe either regular function calls or DOM events.\n</p>\n",
				"description": "<p>Connects listeners to actions, so that after event fires, a\nlistener is called with the same arguments passed to the original\nfunction.\n\n</p>\n<p>Since <code>dojo.connect</code> allows the source of events to be either a\n&quot;regular&quot; JavaScript function or a DOM event, it provides a uniform\ninterface for listening to all the types of events that an\napplication is likely to deal with though a single, unified\ninterface. DOM programmers may want to think of it as\n&quot;addEventListener for everything and anything&quot;.\n\n</p>\n<p>When setting up a connection, the <code>event</code> parameter must be a\nstring that is the name of the method/event to be listened for. If\n<code>obj</code> is null, <code>kernel.global</code> is assumed, meaning that connections\nto global methods are supported but also that you may inadvertently\nconnect to a global by passing an incorrect object name or invalid\nreference.\n\n</p>\n<p><code>dojo.connect</code> generally is forgiving. If you pass the name of a\nfunction or method that does not yet exist on <code>obj</code>, connect will\nnot fail, but will instead set up a stub method. Similarly, null\narguments may simply be omitted such that fewer than 4 arguments\nmay be required to set up a connection See the examples for details.\n\n</p>\n<p>The return value is a handle that is needed to\nremove this connection with <code>dojo.disconnect</code>.\n</p>\n",
				"examples": [
					"<p>When obj.onchange(), do ui.update():\n\n</p>\n<pre><code>dojo.connect(obj, &quot;onchange&quot;, ui, &quot;update&quot;);\ndojo.connect(obj, &quot;onchange&quot;, ui, ui.update); // same</code></pre>\n",
					"<p>Using return value for disconnect:\n\n</p>\n<pre><code>var link = dojo.connect(obj, &quot;onchange&quot;, ui, &quot;update&quot;);\n...\ndojo.disconnect(link);</code></pre>\n",
					"<p>When onglobalevent executes, watcher.handler is invoked:\n\n</p>\n<pre><code>dojo.connect(null, &quot;onglobalevent&quot;, watcher, &quot;handler&quot;);</code></pre>\n",
					"<p>When ob.onCustomEvent executes, customEventHandler is invoked:\n\n</p>\n<pre><code>dojo.connect(ob, &quot;onCustomEvent&quot;, null, &quot;customEventHandler&quot;);\ndojo.connect(ob, &quot;onCustomEvent&quot;, &quot;customEventHandler&quot;); // same</code></pre>\n",
					"<p>When ob.onCustomEvent executes, customEventHandler is invoked\nwith the same scope (this):\n\n</p>\n<pre><code>dojo.connect(ob, &quot;onCustomEvent&quot;, null, customEventHandler);\ndojo.connect(ob, &quot;onCustomEvent&quot;, customEventHandler); // same</code></pre>\n",
					"<p>When globalEvent executes, globalHandler is invoked\nwith the same scope (this):\n\n</p>\n<pre><code>dojo.connect(null, &quot;globalEvent&quot;, null, globalHandler);\ndojo.connect(&quot;globalEvent&quot;, globalHandler); // same</code></pre>\n"
				]
			},
			{
				"name": "connectPublisher",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the topic to publish.</p>\n"
					},
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The source object for the event function. Defaults to kernel.global\nif null.</p>\n"
					},
					{
						"name": "event",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the event function in obj.\nI.e. identifies a property obj[event].</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Ensure that every time obj.event() is called, a message is published\non the topic. Returns a handle which can be passed to\ndojo.disconnect() to disable subsequent automatic publication on\nthe topic.</p>\n",
				"examples": [
					"<pre><code>dojo.connectPublisher(&quot;/ajax/start&quot;, dojo, &quot;xhrGet&quot;);</code></pre>\n"
				]
			},
			{
				"name": "disconnect",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Handle"
						],
						"usage": "required",
						"summary": "<p>the return value of the dojo.connect call that created the connection.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Remove a link created by dojo.connect.</p>\n",
				"description": "<p>Removes the connection between event and the method referenced by handle.</p>\n"
			},
			{
				"name": "isCopyKey",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "e",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>Event object to examine</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)</p>\n"
			},
			{
				"name": "publish",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the topic to publish.</p>\n"
					},
					{
						"name": "args",
						"types": [
							"Array"
						],
						"usage": "optional",
						"summary": "<p>An array of arguments. The arguments will be applied\nto each topic subscriber (as first class parameters, via apply).</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Invoke all listener method subscribed to topic.</p>\n",
				"examples": [
					"<pre><code>dojo.subscribe(&quot;alerts&quot;, null, function(caption, message){ alert(caption + &quot;\\n&quot; + message); };\ndojo.publish(&quot;alerts&quot;, [ &quot;read this&quot;, &quot;hello world&quot; ]);</code></pre>\n"
				]
			},
			{
				"name": "subscribe",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic to which to subscribe.</p>\n"
					},
					{
						"name": "context",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Scope in which method will be invoked, or null for default scope.</p>\n"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>The name of a function in context, or a function reference. This is the function that\nis invoked when topic is published.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Attach a listener to a named topic. The listener function is invoked whenever the\nnamed topic is published (see: dojo.publish).\nReturns a handle which is needed to unsubscribe this listener.</p>\n",
				"examples": [
					"<pre><code>dojo.subscribe(&quot;alerts&quot;, null, function(caption, message){ alert(caption + &quot;\\n&quot; + message); });\ndojo.publish(&quot;alerts&quot;, [ &quot;read this&quot;, &quot;hello world&quot; ]);</code></pre>\n"
				]
			},
			{
				"name": "unsubscribe",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/connect",
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Handle"
						],
						"usage": "required",
						"summary": "<p>The handle returned from a call to subscribe.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Remove a topic listener.</p>\n",
				"examples": [
					"<pre><code>var alerter = dojo.subscribe(&quot;alerts&quot;, null, function(caption, message){ alert(caption + &quot;\\n&quot; + message); };\n...\ndojo.unsubscribe(alerter);</code></pre>\n"
				]
			}
		]
	},
	"dojo/on": {
		"location": "dojo/on",
		"type": "function",
		"parameters": [
			{
				"name": "target",
				"types": [
					"Element",
					"Object"
				],
				"usage": "required",
				"summary": "<p>This is the target object or DOM element that to receive events from</p>\n"
			},
			{
				"name": "type",
				"types": [
					"String",
					"Function"
				],
				"usage": "required",
				"summary": "<p>This is the name of the event to listen for or an extension event type.</p>\n"
			},
			{
				"name": "listener",
				"types": [
					"Function"
				],
				"usage": "required",
				"summary": "<p>This is the function that should be called when the event fires.</p>\n"
			},
			{
				"name": "dontFix",
				"types": [
					"undefined"
				],
				"usage": "required"
			}
		],
		"returnTypes": [
			"Object",
			"undefined"
		],
		"returnDescription": "<p>An object with a remove() method that can be used to stop listening for this\nevent.</p>\n",
		"summary": "<p>A function that provides core event listening functionality. With this function\nyou can provide a target, event type, and listener to be notified of\nfuture matching events that are fired.</p>\n",
		"description": "<p>To listen for &quot;click&quot; events on a button node, we can do:\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;], function(listen){\n    on(button, &quot;click&quot;, clickHandler);\n    ...</code></pre>\n<p>Evented JavaScript objects can also have their own events.\n\n\n</p>\n<pre><code>var obj = new Evented;\non(obj, &quot;foo&quot;, fooHandler);</code></pre>\n<p>And then we could publish a &quot;foo&quot; event:\n\n\n</p>\n<pre><code>on.emit(obj, &quot;foo&quot;, {key: &quot;value&quot;});</code></pre>\n<p>We can use extension events as well. For example, you could listen for a tap gesture:\n\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;, &quot;dojo/gesture/tap&quot;, function(listen, tap){\n    on(button, tap, tapHandler);\n    ...</code></pre>\n<p>which would trigger fooHandler. Note that for a simple object this is equivalent to calling:\n\n\n</p>\n<pre><code>obj.onfoo({key:&quot;value&quot;});</code></pre>\n<p>If you use on.emit on a DOM node, it will use native event dispatching when possible.\n</p>\n",
		"methods": [
			{
				"name": "_fixEvent",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/event",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "se",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_preventDefault",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"parameters": [
					{
						"name": "target",
						"types": [
							"Element",
							"Object"
						],
						"usage": "required",
						"summary": "<p>This is the target object or DOM element that to receive events from</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>This is the name of the event to listen for or an extension event type.</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>This is the function that should be called when the event fires.</p>\n"
					},
					{
						"name": "dontFix",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"returnDescription": "<p>An object with a remove() method that can be used to stop listening for this\nevent.</p>\n",
				"summary": "<p>A function that provides core event listening functionality. With this function\nyou can provide a target, event type, and listener to be notified of\nfuture matching events that are fired.</p>\n",
				"description": "<p>To listen for &quot;click&quot; events on a button node, we can do:\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;], function(listen){\n    on(button, &quot;click&quot;, clickHandler);\n    ...</code></pre>\n<p>Evented JavaScript objects can also have their own events.\n\n\n</p>\n<pre><code>var obj = new Evented;\non(obj, &quot;foo&quot;, fooHandler);</code></pre>\n<p>And then we could publish a &quot;foo&quot; event:\n\n\n</p>\n<pre><code>on.emit(obj, &quot;foo&quot;, {key: &quot;value&quot;});</code></pre>\n<p>We can use extension events as well. For example, you could listen for a tap gesture:\n\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;, &quot;dojo/gesture/tap&quot;, function(listen, tap){\n    on(button, tap, tapHandler);\n    ...</code></pre>\n<p>which would trigger fooHandler. Note that for a simple object this is equivalent to calling:\n\n\n</p>\n<pre><code>obj.onfoo({key:&quot;value&quot;});</code></pre>\n<p>If you use on.emit on a DOM node, it will use native event dispatching when possible.\n</p>\n"
			},
			{
				"name": "emit",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"parameters": [
					{
						"name": "target",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "once",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"parameters": [
					{
						"name": "target",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "dontFix",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>This function acts the same as on(), but will only call the listener once. The \nlistener will be called for the first\nevent that takes place and then listener will automatically be removed.</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"parameters": [
					{
						"name": "target",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "addListener",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "dontFix",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "matchesTarget",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "pausable",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"parameters": [
					{
						"name": "target",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "dontFix",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>This function acts the same as on(), but with pausable functionality. The\nreturned signal object has pause() and resume() functions. Calling the\npause() method will cause the listener to not be called for future events. Calling the\nresume() method will cause the listener to again be called for future events.</p>\n"
			},
			{
				"name": "selector",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/on",
				"parameters": [
					{
						"name": "selector",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The CSS selector to use for filter events and determine the |this| of the event listener.</p>\n"
					},
					{
						"name": "eventType",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The event to listen for</p>\n"
					},
					{
						"name": "children",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Indicates if children elements of the selector should be allowed. This defaults to \ntrue</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Creates a new extension event with event delegation. This is based on\nthe provided event type (can be extension event) that\nonly calls the listener when the CSS selector matches the target of the event.\n\n</p>\n<p>The application must require() an appropriate level of dojo/query to handle the selector.</p>\n",
				"examples": [
					"<pre><code>require([&quot;dojo/on&quot;, &quot;dojo/mouse&quot;, &quot;dojo/query!css2&quot;], function(listen, mouse){\n    on(node, on.selector(&quot;.my-class&quot;, mouse.enter), handlerForMyHover);</code></pre>\n"
				]
			}
		]
	},
	"dojo/topic": {
		"location": "dojo/topic",
		"type": "object",
		"summary": "<p>Pubsub hub.</p>\n",
		"examples": [
			"<pre><code>topic.subscribe(&quot;some/topic&quot;, function(event){\n... do something with event\n});\ntopic.publish(&quot;some/topic&quot;, {name:&quot;some event&quot;, ...});</code></pre>\n"
		],
		"methods": [
			{
				"name": "publish",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/topic",
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The name of the topic to publish to</p>\n"
					},
					{
						"name": "event",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An event to distribute to the topic listeners</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Publishes a message to a topic on the pub/sub hub. All arguments after\nthe first will be passed to the subscribers, so any number of arguments\ncan be provided (not just event).</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/topic",
				"parameters": [
					{
						"name": "topic",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic to subscribe to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>A function to call when a message is published to the given topic</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Subscribes to a topic on the pub/sub hub</p>\n"
			}
		]
	},
	"dojo/Evented": {
		"location": "dojo/Evented",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>A class that can be used as a mixin or base class,\nto add on() and emit() methods to a class\nfor listening for events and emitting events:\n\n\n</p>\n<pre><code>define([&quot;dojo/Evented&quot;], function(Evented){\n    var EventedWidget = dojo.declare([Evented, dijit._Widget], {...});\n    widget = new EventedWidget();\n    widget.on(&quot;open&quot;, function(event){\n    ... do something with event\n });\n\nwidget.emit(&quot;open&quot;, {name:&quot;some event&quot;, ...});</code></pre>\n",
		"methods": [
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Evented",
				"parameters": [
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Evented",
				"parameters": [
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"dojo/aspect": {
		"location": "dojo/aspect",
		"type": "object",
		"summary": "<p>provides aspect oriented programming functionality, allowing for\none to add before, around, or after advice on existing methods.</p>\n",
		"examples": [
			"<pre><code>define([&quot;dojo/aspect&quot;], function(aspect){\n    var signal = aspect.after(targetObject, &quot;methodName&quot;, function(someArgument){\n        this will be called when targetObject.methodName() is called, after the original function is called\n    });</code></pre>\n",
			"<p>The returned signal object can be used to cancel the advice.\n\n</p>\n<pre><code>signal.remove(); // this will stop the advice from being executed anymore\naspect.before(targetObject, &quot;methodName&quot;, function(someArgument){\n    // this will be called when targetObject.methodName() is called, before the original function is called\n });</code></pre>\n"
		],
		"methods": [
			{
				"name": "after",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/aspect",
				"parameters": [
					{
						"name": "target",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>This is the target object</p>\n"
					},
					{
						"name": "methodName",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>This is the name of the method to attach to.</p>\n"
					},
					{
						"name": "advice",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>This is function to be called after the original method</p>\n"
					},
					{
						"name": "receiveArguments",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If this is set to true, the advice function receives the original arguments (from when the original mehtod\nwas called) rather than the return value of the original/previous method.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\nstop the advice function from being executed.</p>\n",
				"summary": "<p>The &quot;after&quot; export of the aspect module is a function that can be used to attach\n&quot;after&quot; advice to a method. This function will be executed after the original method\nis executed. By default the function will be called with a single argument, the return\nvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\nThe fourth (optional) argument can be set to true to so the function receives the original\narguments (from when the original method was called) rather than the return value.\nIf there are multiple &quot;after&quot; advisors, they are executed in the order they were registered.</p>\n"
			},
			{
				"name": "around",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/aspect",
				"parameters": [
					{
						"name": "target",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>This is the target object</p>\n"
					},
					{
						"name": "methodName",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>This is the name of the method to attach to.</p>\n"
					},
					{
						"name": "advice",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>This is function to be called around the original method</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>The &quot;around&quot; export of the aspect module is a function that can be used to attach\n&quot;around&quot; advice to a method. The advisor function is immediately executed when\nthe around() is called, is passed a single argument that is a function that can be\ncalled to continue execution of the original method (or the next around advisor).\nThe advisor function should return a function, and this function will be called whenever\nthe method is called. It will be called with the arguments used to call the method.\nWhatever this function returns will be returned as the result of the method call (unless after advise changes it).</p>\n",
				"examples": [
					"<p>If there are multiple &quot;around&quot; advisors, the most recent one is executed first,\nwhich can then delegate to the next one and so on. For example:\n\n</p>\n<pre><code>around(obj, &quot;foo&quot;, function(originalFoo){\n    return function(){\n        var start = new Date().getTime();\n        var results = originalFoo.apply(this, arguments); // call the original\n        var end = new Date().getTime();\n        console.log(&quot;foo execution took &quot; + (end - start) + &quot; ms&quot;);\n        return results;\n    };\n});</code></pre>\n"
				]
			},
			{
				"name": "before",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/aspect",
				"parameters": [
					{
						"name": "target",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>This is the target object</p>\n"
					},
					{
						"name": "methodName",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>This is the name of the method to attach to.</p>\n"
					},
					{
						"name": "advice",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>This is function to be called before the original method</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>The &quot;before&quot; export of the aspect module is a function that can be used to attach\n&quot;before&quot; advice to a method. This function will be executed before the original method\nis executed. This function will be called with the arguments used to call the method.\nThis function may optionally return an array as the new arguments to use to call\nthe original method (or the previous, next-to-execute before advice, if one exists).\nIf the before method doesn&#39;t return anything (returns undefined) the original arguments\nwill be preserved.\nIf there are multiple &quot;before&quot; advisors, they are executed in the reverse order they were registered.</p>\n"
			}
		]
	},
	"dojo/_base/event": {
		"location": "dojo/_base/event",
		"type": "object",
		"summary": "<p>This module defines dojo DOM event API.   Usually you should use dojo/on, and evt.stopPropagation() +\nevt.preventDefault(), rather than this module.</p>\n",
		"methods": [
			{
				"name": "fix",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/event",
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>native event object</p>\n"
					},
					{
						"name": "sender",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>node to treat as &quot;currentTarget&quot;</p>\n"
					}
				],
				"returnTypes": [
					"Event"
				],
				"returnDescription": "<p>native event object</p>\n",
				"summary": "<p>normalizes properties on the event object including event\nbubbling methods, keystroke normalization, and x/y positions</p>\n"
			},
			{
				"name": "stop",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/event",
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required",
						"summary": "<p>The event object. If omitted, window.event is used on IE.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>prevents propagation and clobbers the default action of the\npassed event</p>\n"
			}
		]
	},
	"dojo/dom-geometry": {
		"location": "dojo/dom-geometry",
		"type": "object",
		"summary": "<p>This module defines the core dojo DOM geometry API.</p>\n",
		"properties": [
			{
				"name": "boxModel",
				"scope": "normal",
				"types": [
					"string"
				],
				"from": "dojo/dom-geometry"
			}
		],
		"methods": [
			{
				"name": "docScroll",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional",
						"summary": "<p>Optional document to query.   If unspecified, use win.doc.</p>\n"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"summary": "<p>Returns an object with {node, x, y} with corresponding offsets.</p>\n"
			},
			{
				"name": "fixIeBiDiScrollLeft",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "scrollLeft",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional",
						"summary": "<p>Optional document to query.   If unspecified, use win.doc.</p>\n"
					}
				],
				"returnTypes": [
					"Number",
					"number"
				],
				"summary": "<p>In RTL direction, scrollLeft should be a negative value, but IE\nreturns a positive one. All codes using documentElement.scrollLeft\nmust call this function to fix this error, otherwise the position\nwill offset to right when there is a horizontal scrollbar.</p>\n"
			},
			{
				"name": "getBorderExtents",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>returns an object with properties useful for noting the border\ndimensions.</p>\n",
				"description": "<ul>\n<li>l/t/r/b = the sum of left/top/right/bottom border (respectively)</li>\n<li>w = the sum of the left and right border</li>\n<li>h = the sum of the top and bottom border</li>\n</ul>\n<p>The w/h are used for calculating boxes.\nNormally application code will not need to invoke this\ndirectly, and will use the ...box... functions instead.</p>\n"
			},
			{
				"name": "getContentBox",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns an object that encodes the width, height, left and top\npositions of the node&#39;s content box, irrespective of the\ncurrent box model.</p>\n"
			},
			{
				"name": "getIeDocumentElementOffset",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional",
						"summary": "<p>Optional document to query.   If unspecified, use win.doc.</p>\n"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>returns the offset in x and y from the document body to the\nvisual edge of the page for IE</p>\n",
				"description": "<p>The following values in IE contain an offset:\n\n</p>\n<pre><code>event.clientX\nevent.clientY\nnode.getBoundingClientRect().left\nnode.getBoundingClientRect().top</code></pre>\n<p>But other position related values do not contain this offset,\n\n</p>\n<p>such as node.offsetLeft, node.offsetTop, node.style.left and\nnode.style.top. The offset is always (2, 2) in LTR direction.\nWhen the body is in RTL direction, the offset counts the width\nof left scroll bar&#39;s width.  This function computes the actual\noffset.</p>\n"
			},
			{
				"name": "getMarginBox",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>returns an object that encodes the width, height, left and top\npositions of the node&#39;s margin box.</p>\n"
			},
			{
				"name": "getMarginExtents",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>returns object with properties useful for box fitting with\nregards to box margins (i.e., the outer-box).\n\n</p>\n<ul>\n<li>l/t = marginLeft, marginTop, respectively</li>\n<li>w = total width, margin inclusive</li>\n<li>h = total height, margin inclusive</li>\n</ul>\n<p>The w/h are used for calculating boxes.\nNormally application code will not need to invoke this\ndirectly, and will use the ...box... functions instead.</p>\n"
			},
			{
				"name": "getMarginSize",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>returns an object that encodes the width and height of\nthe node&#39;s margin box</p>\n"
			},
			{
				"name": "getPadBorderExtents",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns object with properties useful for box fitting with\nregards to padding.</p>\n",
				"description": "<ul>\n<li>l/t/r/b = the sum of left/top/right/bottom padding and left/top/right/bottom border (respectively)</li>\n<li>w = the sum of the left and right padding and border</li>\n<li>h = the sum of the top and bottom padding and border</li>\n</ul>\n<p>The w/h are used for calculating boxes.\nNormally application code will not need to invoke this\ndirectly, and will use the ...box... functions instead.</p>\n"
			},
			{
				"name": "getPadExtents",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns object with special values specifically useful for node\nfitting.</p>\n",
				"description": "<p>Returns an object with <code>w</code>, <code>h</code>, <code>l</code>, <code>t</code> properties:\n\n</p>\n<pre><code>l/t/r/b = left/top/right/bottom padding (respectively)\nw = the total of the left and right padding\nh = the total of the top and bottom padding</code></pre>\n<p>If &#39;node&#39; has position, l/t forms the origin for child nodes.\n\n</p>\n<p>The w/h are used for calculating boxes.\nNormally application code will not need to invoke this\ndirectly, and will use the ...box... functions instead.</p>\n"
			},
			{
				"name": "isBodyLtr",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional",
						"summary": "<p>Optional document to query.   If unspecified, use win.doc.</p>\n"
					}
				],
				"returnTypes": [
					"Boolean",
					"boolean"
				],
				"summary": "<p>Returns true if the current language is left-to-right, and false otherwise.</p>\n"
			},
			{
				"name": "normalizeEvent",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "event",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Normalizes the geometry of a DOM event, normalizing the pageX, pageY,\noffsetX, offsetY, layerX, and layerX properties</p>\n"
			},
			{
				"name": "position",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "includeScroll",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Object",
					"object"
				],
				"summary": "<p>Gets the position and size of the passed element relative to\nthe viewport (if includeScroll==false), or relative to the\ndocument root (if includeScroll==true).\n</p>\n",
				"description": "<p>Returns an object of the form:\n<code>{ x: 100, y: 300, w: 20, h: 15 }</code>.\nIf includeScroll==true, the x and y values will include any\ndocument offsets that may affect the position relative to the\nviewport.\nUses the border-box model (inclusive of border and padding but\nnot margin).  Does not act as a setter.</p>\n"
			},
			{
				"name": "setContentSize",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "box",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>hash with optional &quot;w&quot;, and &quot;h&quot; properties for &quot;width&quot;, and &quot;height&quot;\nrespectively. All specified properties should have numeric values in whole pixels.</p>\n"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the size of the node&#39;s contents, irrespective of margins,\npadding, or borders.</p>\n"
			},
			{
				"name": "setMarginBox",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-geometry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "box",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>hash with optional &quot;l&quot;, &quot;t&quot;, &quot;w&quot;, and &quot;h&quot; properties for &quot;left&quot;, &quot;right&quot;, &quot;width&quot;, and &quot;height&quot;\nrespectively. All specified properties should have numeric values in whole pixels.</p>\n"
					},
					{
						"name": "computedStyle",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>This parameter accepts computed styles object.\nIf this parameter is omitted, the functions will call\ndojo.getComputedStyle to get one. It is a better way, calling\ndojo.computedStyle once, and then pass the reference to this\ncomputedStyle parameter. Wherever possible, reuse the returned\nobject of dojo/dom-style.getComputedStyle().</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>sets the size of the node&#39;s margin box and placement\n(left/top), irrespective of box model. Think of it as a\npassthrough to setBox that handles box-model vagaries for\nyou.</p>\n"
			}
		]
	},
	"dojo/mouse": {
		"location": "dojo/mouse",
		"type": "object",
		"summary": "<p>This module provide mouse event handling utility functions and exports\nmouseenter and mouseleave event emulation.</p>\n",
		"examples": [
			"<p>To use these events, you register a mouseenter like this:\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;, dojo/mouse&quot;], function(on, mouse){\n    on(targetNode, mouse.enter, function(event){\n        dojo.addClass(targetNode, &quot;highlighted&quot;);\n    });\n    on(targetNode, mouse.leave, function(event){\n        dojo.removeClass(targetNode, &quot;highlighted&quot;);\n    });</code></pre>\n"
		],
		"properties": [
			{
				"name": "enter",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/mouse",
				"summary": "<p>This is an extension event for the mouseenter that IE provides, emulating the\nbehavior on other browsers.</p>\n"
			},
			{
				"name": "leave",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/mouse",
				"summary": "<p>This is an extension event for the mouseleave that IE provides, emulating the\nbehavior on other browsers.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_eventHandler",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "selectHandler",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				]
			},
			{
				"name": "isLeft",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Test an event object (from a mousedown event) to see if the left button was pressed.</p>\n"
			},
			{
				"name": "isMiddle",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Test an event object (from a mousedown event) to see if the middle button was pressed.</p>\n"
			},
			{
				"name": "isRight",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Test an event object (from a mousedown event) to see if the right button was pressed.</p>\n"
			},
			{
				"name": "wheel",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/mouse",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>This is an extension event for the mousewheel that non-Mozilla browsers provide,\nemulating the behavior on Mozilla based browsers.</p>\n"
			}
		]
	},
	"dojo/_base/sniff": {
		"location": "dojo/_base/sniff",
		"type": "object",
		"summary": "<p>Deprecated.   New code should use dojo/sniff.\nThis module populates the dojo browser version sniffing properties like dojo.isIE.</p>\n"
	},
	"dojo/keys": {
		"location": "dojo/keys",
		"type": "object",
		"summary": "<p>Definitions for common key values.  Client code should test keyCode against these named constants,\nas the actual codes can vary by browser.</p>\n",
		"properties": [
			{
				"name": "ALT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "BACKSPACE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "CAPS_LOCK",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "CLEAR",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "copyKey",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "CTRL",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "DELETE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "DOWN_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "DOWN_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "END",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "ENTER",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "ESCAPE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F1",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F10",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F11",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F12",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F13",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F14",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F15",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F2",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F3",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F4",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F5",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F6",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F7",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F8",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "F9",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "HELP",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "HOME",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "INSERT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "LEFT_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "LEFT_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "LEFT_WINDOW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "META",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUM_LOCK",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_0",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_1",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_2",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_3",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_4",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_5",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_6",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_7",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_8",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_9",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_DIVIDE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_ENTER",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_MINUS",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_MULTIPLY",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_PERIOD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "NUMPAD_PLUS",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "PAGE_DOWN",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "PAGE_UP",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "PAUSE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "RIGHT_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "RIGHT_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "RIGHT_WINDOW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "SCROLL_LOCK",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "SELECT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "SHIFT",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "SPACE",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "TAB",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "UP_ARROW",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			},
			{
				"name": "UP_DPAD",
				"scope": "normal",
				"types": [
					"number"
				],
				"from": "dojo/keys"
			}
		]
	},
	"dojo/string": {
		"location": "dojo/string",
		"type": "object",
		"summary": "<p>String utilities for Dojo</p>\n",
		"methods": [
			{
				"name": "pad",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "text",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the string to pad</p>\n"
					},
					{
						"name": "size",
						"types": [
							"Integer"
						],
						"usage": "required",
						"summary": "<p>length to provide padding</p>\n"
					},
					{
						"name": "ch",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>character to pad, defaults to &#39;0&#39;</p>\n"
					},
					{
						"name": "end",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>adds padding at the end if true, otherwise pads at start</p>\n"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Pad a string to guarantee that it is at least <code>size</code> length by\nfilling with the character <code>ch</code> at either the start or end of the\nstring. Pads at the start, by default.</p>\n",
				"examples": [
					"<pre><code>// Fill the string to length 10 with &quot;+&quot; characters on the right.  Yields &quot;Dojo++++++&quot;.\nstring.pad(&quot;Dojo&quot;, 10, &quot;+&quot;, true);</code></pre>\n"
				]
			},
			{
				"name": "rep",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the string to replicate</p>\n"
					},
					{
						"name": "num",
						"types": [
							"Integer"
						],
						"usage": "required",
						"summary": "<p>number of times to replicate the string</p>\n"
					}
				],
				"returnTypes": [
					"string",
					"undefined"
				],
				"summary": "<p>Efficiently replicate a string <code>n</code> times.</p>\n"
			},
			{
				"name": "substitute",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "template",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>a string with expressions in the form <code>${key}</code> to be replaced or\n<code>${key:format}</code> which specifies a format function. keys are case-sensitive.</p>\n"
					},
					{
						"name": "map",
						"types": [
							"Object",
							"Array"
						],
						"usage": "required",
						"summary": "<p>hash to search for substitutions</p>\n"
					},
					{
						"name": "transform",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>a function to process all parameters before substitution takes\nplace, e.g. mylib.encodeXML</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>where to look for optional format function; default to the global\nnamespace</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Performs parameterized substitutions on a string. Throws an\nexception if any parameter is unmatched.</p>\n",
				"examples": [
					"<p>Substitutes two expressions in a string from an Array or Object\n\n</p>\n<pre><code>// returns &quot;File &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\n// by providing substitution data in an Array\nstring.substitute(\n    &quot;File &#39;${0}&#39; is not found in directory &#39;${1}&#39;.&quot;,\n    [&quot;foo.html&quot;,&quot;/temp&quot;]\n);\n\n// also returns &quot;File &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\n// but provides substitution data in an Object structure.  Dotted\n// notation may be used to traverse the structure.\nstring.substitute(\n    &quot;File &#39;${name}&#39; is not found in directory &#39;${info.dir}&#39;.&quot;,\n    { name: &quot;foo.html&quot;, info: { dir: &quot;/temp&quot; } }\n);</code></pre>\n",
					"<p>Use a transform function to modify the values:\n\n</p>\n<pre><code>// returns &quot;file &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\nstring.substitute(\n    &quot;${0} is not found in ${1}.&quot;,\n    [&quot;foo.html&quot;,&quot;/temp&quot;],\n    function(str){\n        // try to figure out the type\n        var prefix = (str.charAt(0) == &quot;/&quot;) ? &quot;directory&quot;: &quot;file&quot;;\n        return prefix + &quot; &#39;&quot; + str + &quot;&#39;&quot;;\n    }\n);</code></pre>\n",
					"<p>Use a formatter\n\n</p>\n<pre><code>// returns &quot;thinger -- howdy&quot;\nstring.substitute(\n    &quot;${0:postfix}&quot;, [&quot;thinger&quot;], null, {\n        postfix: function(value, key){\n            return value + &quot; -- howdy&quot;;\n        }\n    }\n);</code></pre>\n"
				]
			},
			{
				"name": "trim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be trimmed</p>\n"
					}
				],
				"returnTypes": [
					"String",
					"string"
				],
				"returnDescription": "<p>Returns the trimmed string</p>\n",
				"summary": "<p>Trims whitespace from both sides of the string</p>\n",
				"description": "<p>This version of trim() was taken from <a href=\"http://blog.stevenlevithan.com/archives/faster-trim-javascript\">Steven Levithan&#39;s blog</a>.\nThe short yet performant version of this function is dojo.trim(),\nwhich is part of Dojo base.  Uses String.prototype.trim instead, if available.</p>\n"
			},
			{
				"name": "ucFirst",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/string",
				"extensionModule": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Makes the first letter of a string uppercase</p>\n"
			}
		]
	},
	"havok/widget/Modal": {
		"location": "havok/widget/Modal",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"dijit/_WidgetsInTemplateMixin",
			"havok/form/_FormMixin",
			"havok/widget/_HideableMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"description": "<p>Creates a modal. Use the show() and hide() methods to\niniitate and cancel.</p>\n",
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setTitleAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/Modal",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "button",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Modal",
				"summary": "<p>The button node that was clicked to close the modal.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "closeButtonTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Modal"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "footerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Modal"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_HideableMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/form/_FormMixin",
				"tags": [
					"readonly"
				],
				"summary": "<p>Will be &quot;Error&quot; if one or more of the child widgets has an invalid value,\n&quot;Incomplete&quot; if not all of the required child widgets are filled in.  Otherwise, &quot;&quot;,\nwhich indicates that the form is ready to be submitted.</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Modal"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDescendantFormWidgets",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "children",
						"types": [
							"dijit/_WidgetBase[]"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all form widget descendants, searching through non-form child widgets like BorderContainer</p>\n"
			},
			{
				"name": "_getInvalidWidgetsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Compute what this.state should be based on state of children</p>\n"
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns Object representing form values.   See description of <code>value</code> for details.</p>\n"
			},
			{
				"name": "_hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setContentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"private": true,
				"parameters": [
					{
						"name": "content",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setInputsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"havok/array"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPostActivityAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fill in form values from according to an Object (in the format returned by get(&#39;value&#39;))</p>\n"
			},
			{
				"name": "_show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "connectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "inStartup",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>You can call this function directly, ex. in the event that you\nprogrammatically add a widget to the form <em>after</em> the form has been\ninitialized.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "disconnectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Deprecated method.   Applications no longer need to call this.   Remove for 2.0.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "getValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::getValues() is deprecated. Use get('value') instead. -- will be removed in version: 2.0"
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Hide the modal. Calling this will resolve the deferred returned by show()</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "isValid",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if all of the widgets are valid.\nDeprecated, will be removed in 2.0.  Use get(&quot;state&quot;) instead.</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "reset",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "setValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::setValues() is deprecated. Use set('value', val) instead. -- will be removed in version: 2.0"
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"parameters": [
					{
						"name": "value",
						"types": [
							"object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined",
					"instance"
				],
				"returnDescription": "<p>A deferred that will resolve to the modal value when the\nmodal is hidden</p>\n",
				"summary": "<p>Display the modal\n</p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>returns if the form is valid - same as isValid - but\nprovides a few additional (ui-specific) features:\n\n</p>\n<ol>\n<li>it will highlight any sub-widgets that are not valid</li>\n<li>it will call focus() on the first invalid sub-widget</li>\n</ol>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onChildChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called when child&#39;s value or disabled state changes</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBackdropClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Event called by the template when the backdrop is clicked.</p>\n"
			},
			{
				"name": "onCloseClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onOkClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Modal",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onValidStateChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "isValid",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Stub function to connect to if you want to do something\n(like disable/enable a submit button) when the valid\nstate changes on the form as a whole.\n\n</p>\n<p>Deprecated.  Will be removed in 2.0.  Use watch(&quot;state&quot;, ...) instead.</p>\n"
			}
		]
	},
	"dojo/query": {
		"location": "dojo/query",
		"type": "function",
		"parameters": [
			{
				"name": "selector",
				"types": [
					"String"
				],
				"usage": "required",
				"summary": "<p>A CSS selector to search for.</p>\n"
			},
			{
				"name": "context",
				"types": [
					"String",
					"DomNode"
				],
				"usage": "optional",
				"summary": "<p>An optional context to limit the searching scope. Only nodes under <code>context</code> will be\nscanned.</p>\n"
			}
		],
		"returnTypes": [
			"instance"
		],
		"summary": "<p>This modules provides DOM querying functionality. The module export is a function\nthat can be used to query for DOM nodes by CSS selector and returns a NodeList\nrepresenting the matching nodes.</p>\n",
		"description": "<p>dojo/query is responsible for loading the appropriate query engine and wrapping\nits results with a <code>NodeList</code>. You can use dojo/query with a specific selector engine\nby using it as a plugin. For example, if you installed the sizzle package, you could\nuse it as the selector engine with:\n\n</p>\n<pre><code>require([&quot;dojo/query!sizzle&quot;], function(query){\n    query(&quot;div&quot;)...</code></pre>\n<p>The id after the ! can be a module id of the selector engine or one of the following values:\n\n</p>\n<ul>\n<li><p>acme: This is the default engine used by Dojo base, and will ensure that the full\nAcme engine is always loaded.</p>\n</li>\n<li><p>css2: If the browser has a native selector engine, this will be used, otherwise a\nvery minimal lightweight selector engine will be loaded that can do simple CSS2 selectors\n(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (&gt;)\noperators) and nothing more.</p>\n</li>\n<li><p>css2.1: If the browser has a native selector engine, this will be used, otherwise the\nfull Acme engine will be loaded.</p>\n</li>\n<li><p>css3: If the browser has a native selector engine with support for CSS3 pseudo\nselectors (most modern browsers except IE8), this will be used, otherwise the\nfull Acme engine will be loaded.</p>\n</li>\n<li><p>Or the module id of a selector engine can be used to explicitly choose the selector engine</p>\n</li>\n</ul>\n<p>For example, if you are using CSS3 pseudo selectors in module, you can specify that\nyou will need support them with:\n\n</p>\n<pre><code>require([&quot;dojo/query!css3&quot;], function(query){\n    query(&#39;#t &gt; h3:nth-child(odd)&#39;)...</code></pre>\n<p>You can also choose the selector engine/load configuration by setting the query-selector:\nFor example:\n\n</p>\n<pre><code>&lt;script data-dojo-config=&quot;query-selector:&#39;css3&#39;&quot; src=&quot;dojo.js&quot;&gt;&lt;/script&gt;</code></pre>\n",
		"examples": [
			"<p>add an onclick handler to every submit button in the document\nwhich causes the form to be sent via Ajax instead:\n\n</p>\n<pre><code>require([&quot;dojo/query&quot;], function(query){\n    query(&quot;input[type=&#39;submit&#39;]&quot;).on(&quot;click&quot;, function(e){\n        dojo.stopEvent(e); // prevent sending the form\n        var btn = e.target;\n        dojo.xhrPost({\n            form: btn.form,\n            load: function(data){\n                // replace the form with the response\n                var div = dojo.doc.createElement(&quot;div&quot;);\n                dojo.place(div, btn.form, &quot;after&quot;);\n                div.innerHTML = data;\n                dojo.style(btn.form, &quot;display&quot;, &quot;none&quot;);\n            }\n        });\n    });\n});</code></pre>\n"
		],
		"methods": [
			{
				"name": "_filterResult",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/query",
				"private": true,
				"parameters": [
					{
						"name": "nodes",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "selector",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "root",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/query",
				"parameters": [
					{
						"name": "selector",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A CSS selector to search for.</p>\n"
					},
					{
						"name": "context",
						"types": [
							"String",
							"DomNode"
						],
						"usage": "optional",
						"summary": "<p>An optional context to limit the searching scope. Only nodes under <code>context</code> will be\nscanned.</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>This modules provides DOM querying functionality. The module export is a function\nthat can be used to query for DOM nodes by CSS selector and returns a NodeList\nrepresenting the matching nodes.</p>\n",
				"description": "<p>dojo/query is responsible for loading the appropriate query engine and wrapping\nits results with a <code>NodeList</code>. You can use dojo/query with a specific selector engine\nby using it as a plugin. For example, if you installed the sizzle package, you could\nuse it as the selector engine with:\n\n</p>\n<pre><code>require([&quot;dojo/query!sizzle&quot;], function(query){\n    query(&quot;div&quot;)...</code></pre>\n<p>The id after the ! can be a module id of the selector engine or one of the following values:\n\n</p>\n<ul>\n<li><p>acme: This is the default engine used by Dojo base, and will ensure that the full\nAcme engine is always loaded.</p>\n</li>\n<li><p>css2: If the browser has a native selector engine, this will be used, otherwise a\nvery minimal lightweight selector engine will be loaded that can do simple CSS2 selectors\n(by #id, .class, tag, and [name=value] attributes, with standard child or descendant (&gt;)\noperators) and nothing more.</p>\n</li>\n<li><p>css2.1: If the browser has a native selector engine, this will be used, otherwise the\nfull Acme engine will be loaded.</p>\n</li>\n<li><p>css3: If the browser has a native selector engine with support for CSS3 pseudo\nselectors (most modern browsers except IE8), this will be used, otherwise the\nfull Acme engine will be loaded.</p>\n</li>\n<li><p>Or the module id of a selector engine can be used to explicitly choose the selector engine</p>\n</li>\n</ul>\n<p>For example, if you are using CSS3 pseudo selectors in module, you can specify that\nyou will need support them with:\n\n</p>\n<pre><code>require([&quot;dojo/query!css3&quot;], function(query){\n    query(&#39;#t &gt; h3:nth-child(odd)&#39;)...</code></pre>\n<p>You can also choose the selector engine/load configuration by setting the query-selector:\nFor example:\n\n</p>\n<pre><code>&lt;script data-dojo-config=&quot;query-selector:&#39;css3&#39;&quot; src=&quot;dojo.js&quot;&gt;&lt;/script&gt;</code></pre>\n",
				"examples": [
					"<p>add an onclick handler to every submit button in the document\nwhich causes the form to be sent via Ajax instead:\n\n</p>\n<pre><code>require([&quot;dojo/query&quot;], function(query){\n    query(&quot;input[type=&#39;submit&#39;]&quot;).on(&quot;click&quot;, function(e){\n        dojo.stopEvent(e); // prevent sending the form\n        var btn = e.target;\n        dojo.xhrPost({\n            form: btn.form,\n            load: function(data){\n                // replace the form with the response\n                var div = dojo.doc.createElement(&quot;div&quot;);\n                dojo.place(div, btn.form, &quot;after&quot;);\n                div.innerHTML = data;\n                dojo.style(btn.form, &quot;display&quot;, &quot;none&quot;);\n            }\n        });\n    });\n});</code></pre>\n"
				]
			},
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/query",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "parentRequire",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "loaded",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>can be used as AMD plugin to conditionally load new query engine</p>\n",
				"examples": [
					"<pre><code>require([&quot;dojo/query!custom&quot;], function(qsa){\n    // loaded selector/custom.js as engine\n    qsa(&quot;#foobar&quot;).forEach(...);\n});</code></pre>\n"
				]
			},
			{
				"name": "NodeList",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/query",
				"parameters": [
					{
						"name": "array",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Array-like object which adds syntactic\nsugar for chaining, common iteration operations, animation, and\nnode manipulation. NodeLists are most often returned as the\nresult of dojo.query() calls.</p>\n",
				"description": "<p>NodeList instances provide many utilities that reflect\ncore Dojo APIs for Array iteration and manipulation, DOM\nmanipulation, and event handling. Instead of needing to dig up\nfunctions in the dojo.* namespace, NodeLists generally make the\nfull power of Dojo available for DOM manipulation tasks in a\nsimple, chainable way.</p>\n",
				"examples": [
					"<p>create a node list from a node\n\n</p>\n<pre><code>new query.NodeList(dojo.byId(&quot;foo&quot;));</code></pre>\n",
					"<p>get a NodeList from a CSS query and iterate on it\n\n</p>\n<pre><code>var l = dojo.query(&quot;.thinger&quot;);\nl.forEach(function(node, index, nodeList){\n    console.log(index, node.innerHTML);\n});</code></pre>\n",
					"<p>use native and Dojo-provided array methods to manipulate a\nNodeList without needing to use dojo.* functions explicitly:\n\n</p>\n<pre><code>var l = dojo.query(&quot;.thinger&quot;);\n// since NodeLists are real arrays, they have a length\n// property that is both readable and writable and\n// push/pop/shift/unshift methods\nconsole.log(l.length);\nl.push(dojo.create(&quot;span&quot;));\n\n// dojo&#39;s normalized array methods work too:\nconsole.log( l.indexOf(dojo.byId(&quot;foo&quot;)) );\n// ...including the special &quot;function as string&quot; shorthand\nconsole.log( l.every(&quot;item.nodeType == 1&quot;) );\n\n// NodeLists can be [..] indexed, or you can use the at()\n// function to get specific items wrapped in a new NodeList:\nvar node = l[3]; // the 4th element\nvar newList = l.at(1, 3); // the 2nd and 4th elements</code></pre>\n",
					"<p>the style functions you expect are all there too:\n\n</p>\n<pre><code>// style() as a getter...\nvar borders = dojo.query(&quot;.thinger&quot;).style(&quot;border&quot;);\n// ...and as a setter:\ndojo.query(&quot;.thinger&quot;).style(&quot;border&quot;, &quot;1px solid black&quot;);\n// class manipulation\ndojo.query(&quot;li:nth-child(even)&quot;).addClass(&quot;even&quot;);\n// even getting the coordinates of all the items\nvar coords = dojo.query(&quot;.thinger&quot;).coords();</code></pre>\n",
					"<p>DOM manipulation functions from the dojo.* namespace area also available:\n\n</p>\n<pre><code>// remove all of the elements in the list from their\n// parents (akin to &quot;deleting&quot; them from the document)\ndojo.query(&quot;.thinger&quot;).orphan();\n// place all elements in the list at the front of #foo\ndojo.query(&quot;.thinger&quot;).place(&quot;foo&quot;, &quot;first&quot;);</code></pre>\n",
					"<p>Event handling couldn&#39;t be easier. <code>dojo.connect</code> is mapped in,\nand shortcut handlers are provided for most DOM events:\n\n</p>\n<pre><code>// like dojo.connect(), but with implicit scope\ndojo.query(&quot;li&quot;).connect(&quot;onclick&quot;, console, &quot;log&quot;);\n\n// many common event handlers are already available directly:\ndojo.query(&quot;li&quot;).onclick(console, &quot;log&quot;);\nvar toggleHovered = dojo.hitch(dojo, &quot;toggleClass&quot;, &quot;hovered&quot;);\ndojo.query(&quot;p&quot;)\n    .onmouseenter(toggleHovered)\n    .onmouseleave(toggleHovered);</code></pre>\n",
					"<p>chainability is a key advantage of NodeLists:\n\n</p>\n<pre><code>dojo.query(&quot;.thinger&quot;)\n    .onclick(function(e){ /* ... */ })\n    .at(1, 3, 8) // get a subset\n        .style(&quot;padding&quot;, &quot;5px&quot;)\n        .forEach(console.log);</code></pre>\n"
				]
			}
		]
	},
	"dojo/selector/_loader": {
		"location": "dojo/selector/_loader",
		"type": "object",
		"summary": "<p>This module handles loading the appropriate selector engine for the given browser</p>\n",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/selector/_loader",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "parentRequire",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "loaded",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "config",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"dojo/dom-class": {
		"location": "dojo/dom-class",
		"type": "object",
		"summary": "<p>This module defines the core dojo DOM class API.</p>\n",
		"methods": [
			{
				"name": "add",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-class",
				"parameters": [
					{
						"name": "node",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>String ID or DomNode reference to add a class string too\n</p>\n"
					},
					{
						"name": "classStr",
						"types": [
							"String",
							"Array"
						],
						"usage": "required",
						"summary": "<p>A String class name to add, or several space-separated class names,\nor an array of class names.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Adds the specified classes to the end of the class list on the\npassed node. Will not re-apply duplicate classes.\n</p>\n",
				"examples": [
					"<p>Add a class to some node:\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.add(&quot;someNode&quot;, &quot;anewClass&quot;);\n});</code></pre>\n",
					"<p>Add two classes at once:\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.add(&quot;someNode&quot;, &quot;firstClass secondClass&quot;);\n});</code></pre>\n",
					"<p>Add two classes at once (using array):\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.add(&quot;someNode&quot;, [&quot;firstClass&quot;, &quot;secondClass&quot;]);\n});</code></pre>\n",
					"<p>Available in <code>dojo/NodeList</code> for multiple additions\n\n</p>\n<pre><code>require([&quot;dojo/query&quot;], function(query){\n    query(&quot;ul &gt; li&quot;).addClass(&quot;firstLevel&quot;);\n});</code></pre>\n"
				]
			},
			{
				"name": "contains",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-class",
				"parameters": [
					{
						"name": "node",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>String ID or DomNode reference to check the class for.</p>\n"
					},
					{
						"name": "classStr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string class name to look for.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns whether or not the specified classes are a portion of the\nclass list currently applied to the node.</p>\n",
				"examples": [
					"<p>Do something if a node with id=&quot;someNode&quot; has class=&quot;aSillyClassName&quot; present\n\n</p>\n<pre><code>if(dojo.hasClass(&quot;someNode&quot;,&quot;aSillyClassName&quot;)){ ... }</code></pre>\n"
				]
			},
			{
				"name": "remove",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-class",
				"parameters": [
					{
						"name": "node",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>String ID or DomNode reference to remove the class from.\n</p>\n"
					},
					{
						"name": "classStr",
						"types": [
							"String",
							"Array"
						],
						"usage": "optional",
						"summary": "<p>An optional String class name to remove, or several space-separated\nclass names, or an array of class names. If omitted, all class names\nwill be deleted.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Removes the specified classes from node. No <code>contains()</code>\ncheck is required.\n</p>\n",
				"examples": [
					"<p>Remove a class from some node:\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.remove(&quot;someNode&quot;, &quot;firstClass&quot;);\n});</code></pre>\n",
					"<p>Remove two classes from some node:\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.remove(&quot;someNode&quot;, &quot;firstClass secondClass&quot;);\n});</code></pre>\n",
					"<p>Remove two classes from some node (using array):\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.remove(&quot;someNode&quot;, [&quot;firstClass&quot;, &quot;secondClass&quot;]);\n});</code></pre>\n",
					"<p>Remove all classes from some node:\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.remove(&quot;someNode&quot;);\n});</code></pre>\n",
					"<p>Available in <code>dojo/NodeList</code> for multiple removal\n\n</p>\n<pre><code>require([&quot;dojo/query&quot;], function(query){\n    query(&quot;ul &gt; li&quot;).removeClass(&quot;foo&quot;);\n});</code></pre>\n"
				]
			},
			{
				"name": "replace",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-class",
				"parameters": [
					{
						"name": "node",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>String ID or DomNode reference to remove the class from.\n</p>\n"
					},
					{
						"name": "addClassStr",
						"types": [
							"String",
							"Array"
						],
						"usage": "required",
						"summary": "<p>A String class name to add, or several space-separated class names,\nor an array of class names.\n</p>\n"
					},
					{
						"name": "removeClassStr",
						"types": [
							"String",
							"Array"
						],
						"usage": "optional",
						"summary": "<p>A String class name to remove, or several space-separated class names,\nor an array of class names.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Replaces one or more classes on a node if not present.\nOperates more quickly than calling dojo.removeClass and dojo.addClass\n</p>\n",
				"examples": [
					"<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.replace(&quot;someNode&quot;, &quot;add1 add2&quot;, &quot;remove1 remove2&quot;);\n});</code></pre>\n",
					"<p>Replace all classes with addMe\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.replace(&quot;someNode&quot;, &quot;addMe&quot;);\n});</code></pre>\n",
					"<p>Available in <code>dojo/NodeList</code> for multiple toggles\n\n</p>\n<pre><code>require([&quot;dojo/query&quot;], function(query){\n    query(&quot;.findMe&quot;).replaceClass(&quot;addMe&quot;, &quot;removeMe&quot;);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-class",
				"parameters": [
					{
						"name": "node",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>String ID or DomNode reference to toggle a class string\n</p>\n"
					},
					{
						"name": "classStr",
						"types": [
							"String",
							"Array"
						],
						"usage": "required",
						"summary": "<p>A String class name to toggle, or several space-separated class names,\nor an array of class names.\n</p>\n"
					},
					{
						"name": "condition",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If passed, true means to add the class, false means to remove.\nOtherwise dojo.hasClass(node, classStr) is used to detect the class presence.\n</p>\n"
					}
				],
				"returnTypes": [
					"Boolean"
				],
				"returnDescription": "<p>If passed, true means to add the class, false means to remove.\nOtherwise dojo.hasClass(node, classStr) is used to detect the class presence.\n</p>\n",
				"summary": "<p>Adds a class to node if not present, or removes if present.\nPass a boolean condition if you want to explicitly add or remove.\nReturns the condition that was specified directly or indirectly.\n</p>\n",
				"examples": [
					"<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.toggle(&quot;someNode&quot;, &quot;hovered&quot;);\n});</code></pre>\n",
					"<p>Forcefully add a class\n\n</p>\n<pre><code>require([&quot;dojo/dom-class&quot;], function(domClass){\n    domClass.toggle(&quot;someNode&quot;, &quot;hovered&quot;, true);\n});</code></pre>\n",
					"<p>Available in <code>dojo/NodeList</code> for multiple toggles\n\n</p>\n<pre><code>require([&quot;dojo/query&quot;], function(query){\n    query(&quot;.toggleMe&quot;).toggleClass(&quot;toggleMe&quot;);\n});</code></pre>\n"
				]
			}
		]
	},
	"dijit/registry": {
		"location": "dijit/registry",
		"type": "object",
		"summary": "<p>Registry of existing widget on page, plus some utility methods.</p>\n",
		"properties": [
			{
				"name": "_hash",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dijit/registry",
				"private": true
			},
			{
				"name": "length",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dijit/registry",
				"summary": "<p>Number of registered widgets</p>\n"
			}
		],
		"methods": [
			{
				"name": "_destroyAll",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Code to destroy all widgets and do other cleanup on page unload</p>\n"
			},
			{
				"name": "add",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "widget",
						"types": [
							"dijit/_WidgetBase"
						],
						"usage": "required",
						"summary": "<p>Any dijit/_WidgetBase subclass.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Add a widget to the registry. If a duplicate ID is detected, a error is thrown.</p>\n"
			},
			{
				"name": "byId",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "id",
						"types": [
							"String",
							"Widget"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String|Widget"
				],
				"summary": "<p>Find a widget by it&#39;s id.\nIf passed a widget then just returns the widget.</p>\n"
			},
			{
				"name": "byNode",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the widget corresponding to the given DOMNode</p>\n"
			},
			{
				"name": "findWidgets",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "root",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>Node to search under.</p>\n"
					},
					{
						"name": "skipNode",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>If specified, don&#39;t search beneath this node (usually containerNode).</p>\n"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Search subtree under root returning widgets found.\nDoesn&#39;t search for nested widgets (ie, widgets inside other widgets).</p>\n"
			},
			{
				"name": "getEnclosingWidget",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"null"
				],
				"summary": "<p>Returns the widget whose DOM tree contains the specified DOMNode, or null if\nthe node is not contained within the DOM tree of any widget</p>\n"
			},
			{
				"name": "getUniqueId",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "widgetType",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Generates a unique id for a given widgetType</p>\n"
			},
			{
				"name": "remove",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [
					{
						"name": "id",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Remove a widget from the registry. Does not destroy the widget; simply\nremoves the reference.</p>\n"
			},
			{
				"name": "toArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Convert registry into a true Array\n</p>\n",
				"examples": [
					"<p>Work with the widget .domNodes in a real Array\n\n</p>\n<pre><code>array.map(registry.toArray(), function(w){ return w.domNode; });</code></pre>\n"
				]
			}
		]
	},
	"dijit/registry._hash": {
		"location": "dijit/registry._hash",
		"type": "object"
	},
	"dijit/main": {
		"location": "dijit/main",
		"type": "object",
		"summary": "<p>The dijit package main module.\nDeprecated.   Users should access individual modules (ex: dijit/registry) directly.</p>\n",
		"properties": [
			{
				"name": "_activeStack",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dijit/registry",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "_curFocus",
				"scope": "normal",
				"types": [
					"null"
				],
				"from": "dijit/registry",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "_prevFocus",
				"scope": "normal",
				"types": [
					"null"
				],
				"from": "dijit/registry",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "registry",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"summary": "<p>Registry of existing widget on page, plus some utility methods.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_getTabNavigable",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Finds descendants of the specified root node.</p>\n",
				"description": "<p>Finds the following descendants of the specified root node:\n\n</p>\n<ul>\n<li>the first tab-navigable element in document order\nwithout a tabIndex or with tabIndex=&quot;0&quot;</li>\n<li>the last tab-navigable element in document order\nwithout a tabIndex or with tabIndex=&quot;0&quot;</li>\n<li>the first element in document order with the lowest\npositive tabIndex value</li>\n<li>the last element in document order with the highest\npositive tabIndex value</li>\n</ul>\n"
			},
			{
				"name": "_isElementShown",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"private": true,
				"extensionModule": true,
				"parameters": [
					{
						"name": "elem",
						"types": [
							"Element"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				]
			},
			{
				"name": "focus",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "getFirstInTabbingOrder",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"extensionModule": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Finds the descendant of the specified root node\nthat is first in the tabbing order</p>\n"
			},
			{
				"name": "getLastInTabbingOrder",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"extensionModule": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Finds the descendant of the specified root node\nthat is last in the tabbing order</p>\n"
			},
			{
				"name": "hasDefaultTabStop",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"extensionModule": true,
				"parameters": [
					{
						"name": "elem",
						"types": [
							"Element"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"boolean"
				],
				"summary": "<p>Tests if element is tab-navigable even without an explicit tabIndex setting</p>\n"
			},
			{
				"name": "isTabNavigable",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"extensionModule": true,
				"parameters": [
					{
						"name": "elem",
						"types": [
							"Element"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean",
					"undefined"
				],
				"summary": "<p>Tests if an element is tab-navigable</p>\n"
			}
		]
	},
	"dijit/main.registry": {
		"location": "dijit/main.registry",
		"type": "object",
		"summary": "<p>Registry of existing widget on page, plus some utility methods.</p>\n",
		"properties": [
			{
				"name": "_hash",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dijit/registry",
				"private": true,
				"extensionModule": true
			},
			{
				"name": "length",
				"scope": "normal",
				"types": [
					"Number"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"summary": "<p>Number of registered widgets</p>\n"
			}
		],
		"methods": [
			{
				"name": "_destroyAll",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"private": true,
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Code to destroy all widgets and do other cleanup on page unload</p>\n"
			},
			{
				"name": "add",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "widget",
						"types": [
							"dijit/_WidgetBase"
						],
						"usage": "required",
						"summary": "<p>Any dijit/_WidgetBase subclass.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Add a widget to the registry. If a duplicate ID is detected, a error is thrown.</p>\n"
			},
			{
				"name": "byId",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "id",
						"types": [
							"String",
							"Widget"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String|Widget"
				],
				"summary": "<p>Find a widget by it&#39;s id.\nIf passed a widget then just returns the widget.</p>\n"
			},
			{
				"name": "byNode",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the widget corresponding to the given DOMNode</p>\n"
			},
			{
				"name": "findWidgets",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>Node to search under.</p>\n"
					},
					{
						"name": "skipNode",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>If specified, don&#39;t search beneath this node (usually containerNode).</p>\n"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Search subtree under root returning widgets found.\nDoesn&#39;t search for nested widgets (ie, widgets inside other widgets).</p>\n"
			},
			{
				"name": "getEnclosingWidget",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"null"
				],
				"summary": "<p>Returns the widget whose DOM tree contains the specified DOMNode, or null if\nthe node is not contained within the DOM tree of any widget</p>\n"
			},
			{
				"name": "getUniqueId",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "widgetType",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Generates a unique id for a given widgetType</p>\n"
			},
			{
				"name": "remove",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [
					{
						"name": "id",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Remove a widget from the registry. Does not destroy the widget; simply\nremoves the reference.</p>\n"
			},
			{
				"name": "toArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/registry",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Convert registry into a true Array\n</p>\n",
				"examples": [
					"<p>Work with the widget .domNodes in a real Array\n\n</p>\n<pre><code>array.map(registry.toArray(), function(w){ return w.domNode; });</code></pre>\n"
				]
			}
		]
	},
	"havok/widget/_WidgetBase": {
		"location": "havok/widget/_WidgetBase",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/_WidgetBase",
		"mixins": [
			"dijit/_WidgetBase",
			"dijit/_TemplatedMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"dijit/_WidgetBase": {
		"location": "dijit/_WidgetBase",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/Stateful",
		"mixins": [
			"dojo/Stateful",
			"dijit/Destroyable"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Future base class for all Dijit widgets.</p>\n",
		"description": "<p>Future base class for all Dijit widgets.\n_Widget extends this class adding support for various features needed by desktop.\n\n</p>\n<p>Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),\npostCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().\n\n</p>\n<p>Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).\nFor an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().\n\n</p>\n<p>_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget&#39;s DOMNodes:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  _setFocusAttr: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\n  _setFocusAttr: &quot;focusNode&quot;  (shorthand)\n  _setFocusAttr: &quot;&quot;       (shorthand, maps to this.domNode)\nMaps this.focus to this.focusNode.focus, or (last example) this.domNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  _setTitleAttr: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  _setTitleAttr: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  _setMyClassAttr: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value of _setXXXAttr is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>If the custom setter is null, no action is performed other than saving the new value\nin the widget (in this).\n\n</p>\n<p>If no custom setter is defined for an attribute, then it will be copied\nto this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.\nThat&#39;s only done though for attributes that match DOMNode attributes (title,\nalt, aria-labelledby, etc.)</p>\n",
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "focused",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"extensionModule": true,
				"summary": "<p>This widget or a widget it contains has focus, or is &quot;active&quot; because\nit was recently clicked.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Construct the UI for this widget, setting this.domNode.\nMost widgets will mixin <code>dijit._TemplatedMixin</code>, which implements this method.</p>\n"
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they stop being active,\nsuch as changing CSS classes.  See onBlur() for more details.</p>\n"
			},
			{
				"name": "_onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they are active,\nsuch as changing CSS classes.  See onFocus() for more details.</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget stops being &quot;active&quot; because\nfocus moved to something outside of it, or the user\nclicked somewhere outside of it, or the widget was\nhidden.</p>\n"
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget becomes &quot;active&quot; because\nit or a widget inside of it either has focus, or has recently\nbeen clicked.</p>\n"
			}
		]
	},
	"dojo/ready": {
		"location": "dojo/ready",
		"type": "function",
		"parameters": [
			{
				"name": "priority",
				"types": [
					"Integer"
				],
				"usage": "optional",
				"summary": "<p>The order in which to exec this callback relative to other callbacks, defaults to 1000</p>\n"
			},
			{
				"name": "context",
				"types": [
					"undefined"
				],
				"usage": "required",
				"summary": "<p>The context in which to run execute callback, or a callback if not using context</p>\n"
			},
			{
				"name": "callback",
				"types": [
					"Function"
				],
				"usage": "optional",
				"summary": "<p>The function to execute.\n</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.\nIn most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed.\n\n</p>\n<p>When called in a non-browser environment, just checks that all requested modules have arrived and been\nevaluated.</p>\n",
		"examples": [
			"<p>Simple DOM and Modules ready syntax\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(function(){ alert(&quot;Dom ready!&quot;); });\n});</code></pre>\n",
			"<p>Using a priority\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(2, function(){ alert(&quot;low priority ready!&quot;); })\n});</code></pre>\n",
			"<p>Using context\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(foo, function(){\n        // in here, this == foo\n    });\n});</code></pre>\n",
			"<p>Using dojo/hitch style args:\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    var foo = { dojoReady: function(){ console.warn(this, &quot;dojo dom and modules ready.&quot;); } };\n    ready(foo, &quot;dojoReady&quot;);\n});</code></pre>\n"
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/ready",
				"parameters": [
					{
						"name": "priority",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The order in which to exec this callback relative to other callbacks, defaults to 1000</p>\n"
					},
					{
						"name": "context",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The context in which to run execute callback, or a callback if not using context</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>The function to execute.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Add a function to execute on DOM content loaded and all requested modules have arrived and been evaluated.\nIn most cases, the <code>domReady</code> plug-in should suffice and this method should not be needed.\n\n</p>\n<p>When called in a non-browser environment, just checks that all requested modules have arrived and been\nevaluated.</p>\n",
				"examples": [
					"<p>Simple DOM and Modules ready syntax\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(function(){ alert(&quot;Dom ready!&quot;); });\n});</code></pre>\n",
					"<p>Using a priority\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(2, function(){ alert(&quot;low priority ready!&quot;); })\n});</code></pre>\n",
					"<p>Using context\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    ready(foo, function(){\n        // in here, this == foo\n    });\n});</code></pre>\n",
					"<p>Using dojo/hitch style args:\n\n</p>\n<pre><code>require([&quot;dojo/ready&quot;], function(ready){\n    var foo = { dojoReady: function(){ console.warn(this, &quot;dojo dom and modules ready.&quot;); } };\n    ready(foo, &quot;dojoReady&quot;);\n});</code></pre>\n"
				]
			}
		]
	},
	"dijit/Destroyable": {
		"location": "dijit/Destroyable",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Mixin to track handles and release them when instance is destroyed.</p>\n",
		"description": "<p>Call this.own(...) on list of handles (returned from dojo/aspect, dojo/on,\ndojo/Stateful::watch, or any class (including widgets) with a destroyRecursive() or destroy() method.\nThen call destroy() later to destroy this instance and release the resources.</p>\n",
		"methods": [
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this class, releasing any resources registered via own().</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			}
		]
	},
	"dijit/_TemplatedMixin": {
		"location": "dijit/_TemplatedMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/_AttachMixin",
		"mixins": [
			"dijit/_AttachMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Mixin for widgets that are instantiated from a template</p>\n",
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_templateCache",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>A string that represents the widget template.\nUse in conjunction with dojo.cache() to load from a file.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Construct the UI for this widget from a template, setting this.domNode.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "getCachedTemplate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"parameters": [
					{
						"name": "templateString",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The template</p>\n"
					},
					{
						"name": "alwaysUseString",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>Don&#39;t cache the DOM tree for this template, even if it doesn&#39;t have any variables</p>\n"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional",
						"summary": "<p>The target document.   Defaults to document global if unspecified.</p>\n"
					}
				],
				"returnTypes": [
					"Mixed"
				],
				"returnDescription": "<p>Either string (if there are ${} variables that need to be replaced) or just\na DOM tree (if the node can be cloned directly)</p>\n",
				"summary": "<p>Static method to get a template based on the templatePath or\ntemplateString key</p>\n"
			}
		]
	},
	"dijit/_TemplatedMixin._templateCache": {
		"location": "dijit/_TemplatedMixin._templateCache",
		"type": "object"
	},
	"dojo/cache": {
		"location": "dojo/cache",
		"type": "function",
		"parameters": [
			{
				"name": "module",
				"types": [
					"String",
					"Object"
				],
				"usage": "required",
				"summary": "<p>dojo/number</p>\n"
			},
			{
				"name": "url",
				"types": [
					"String"
				],
				"usage": "required",
				"summary": "<p>The rest of the path to append to the path derived from the module argument. If\nmodule is an object, then this second argument should be the &quot;value&quot; argument instead.</p>\n"
			},
			{
				"name": "value",
				"types": [
					"String",
					"Object"
				],
				"usage": "optional",
				"summary": "<p>If a String, the value to use in the cache for the module/url combination.\nIf an Object, it can have two properties: value and sanitize. The value property\nshould be the value to use in the cache, and sanitize can be set to true or false,\nto indicate if XML declarations should be removed from the value and if the HTML\ninside a body tag in the value should be extracted as the real value. The value argument\nor the value property on the value argument are usually only used by the build system\nas it inlines cache content.</p>\n"
			}
		],
		"returnTypes": [
			"undefined",
			"null"
		],
		"summary": "<p>A getter and setter for storing the string content associated with the\nmodule and url arguments.</p>\n",
		"description": "<p>If module is a string that contains slashes, then it is interpretted as a fully\nresolved path (typically a result returned by require.toUrl), and url should not be\nprovided. This is the preferred signature. If module is a string that does not\ncontain slashes, then url must also be provided and module and url are used to\ncall <code>dojo.moduleUrl()</code> to generate a module URL. This signature is deprecated.\nIf value is specified, the cache value for the moduleUrl will be set to\nthat value. Otherwise, dojo.cache will fetch the moduleUrl and store it\nin its internal cache and return that cached value for the URL. To clear\na cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the\nthe URL contents, only modules on the same domain of the page can use this capability.\nThe build system can inline the cache values though, to allow for xdomain hosting.</p>\n",
		"examples": [
			"<p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&quot;cache&quot;] style\nof call is used to avoid an issue with the build system erroneously trying to intern\nthis example. To get the build system to intern your dojo.cache calls, use the\n&quot;dojo.cache&quot; style of call):\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot; that will be\n//the value for the text variable.\nvar text = dojo[&quot;cache&quot;](&quot;my.module&quot;, &quot;template.html&quot;);</code></pre>\n",
			"<p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input\n (the dojo[&quot;cache&quot;] style of call is used to avoid an issue with the build system\nerroneously trying to intern this example. To get the build system to intern your\ndojo.cache calls, use the &quot;dojo.cache&quot; style of call):\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the\n//text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.\nvar text = dojo[&quot;cache&quot;](&quot;my.module&quot;, &quot;template.html&quot;, {sanitize: true});</code></pre>\n",
			"<p>Same example as previous, but demonstrates how an object can be passed in as\nthe first argument, then the value argument can then be the second argument.\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the\n//text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.\nvar text = dojo[&quot;cache&quot;](new dojo._Url(&quot;my/module/template.html&quot;), {sanitize: true});</code></pre>\n"
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/text",
				"parameters": [
					{
						"name": "module",
						"types": [
							"String",
							"Object"
						],
						"usage": "required",
						"summary": "<p>dojo/number</p>\n"
					},
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The rest of the path to append to the path derived from the module argument. If\nmodule is an object, then this second argument should be the &quot;value&quot; argument instead.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "optional",
						"summary": "<p>If a String, the value to use in the cache for the module/url combination.\nIf an Object, it can have two properties: value and sanitize. The value property\nshould be the value to use in the cache, and sanitize can be set to true or false,\nto indicate if XML declarations should be removed from the value and if the HTML\ninside a body tag in the value should be extracted as the real value. The value argument\nor the value property on the value argument are usually only used by the build system\nas it inlines cache content.</p>\n"
					}
				],
				"returnTypes": [
					"undefined",
					"null"
				],
				"summary": "<p>A getter and setter for storing the string content associated with the\nmodule and url arguments.</p>\n",
				"description": "<p>If module is a string that contains slashes, then it is interpretted as a fully\nresolved path (typically a result returned by require.toUrl), and url should not be\nprovided. This is the preferred signature. If module is a string that does not\ncontain slashes, then url must also be provided and module and url are used to\ncall <code>dojo.moduleUrl()</code> to generate a module URL. This signature is deprecated.\nIf value is specified, the cache value for the moduleUrl will be set to\nthat value. Otherwise, dojo.cache will fetch the moduleUrl and store it\nin its internal cache and return that cached value for the URL. To clear\na cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the\nthe URL contents, only modules on the same domain of the page can use this capability.\nThe build system can inline the cache values though, to allow for xdomain hosting.</p>\n",
				"examples": [
					"<p>To ask dojo.cache to fetch content and store it in the cache (the dojo[&quot;cache&quot;] style\nof call is used to avoid an issue with the build system erroneously trying to intern\nthis example. To get the build system to intern your dojo.cache calls, use the\n&quot;dojo.cache&quot; style of call):\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot; that will be\n//the value for the text variable.\nvar text = dojo[&quot;cache&quot;](&quot;my.module&quot;, &quot;template.html&quot;);</code></pre>\n",
					"<p>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input\n (the dojo[&quot;cache&quot;] style of call is used to avoid an issue with the build system\nerroneously trying to intern this example. To get the build system to intern your\ndojo.cache calls, use the &quot;dojo.cache&quot; style of call):\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the\n//text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.\nvar text = dojo[&quot;cache&quot;](&quot;my.module&quot;, &quot;template.html&quot;, {sanitize: true});</code></pre>\n",
					"<p>Same example as previous, but demonstrates how an object can be passed in as\nthe first argument, then the value argument can then be the second argument.\n\n</p>\n<pre><code>//If template.html contains &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;, the\n//text variable will contain just &quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;.\nvar text = dojo[&quot;cache&quot;](new dojo._Url(&quot;my/module/template.html&quot;), {sanitize: true});</code></pre>\n"
				]
			}
		]
	},
	"dojo/text": {
		"location": "dojo/text",
		"type": "object",
		"summary": "<p>This module implements the dojo/text! plugin and the dojo.cache API.</p>\n",
		"description": "<p>We choose to include our own plugin to leverage functionality already contained in dojo\nand thereby reduce the size of the plugin compared to various foreign loader implementations.\nAlso, this allows foreign AMD loaders to be used without their plugins.\n\n</p>\n<p>CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous\nloader. This feature is outside the scope of the CommonJS plugins specification.</p>\n",
		"properties": [
			{
				"name": "dynamic",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/text"
			}
		],
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/text",
				"parameters": [
					{
						"name": "id",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Path to the resource.</p>\n"
					},
					{
						"name": "require",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Object that include the function toUrl with given id returns a valid URL from which to load the text.</p>\n"
					},
					{
						"name": "load",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function which will be called, when the loading finished.</p>\n"
					}
				],
				"returnTypes": []
			},
			{
				"name": "normalize",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/text",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "toAbsMid",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			}
		]
	},
	"dijit/_AttachMixin": {
		"location": "dijit/_AttachMixin",
		"type": "constructor",
		"classlike": true,
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Mixin for widgets to attach to dom nodes and setup events via\nconvenient data-dojo-attach-point and data-dojo-attach-event DOM attributes.\n\n</p>\n<p>Superclass of _TemplatedMixin, and can also be used standalone when templates are pre-rendered on the\nserver.\n\n</p>\n<p>Does not [yet] handle widgets like ContentPane with this.containerNode set.   It should skip\nscanning for data-dojo-attach-point and data-dojo-attach-event inside this.containerNode, but it\ndoesn&#39;t.</p>\n",
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Search descendants of this.containerNode for data-dojo-attach-point and data-dojo-attach-event.\nShould generally be left false (the default value) both for performance and to avoid failures when\nthis.containerNode holds other _AttachMixin instances with their own attach points and events.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Attach to DOM nodes marked with special attributes.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/touch": {
		"location": "dojo/touch",
		"type": "object",
		"summary": "<p>This module provides unified touch event handlers by exporting\npress, move, release and cancel which can also run well on desktop.\nBased on <a href=\"http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html\">http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html</a>\nAlso, if the dojoClick property is set to true on a DOM node, dojo/touch generates\nclick events immediately for this node and its descendants, to avoid the\ndelay before native browser click events, and regardless of whether evt.preventDefault()\nwas called in a touch.press event listener.\n</p>\n",
		"examples": [
			"<p>Used with dojo.on\n\n</p>\n<pre><code>define([&quot;dojo/on&quot;, &quot;dojo/touch&quot;], function(on, touch){\n    on(node, touch.press, function(e){});\n    on(node, touch.move, function(e){});\n    on(node, touch.release, function(e){});\n    on(node, touch.cancel, function(e){});</code></pre>\n",
			"<p>Used with touch.* directly\n\n</p>\n<pre><code>touch.press(node, function(e){});\ntouch.move(node, function(e){});\ntouch.release(node, function(e){});\ntouch.cancel(node, function(e){});</code></pre>\n",
			"<p>Have dojo/touch generate clicks without delay, with a default move threshold of 4 pixels\n\n</p>\n<pre><code>node.dojoClick = true;</code></pre>\n",
			"<p>Have dojo/touch generate clicks without delay, with a move threshold of 10 pixels horizontally and vertically\n\n</p>\n<pre><code>node.dojoClick = 10;</code></pre>\n",
			"<p>Have dojo/touch generate clicks without delay, with a move threshold of 50 pixels horizontally and 10 pixels vertically\n\n</p>\n<pre><code>node.dojoClick = {x:50, y:5};</code></pre>\n"
		],
		"methods": [
			{
				"name": "cancel",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;touchcancel&#39;|&#39;mouseleave&#39; for the given node</p>\n"
			},
			{
				"name": "enter",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to mouse.enter or touch equivalent for the given node</p>\n"
			},
			{
				"name": "leave",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to mouse.leave or touch equivalent for the given node</p>\n"
			},
			{
				"name": "move",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener that fires when the mouse cursor or a finger is dragged over the given node.</p>\n"
			},
			{
				"name": "out",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;mouseout&#39; or touch equivalent for the given node</p>\n"
			},
			{
				"name": "over",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;mouseover&#39; or touch equivalent for the given node</p>\n"
			},
			{
				"name": "press",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to &#39;touchstart&#39;|&#39;mousedown&#39; for the given node</p>\n"
			},
			{
				"name": "release",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/touch",
				"parameters": [
					{
						"name": "node",
						"types": [
							"Dom"
						],
						"usage": "required",
						"summary": "<p>Target node to listen to</p>\n"
					},
					{
						"name": "listener",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Callback function</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A handle which will be used to remove the listener by handle.remove()</p>\n",
				"summary": "<p>Register a listener to releasing the mouse button while the cursor is over the given node\n(i.e. &quot;mouseup&quot;) or for removing the finger from the screen while touching the given node.</p>\n"
			}
		]
	},
	"dojo/domReady": {
		"location": "dojo/domReady",
		"type": "function",
		"parameters": [
			{
				"name": "callback",
				"types": [
					"undefined"
				],
				"usage": "required"
			}
		],
		"returnTypes": [],
		"summary": "<p>Plugin to delay require()/define() callback from firing until the DOM has finished loading.</p>\n",
		"properties": [
			{
				"name": "_Q",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/domReady",
				"private": true
			}
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/domReady",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Plugin to delay require()/define() callback from firing until the DOM has finished loading.</p>\n"
			},
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/domReady",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "req",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "load",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onQEmpty",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/domReady",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Private method overridden by dojo/ready, to notify when everything in the\ndomReady queue has been processed.  Do not use directly.\nWill be removed in 2.0, along with domReady._Q.</p>\n"
			}
		]
	},
	"dijit/_WidgetsInTemplateMixin": {
		"location": "dijit/_WidgetsInTemplateMixin",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Mixin to supplement _TemplatedMixin when template contains widgets</p>\n",
		"properties": [
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "attachFunc",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean",
					"undefined"
				]
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/parser": {
		"location": "dojo/parser",
		"type": "object",
		"summary": "<p>The Dom/Widget parsing package</p>\n",
		"methods": [
			{
				"name": "_clearCache",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Clear cached data.   Used mainly for benchmarking.</p>\n"
			},
			{
				"name": "_functionFromScript",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"parameters": [
					{
						"name": "script",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The <code>&lt;script&gt;</code> DOMNode</p>\n"
					},
					{
						"name": "attrData",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>For HTML5 compliance, searches for attrData + &quot;args&quot; (typically\n&quot;data-dojo-args&quot;) instead of &quot;args&quot;</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Convert a <code>&lt;script type=&quot;dojo/method&quot; args=&quot;a, b, c&quot;&gt; ... &lt;/script&gt;</code>\ninto a function</p>\n"
			},
			{
				"name": "_instantiate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"parameters": [
					{
						"name": "nodes",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>Array of objects like\n\n</p>\n<pre><code>{\n    ctor: Function (may be null)\n    types: [&quot;dijit/form/Button&quot;, &quot;acme/MyMixin&quot;] (used if ctor not specified)\n    node: DOMNode,\n    scripts: [ ... ],   // array of &lt;script type=&quot;dojo/...&quot;&gt; children of node\n    inherited: { ... }  // settings inherited from ancestors like dir, theme, etc.\n}</code></pre>\n"
					},
					{
						"name": "mixin",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An object that will be mixed in with each node in the array.\nValues in the mixin will override values in the node, if they\nexist.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>An options object used to hold kwArgs for instantiation.\nSee parse.options argument for details.</p>\n"
					},
					{
						"name": "returnPromise",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>Return a Promise rather than the instance; supports asynchronous widget creation.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Array of instances, or if returnPromise is true, a promise for array of instances\nthat resolves when instances have finished initializing.</p>\n",
				"summary": "<p>Takes array of objects representing nodes, and turns them into class instances and\npotentially calls a startup method to allow them to connect with\nany children.</p>\n"
			},
			{
				"name": "_require",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"parameters": [
					{
						"name": "script",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper for _scanAMD().  Takes a <code>&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;</code> node,\ncalls require() to load the specified modules and (asynchronously) assign them to the specified global\nvariables, and returns a Promise for when that operation completes.\n\n</p>\n<p>In the example above, it is effectively doing a require([&quot;acme/bar&quot;, ...], function(a){ bar = a; }).</p>\n"
			},
			{
				"name": "_scanAmd",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"private": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to base the scan from.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>a kwArgs options object, see parse() for details</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Scans the DOM for any declarative requires and returns their values.</p>\n",
				"description": "<p>Looks for <code>&lt;script type=dojo/require&gt;bar: &quot;acme/bar&quot;, ...&lt;/script&gt;</code> node, calls require() to load the\nspecified modules and (asynchronously) assign them to the specified global variables,\nand returns a Promise for when those operations complete.</p>\n"
			},
			{
				"name": "construct",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"parameters": [
					{
						"name": "ctor",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Widget constructor.</p>\n"
					},
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>This node will be replaced/attached to by the widget.  It also specifies the arguments to pass to ctor.</p>\n"
					},
					{
						"name": "mixin",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Attributes in this object will be passed as parameters to ctor,\noverriding attributes specified on the node.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An options object used to hold kwArgs for instantiation.   See parse.options argument for details.</p>\n"
					},
					{
						"name": "scripts",
						"types": [
							"DomNode[]"
						],
						"usage": "optional",
						"summary": "<p>Array of <code>&lt;script type=&quot;dojo/*&quot;&gt;</code> DOMNodes.  If not specified, will search for <code>&lt;script&gt;</code> tags inside node.</p>\n"
					},
					{
						"name": "inherited",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Settings from dir=rtl or lang=... on a node above this node.   Overrides options.inherited.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Instance or Promise for the instance, if markupFactory() itself returned a promise</p>\n",
				"summary": "<p>Calls new ctor(params, node), where params is the hash of parameters specified on the node,\nexcluding data-dojo-type and data-dojo-mixins.   Does not call startup().</p>\n"
			},
			{
				"name": "instantiate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"parameters": [
					{
						"name": "nodes",
						"types": [
							"Array"
						],
						"usage": "required",
						"summary": "<p>Array of DOM nodes</p>\n"
					},
					{
						"name": "mixin",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An object that will be mixed in with each node in the array.\nValues in the mixin will override values in the node, if they\nexist.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>An object used to hold kwArgs for instantiation.\nSee parse.options argument for details.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Array of instances.</p>\n",
				"summary": "<p>Takes array of nodes, and turns them into class instances and\npotentially calls a startup method to allow them to connect with\nany children.</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "optional",
						"summary": "<p>A default starting root node from which to start the parsing. Can be\nomitted, defaulting to the entire document. If omitted, the <code>options</code>\nobject can be passed in this place. If the <code>options</code> object has a\n<code>rootNode</code> member, that is used.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>A hash of options.\n\n</p>\n<ul>\n<li>noStart: Boolean?:\n  when set will prevent the parser from calling .startup()\n  when locating the nodes.</li>\n<li>rootNode: DomNode?:\n  identical to the function&#39;s <code>rootNode</code> argument, though\n  allowed to be passed in via this `options object.</li>\n<li>template: Boolean:\n  If true, ignores ContentPane&#39;s stopParser flag and parses contents inside of\n  a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes\n  nested inside the ContentPane to work.</li>\n<li>inherited: Object:\n  Hash possibly containing dir and lang settings to be applied to\n  parsed widgets, unless there&#39;s another setting on a sub-node that overrides</li>\n<li>scope: String:\n  Root for attribute names to search for.   If scopeName is dojo,\n  will search for data-dojo-type (or dojoType).   For backwards compatibility\n  reasons defaults to dojo._scopeName (which is &quot;dojo&quot; except when\n  multi-version support is used, when it will be something like dojo16, dojo20, etc.)</li>\n<li>propsThis: Object:\n  If specified, &quot;this&quot; referenced from data-dojo-props will refer to propsThis.\n  Intended for use from the widgets-in-template feature of <code>dijit._WidgetsInTemplateMixin</code></li>\n<li>contextRequire: Function:\n  If specified, this require is utilised for looking resolving modules instead of the\n  <code>dojo/parser</code> context <code>require()</code>.  Intended for use from the widgets-in-template feature of\n  <code>dijit._WidgetsInTemplateMixin</code>.</li>\n</ul>\n"
					}
				],
				"returnTypes": [
					"Mixed",
					"Array"
				],
				"returnDescription": "<p>Returns a blended object that is an array of the instantiated objects, but also can include\na promise that is resolved with the instantiated objects.  This is done for backwards\ncompatibility.  If the parser auto-requires modules, it will always behave in a promise\nfashion and <code>parser.parse().then(function(instances){...})</code> should be used.</p>\n",
				"summary": "<p>Scan the DOM for class instances, and instantiate them.</p>\n",
				"description": "<p>Search specified node (or root node) recursively for class instances,\nand instantiate them. Searches for either data-dojo-type=&quot;Class&quot; or\ndojoType=&quot;Class&quot; where &quot;Class&quot; is a a fully qualified class name,\nlike <code>dijit/form/Button</code>\n\n</p>\n<p>Using <code>data-dojo-type</code>:\nAttributes using can be mixed into the parameters used to instantiate the\nClass by using a <code>data-dojo-props</code> attribute on the node being converted.\n<code>data-dojo-props</code> should be a string attribute to be converted from JSON.\n\n</p>\n<p>Using <code>dojoType</code>:\nAttributes are read from the original domNode and converted to appropriate\ntypes by looking up the Class prototype values. This is the default behavior\nfrom Dojo 1.0 to Dojo 1.5. <code>dojoType</code> support is deprecated, and will\ngo away in Dojo 2.0.</p>\n",
				"examples": [
					"<p>Parse all widgets on a page:\n\n</p>\n<pre><code>parser.parse();</code></pre>\n",
					"<p>Parse all classes within the node with id=&quot;foo&quot;\n\n</p>\n<pre><code>parser.parse(dojo.byId(&#39;foo&#39;));</code></pre>\n",
					"<p>Parse all classes in a page, but do not call .startup() on any\nchild\n\n</p>\n<pre><code>parser.parse({ noStart: true })</code></pre>\n",
					"<p>Parse all classes in a node, but do not call .startup()\n\n</p>\n<pre><code>parser.parse(someNode, { noStart:true });\n// or\nparser.parse({ noStart:true, rootNode: someNode });</code></pre>\n"
				]
			},
			{
				"name": "scan",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/parser",
				"parameters": [
					{
						"name": "root",
						"types": [
							"DomNode"
						],
						"usage": "optional",
						"summary": "<p>A default starting root node from which to start the parsing. Can be\nomitted, defaulting to the entire document. If omitted, the <code>options</code>\nobject can be passed in this place. If the <code>options</code> object has a\n<code>rootNode</code> member, that is used.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>a kwArgs options object, see parse() for details\n</p>\n"
					}
				],
				"returnTypes": [
					"Promise",
					"undefined"
				],
				"returnDescription": "<p>A promise that is resolved with the nodes that have been parsed.</p>\n",
				"summary": "<p>Scan a DOM tree and return an array of objects representing the DOMNodes\nthat need to be turned into widgets.</p>\n",
				"description": "<p>Search specified node (or document root node) recursively for class instances\nand return an array of objects that represent potential widgets to be\ninstantiated. Searches for either data-dojo-type=&quot;MID&quot; or dojoType=&quot;MID&quot; where\n&quot;MID&quot; is a module ID like &quot;dijit/form/Button&quot; or a fully qualified Class name\nlike &quot;dijit/form/Button&quot;.  If the MID is not currently available, scan will\nattempt to require() in the module.\n\n</p>\n<p>See parser.parse() for details of markup.</p>\n"
			}
		]
	},
	"dojo/_base/url": {
		"location": "dojo/_base/url",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"properties": [
			{
				"name": "authority",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "fragment",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "host",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "password",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "path",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "port",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "query",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "scheme",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "uri",
				"scope": "normal",
				"types": [
					"undefined"
				],
				"from": "dojo/_base/url"
			},
			{
				"name": "user",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/url"
			}
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/url",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/url",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/_base/url.scheme": {
		"location": "dojo/_base/url.scheme",
		"type": "object"
	},
	"dojo/_base/url.authority": {
		"location": "dojo/_base/url.authority",
		"type": "object"
	},
	"dojo/_base/url.query": {
		"location": "dojo/_base/url.query",
		"type": "object"
	},
	"dojo/_base/url.fragment": {
		"location": "dojo/_base/url.fragment",
		"type": "object"
	},
	"dojo/_base/url.user": {
		"location": "dojo/_base/url.user",
		"type": "object"
	},
	"dojo/_base/url.password": {
		"location": "dojo/_base/url.password",
		"type": "object"
	},
	"dojo/_base/url.port": {
		"location": "dojo/_base/url.port",
		"type": "object"
	},
	"dojo/promise/all": {
		"location": "dojo/promise/all",
		"type": "function",
		"parameters": [
			{
				"name": "objectOrArray",
				"types": [
					"Object",
					"Array"
				],
				"usage": "optional",
				"summary": "<p>The promise will be fulfilled with a list of results if invoked with an\narray, or an object of results when passed an object (using the same\nkeys). If passed neither an object or array it is resolved with an\nundefined value.</p>\n"
			}
		],
		"returnTypes": [
			"dojo/promise/Promise",
			"undefined"
		],
		"summary": "<p>Takes multiple promises and returns a new promise that is fulfilled\nwhen all promises have been fulfilled.</p>\n",
		"description": "<p>Takes multiple promises and returns a new promise that is fulfilled\nwhen all promises have been fulfilled. If one of the promises is rejected,\nthe returned promise is also rejected. Canceling the returned promise will\n<em>not</em> cancel any passed promises.</p>\n",
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/all",
				"parameters": [
					{
						"name": "objectOrArray",
						"types": [
							"Object",
							"Array"
						],
						"usage": "optional",
						"summary": "<p>The promise will be fulfilled with a list of results if invoked with an\narray, or an object of results when passed an object (using the same\nkeys). If passed neither an object or array it is resolved with an\nundefined value.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"summary": "<p>Takes multiple promises and returns a new promise that is fulfilled\nwhen all promises have been fulfilled.</p>\n",
				"description": "<p>Takes multiple promises and returns a new promise that is fulfilled\nwhen all promises have been fulfilled. If one of the promises is rejected,\nthe returned promise is also rejected. Canceling the returned promise will\n<em>not</em> cancel any passed promises.</p>\n"
			}
		]
	},
	"dojo/date/stamp": {
		"location": "dojo/date/stamp",
		"type": "object",
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "fromISOString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/stamp",
				"parameters": [
					{
						"name": "formattedString",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00</p>\n"
					},
					{
						"name": "defaultTime",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>Used for defaults for fields omitted in the formattedString.\nUses 1970-01-01T00:00:00.0Z by default.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.\n</p>\n",
				"description": "<p>Accepts a string formatted according to a profile of ISO8601 as defined by\n<a href=\"http://www.ietf.org/rfc/rfc3339.txt\">RFC3339</a>, except that partial input is allowed.\nCan also process dates as specified <a href=\"http://www.w3.org/TR/NOTE-datetime\">by the W3C</a>\nThe following combinations are valid:\n\n</p>\n<ul>\n<li>dates only<ul>\n<li>yyyy</li>\n<li>yyyy-MM</li>\n<li>yyyy-MM-dd</li>\n</ul>\n</li>\n<li>times only, with an optional time zone appended<ul>\n<li>THH:mm</li>\n<li>THH:mm:ss</li>\n<li>THH:mm:ss.SSS</li>\n</ul>\n</li>\n<li>and &quot;datetimes&quot; which could be any combination of the above</li>\n</ul>\n<p>timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm\nAssumes the local time zone if not specified.  Does not validate.  Improperly formatted\ninput may return null.  Arguments which are out of bounds will be handled\nby the Date constructor (e.g. January 32nd typically gets resolved to February 1st)\nOnly years between 100 and 9999 are supported.</p>\n"
			},
			{
				"name": "toISOString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/stamp",
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>A Date object</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>selector (String): <p>&quot;date&quot; or &quot;time&quot; for partial formatting of the Date object.\nBoth date and time will be formatted by default.</p>\n</li><li>zulu (Boolean): <p>if true, UTC/GMT is used for a timezone</p>\n</li><li>milliseconds (Boolean): <p>if true, output milliseconds</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Format a Date object as a string according a subset of the ISO-8601 standard\n</p>\n",
				"description": "<p>When options.selector is omitted, output follows <a href=\"http://www.ietf.org/rfc/rfc3339.txt\">RFC3339</a>\nThe local time zone is included as an offset from GMT, except when selector==&#39;time&#39; (time without a date)\nDoes not check bounds.  Only years between 100 and 9999 are supported.\n</p>\n"
			}
		]
	},
	"havok/form/_FormMixin": {
		"location": "havok/form/_FormMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/form/_FormMixin",
		"mixins": [
			"dijit/form/_FormMixin"
		],
		"properties": [
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/form/_FormMixin",
				"tags": [
					"readonly"
				],
				"summary": "<p>Will be &quot;Error&quot; if one or more of the child widgets has an invalid value,\n&quot;Incomplete&quot; if not all of the required child widgets are filled in.  Otherwise, &quot;&quot;,\nwhich indicates that the form is ready to be submitted.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_getDescendantFormWidgets",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "children",
						"types": [
							"dijit/_WidgetBase[]"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all form widget descendants, searching through non-form child widgets like BorderContainer</p>\n"
			},
			{
				"name": "_getInvalidWidgetsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Compute what this.state should be based on state of children</p>\n"
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns Object representing form values.   See description of <code>value</code> for details.</p>\n"
			},
			{
				"name": "_setInputsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"havok/array"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPostActivityAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fill in form values from according to an Object (in the format returned by get(&#39;value&#39;))</p>\n"
			},
			{
				"name": "connectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "inStartup",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>You can call this function directly, ex. in the event that you\nprogrammatically add a widget to the form <em>after</em> the form has been\ninitialized.</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "disconnectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Deprecated method.   Applications no longer need to call this.   Remove for 2.0.</p>\n"
			},
			{
				"name": "getValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::getValues() is deprecated. Use get('value') instead. -- will be removed in version: 2.0"
			},
			{
				"name": "isValid",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if all of the widgets are valid.\nDeprecated, will be removed in 2.0.  Use get(&quot;state&quot;) instead.</p>\n"
			},
			{
				"name": "reset",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "setValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::setValues() is deprecated. Use set('value', val) instead. -- will be removed in version: 2.0"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>returns if the form is valid - same as isValid - but\nprovides a few additional (ui-specific) features:\n\n</p>\n<ol>\n<li>it will highlight any sub-widgets that are not valid</li>\n<li>it will call focus() on the first invalid sub-widget</li>\n</ol>\n"
			}
		],
		"events": [
			{
				"name": "_onChildChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called when child&#39;s value or disabled state changes</p>\n"
			},
			{
				"name": "onValidStateChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "isValid",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Stub function to connect to if you want to do something\n(like disable/enable a submit button) when the valid\nstate changes on the form as a whole.\n\n</p>\n<p>Deprecated.  Will be removed in 2.0.  Use watch(&quot;state&quot;, ...) instead.</p>\n"
			}
		]
	},
	"dijit/form/_FormMixin": {
		"location": "dijit/form/_FormMixin",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Mixin for containers of form widgets (i.e. widgets that represent a single value\nand can be children of a <code>&lt;form&gt;</code> node or <code>dijit/form/Form</code> widget)</p>\n",
		"description": "<p>Can extract all the form widgets\nvalues and combine them into a single javascript object, or alternately\ntake such an object and set the values for all the contained\nform widgets</p>\n",
		"properties": [
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/form/_FormMixin",
				"tags": [
					"readonly"
				],
				"summary": "<p>Will be &quot;Error&quot; if one or more of the child widgets has an invalid value,\n&quot;Incomplete&quot; if not all of the required child widgets are filled in.  Otherwise, &quot;&quot;,\nwhich indicates that the form is ready to be submitted.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_getDescendantFormWidgets",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "children",
						"types": [
							"dijit/_WidgetBase[]"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all form widget descendants, searching through non-form child widgets like BorderContainer</p>\n"
			},
			{
				"name": "_getState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Compute what this.state should be based on state of children</p>\n"
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns Object representing form values.   See description of <code>value</code> for details.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fill in form values from according to an Object (in the format returned by get(&#39;value&#39;))</p>\n"
			},
			{
				"name": "connectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "inStartup",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>You can call this function directly, ex. in the event that you\nprogrammatically add a widget to the form <em>after</em> the form has been\ninitialized.</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "disconnectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Deprecated method.   Applications no longer need to call this.   Remove for 2.0.</p>\n"
			},
			{
				"name": "getValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::getValues() is deprecated. Use get('value') instead. -- will be removed in version: 2.0"
			},
			{
				"name": "isValid",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if all of the widgets are valid.\nDeprecated, will be removed in 2.0.  Use get(&quot;state&quot;) instead.</p>\n"
			},
			{
				"name": "reset",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "setValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::setValues() is deprecated. Use set('value', val) instead. -- will be removed in version: 2.0"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>returns if the form is valid - same as isValid - but\nprovides a few additional (ui-specific) features:\n\n</p>\n<ol>\n<li>it will highlight any sub-widgets that are not valid</li>\n<li>it will call focus() on the first invalid sub-widget</li>\n</ol>\n"
			}
		],
		"events": [
			{
				"name": "_onChildChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called when child&#39;s value or disabled state changes</p>\n"
			},
			{
				"name": "onValidStateChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "isValid",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Stub function to connect to if you want to do something\n(like disable/enable a submit button) when the valid\nstate changes on the form as a whole.\n\n</p>\n<p>Deprecated.  Will be removed in 2.0.  Use watch(&quot;state&quot;, ...) instead.</p>\n"
			}
		]
	},
	"dojo/window": {
		"location": "dojo/window",
		"type": "object",
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/window",
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "required",
						"summary": "<p>The document to get the associated window for.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get window object associated with document doc.</p>\n"
			},
			{
				"name": "getBox",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/window",
				"parameters": [
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns the dimensions and scroll position of the viewable area of a browser window</p>\n"
			},
			{
				"name": "scrollIntoView",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/window",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DomNode"
						],
						"usage": "required"
					},
					{
						"name": "pos",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Scroll the passed node into view using minimal movement, if it is not already.</p>\n"
			}
		]
	},
	"havok/widget/_HideableMixin": {
		"location": "havok/widget/_HideableMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_HideableMixin"
			}
		],
		"methods": [
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/Button": {
		"location": "havok/widget/Button",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_KeypressMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "keyTarget",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/_KeypressMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Button"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_resetKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setKeysAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setKeyTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Button",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/_KeypressMixin": {
		"location": "havok/widget/_KeypressMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "keyTarget",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/_KeypressMixin"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_removeKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_resetKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setKeysAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setKeyTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/filter/Base": {
		"location": "havok/filter/Base",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/Stateful",
		"mixins": [
			"dojo/Stateful"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/Chain": {
		"location": "havok/filter/Chain",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"parameters": [],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getFilteredValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Chain",
				"private": true,
				"parameters": [
					{
						"name": "filter",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_loop",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Chain",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "index",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Chain",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Chain",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/CleanHTML": {
		"location": "havok/filter/CleanHTML",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"summary": "<p>Filter that will remove leading and trailing whitespace</p>\n",
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/CleanHTML",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/Currency": {
		"location": "havok/filter/Currency",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Currency",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"dojo/number": {
		"location": "dojo/number",
		"type": "object",
		"summary": "<p>localized formatting and parsing routines for Number</p>\n",
		"properties": [
			{
				"name": "_numberPatternRE",
				"scope": "normal",
				"types": [
					"RegExp"
				],
				"from": "dojo/number",
				"private": true
			}
		],
		"methods": [
			{
				"name": "__FormatAbsoluteOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__FormatOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__IntegerRegexpFlags",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__ParseOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__RealNumberRegexpFlags",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__RegexpOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyPattern",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted.</p>\n"
					},
					{
						"name": "pattern",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>a pattern string as described by\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">unicode.org TR35</a></p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>_applyPattern is usually called via <code>dojo/number.format()</code> which\npopulates an extra property in the options parameter, &quot;customs&quot;.\nThe customs object specifies group and decimal parameters if set.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Apply pattern to format value as a string using options. Gives no\nconsideration to local customs.</p>\n"
			},
			{
				"name": "_formatAbsolute",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted, ignores sign</p>\n"
					},
					{
						"name": "pattern",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the number portion of a pattern (e.g. <code>#,##0.00</code>)</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>decimal (String, optional): <p>the decimal separator</p>\n</li><li>group (String, optional): <p>the group separator</p>\n</li><li>places (Number|String, optional): <p>number of decimal places.  the range &quot;n,m&quot; will format to m places.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans don&#39;t round.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Apply numeric pattern to absolute value using options. Gives no\nconsideration to local customs.</p>\n"
			},
			{
				"name": "_integerRegexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [
					{
						"name": "flags",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>signed (Boolean, optional): <p>The leading plus-or-minus sign. Can be true, false, or <code>[true,false]</code>.\nDefault is <code>[true, false]</code>, (i.e. will match if it is signed\nor unsigned).</p>\n</li><li>separator (String, optional): <p>The character used as the thousands separator. Default is no\nseparator. For more than one symbol use an array, e.g. <code>[&quot;,&quot;, &quot;&quot;]</code>,\nmakes &#39;,&#39; optional.</p>\n</li><li>groupSize (Number, optional): <p>group size between separators</p>\n</li><li>groupSize2 (Number, optional): <p>second grouping, where separators 2..n have a different interval than the first separator (for India)</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds a regular expression that matches an integer</p>\n"
			},
			{
				"name": "_parseInfo",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_realNumberRegexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"private": true,
				"parameters": [
					{
						"name": "flags",
						"types": [
							"__RealNumberRegexpFlags"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds a regular expression to match a real number in exponential\nnotation</p>\n"
			},
			{
				"name": "format",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				],
				"summary": "<p>Format a Number as a String, using locale-specific settings</p>\n",
				"description": "<p>Create a string from a Number using a known localized pattern.\nFormatting patterns appropriate to the locale are chosen from the\n<a href=\"http://unicode.org/cldr\">Common Locale Data Repository</a> as well as the appropriate symbols and\ndelimiters.\nIf value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representation of a Number</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by pattern\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Convert a properly formatted string to a primitive Number, using\nlocale-specific settings.</p>\n",
				"description": "<p>Create a Number from a string using a known localized pattern.\nFormatting patterns are chosen appropriate to the locale\nand follow the syntax described by\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">unicode.org TR35</a>\nNote that literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "regexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>places (Number|String, optional): <p>number of decimal places to accept: Infinity, a positive number, or\na range &quot;n,m&quot;.  Defined by pattern or Infinity if pattern not provided.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds the regular needed to parse a number</p>\n",
				"description": "<p>Returns regular expression with positive and negative match, group\nand decimal separators</p>\n"
			},
			{
				"name": "round",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/number",
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The number to round</p>\n"
					},
					{
						"name": "places",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.\nMust be non-negative.</p>\n"
					},
					{
						"name": "increment",
						"types": [
							"Number"
						],
						"usage": "optional",
						"summary": "<p>Rounds next place to nearest value of increment/10.  10 by default.</p>\n"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Rounds to the nearest value with the given number of decimal places, away from zero</p>\n",
				"description": "<p>Rounds to the nearest value with the given number of decimal places, away from zero if equal.\nSimilar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by\nfractional increments also, such as the nearest quarter.\nNOTE: Subject to floating point errors.  See dojox/math/round for experimental workaround.</p>\n",
				"examples": [
					"<pre><code>&gt;&gt;&gt; number.round(-0.5)\n-1\n&gt;&gt;&gt; number.round(162.295, 2)\n162.29  // note floating point error.  Should be 162.3\n&gt;&gt;&gt; number.round(10.71, 0, 2.5)\n10.75</code></pre>\n"
				]
			}
		]
	},
	"dojo/number.__FormatOptions": {
		"location": "dojo/number.__FormatOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "fractional",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/number",
				"summary": "<p>If false, show no decimal places, overriding places and pattern settings.</p>\n"
			},
			{
				"name": "locale",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override the locale used to determine formatting rules</p>\n"
			},
			{
				"name": "pattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "places",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n"
			},
			{
				"name": "round",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n"
			},
			{
				"name": "type",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n"
			}
		]
	},
	"dojo/number.__FormatAbsoluteOptions": {
		"location": "dojo/number.__FormatAbsoluteOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "decimal",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>the decimal separator</p>\n"
			},
			{
				"name": "group",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>the group separator</p>\n"
			},
			{
				"name": "places",
				"scope": "prototype",
				"types": [
					"Number",
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>number of decimal places.  the range &quot;n,m&quot; will format to m places.</p>\n"
			},
			{
				"name": "round",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans don&#39;t round.</p>\n"
			}
		]
	},
	"dojo/number.__RegexpOptions": {
		"location": "dojo/number.__RegexpOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "locale",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override the locale used to determine formatting rules</p>\n"
			},
			{
				"name": "pattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.</p>\n"
			},
			{
				"name": "places",
				"scope": "prototype",
				"types": [
					"Number",
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>number of decimal places to accept: Infinity, a positive number, or\na range &quot;n,m&quot;.  Defined by pattern or Infinity if pattern not provided.</p>\n"
			},
			{
				"name": "strict",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/number",
				"summary": "<p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n"
			},
			{
				"name": "type",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n"
			}
		]
	},
	"dojo/number.__ParseOptions": {
		"location": "dojo/number.__ParseOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "fractional",
				"scope": "prototype",
				"types": [
					"Boolean",
					"Array"
				],
				"from": "dojo/number",
				"summary": "<p>Whether to include the fractional portion, where the number of decimal places are implied by pattern\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.</p>\n"
			},
			{
				"name": "locale",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override the locale used to determine formatting rules</p>\n"
			},
			{
				"name": "pattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "strict",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/number",
				"summary": "<p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n"
			},
			{
				"name": "type",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n"
			}
		]
	},
	"dojo/number.__RealNumberRegexpFlags": {
		"location": "dojo/number.__RealNumberRegexpFlags",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "decimal",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>A string for the character used as the decimal point.  Default\nis &quot;.&quot;.</p>\n"
			},
			{
				"name": "eSigned",
				"scope": "prototype",
				"types": [
					"Boolean",
					"Array"
				],
				"from": "dojo/number",
				"summary": "<p>The leading plus-or-minus sign on the exponent.  Can be true,\nfalse, or [true, false].  Default is [true, false], (i.e. will\nmatch if it is signed or unsigned).  flags in regexp.integer can be\napplied.</p>\n"
			},
			{
				"name": "exponent",
				"scope": "prototype",
				"types": [
					"Boolean",
					"Array"
				],
				"from": "dojo/number",
				"summary": "<p>Express in exponential notation.  Can be true, false, or [true,\nfalse]. Default is [true, false], (i.e. will match if the\nexponential part is present are not).</p>\n"
			},
			{
				"name": "fractional",
				"scope": "prototype",
				"types": [
					"Boolean",
					"Array"
				],
				"from": "dojo/number",
				"summary": "<p>Whether decimal places are used.  Can be true, false, or [true,\nfalse].  Default is [true, false] which means optional.</p>\n"
			},
			{
				"name": "places",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>The integer number of decimal places or a range given as &quot;n,m&quot;.  If\nnot given, the decimal part is optional and the number of places is\nunlimited.</p>\n"
			}
		]
	},
	"dojo/number.__IntegerRegexpFlags": {
		"location": "dojo/number.__IntegerRegexpFlags",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "groupSize",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>group size between separators</p>\n"
			},
			{
				"name": "groupSize2",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>second grouping, where separators 2..n have a different interval than the first separator (for India)</p>\n"
			},
			{
				"name": "separator",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>The character used as the thousands separator. Default is no\nseparator. For more than one symbol use an array, e.g. <code>[&quot;,&quot;, &quot;&quot;]</code>,\nmakes &#39;,&#39; optional.</p>\n"
			},
			{
				"name": "signed",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/number",
				"summary": "<p>The leading plus-or-minus sign. Can be true, false, or <code>[true,false]</code>.\nDefault is <code>[true, false]</code>, (i.e. will match if it is signed\nor unsigned).</p>\n"
			}
		]
	},
	"dojo/i18n": {
		"location": "dojo/i18n",
		"type": "object",
		"summary": "<p>This module implements the dojo/i18n! plugin and the v1.6- i18n API</p>\n",
		"description": "<p>We choose to include our own plugin to leverage functionality already contained in dojo\nand thereby reduce the size of the plugin compared to various loader implementations. Also, this\nallows foreign AMD loaders to be used without their plugins.</p>\n",
		"properties": [
			{
				"name": "cache",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/i18n"
			},
			{
				"name": "dynamic",
				"scope": "normal",
				"types": [
					"boolean"
				],
				"from": "dojo/i18n"
			},
			{
				"name": "unitTests",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/i18n"
			}
		],
		"methods": [
			{
				"name": "_preloadLocalizations",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"private": true,
				"parameters": [
					{
						"name": "bundlePrefix",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "localesGenerated",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "guaranteedAmdFormat",
						"types": [
							"boolean"
						],
						"usage": "optional"
					},
					{
						"name": "contextRequire",
						"types": [
							"function"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Load available flattened resource bundles associated with a particular module for dojo/locale and all dojo/config.extraLocale (if any)</p>\n",
				"description": "<p>Only called by built layer files. The entire locale hierarchy is loaded. For example,\nif locale==&quot;ab-cd&quot;, then ROOT, &quot;ab&quot;, and &quot;ab-cd&quot; are loaded. This is different than v1.6-\nin that the v1.6- would only load ab-cd...which was <em>always</em> flattened.\n\n</p>\n<p>If guaranteedAmdFormat is true, then the module can be loaded with require thereby circumventing the detection algorithm\nand the extra possible extra transaction.</p>\n"
			},
			{
				"name": "getL10nName",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"parameters": [
					{
						"name": "moduleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "bundleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "getLocalization",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"parameters": [
					{
						"name": "moduleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "bundleName",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "load",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>id is in one of the following formats\n\n</p>\n<ol>\n<li><p><path>/nls/<bundle>\n =&gt; load the bundle, localized to config.locale; load all bundles localized to\n config.extraLocale (if any); return the loaded bundle localized to config.locale.</p>\n</li>\n<li><p><path>/nls/<locale>/<bundle>\n =&gt; load then return the bundle localized to <locale></p>\n</li>\n<li><p><em>preload</em><path>/nls/<module>*<JSON array of available locales>\n =&gt; for config.locale and all config.extraLocale, load all bundles found\n in the best-matching bundle rollup. A value of 1 is returned, which\n is meaningless other than to say the plugin is executing the requested\n preloads</p>\n</li>\n</ol>\n<p>In cases 1 and 2, <path> is always normalized to an absolute module id upon entry; see\nnormalize. In case 3, it <path> is assumed to be absolute; this is arranged by the builder.\n\n</p>\n<p>To load a bundle means to insert the bundle into the plugin&#39;s cache and publish the bundle\nvalue to the loader. Given <path>, <bundle>, and a particular <locale>, the cache key\n\n</p>\n<pre><code>&lt;path&gt;/nls/&lt;bundle&gt;/&lt;locale&gt;</code></pre>\n<p>will hold the value. Similarly, then plugin will publish this value to the loader by\n\n</p>\n<pre><code>define(&quot;&lt;path&gt;/nls/&lt;bundle&gt;/&lt;locale&gt;&quot;, &lt;bundle-value&gt;);</code></pre>\n<p>Given this algorithm, other machinery can provide fast load paths be preplacing\nvalues in the plugin&#39;s cache, which is public. When a load is demanded the\ncache is inspected before starting any loading. Explicitly placing values in the plugin\ncache is an advanced/experimental feature that should not be needed; use at your own risk.\n\n</p>\n<p>For the normal AMD algorithm, the root bundle is loaded first, which instructs the\nplugin what additional localized bundles are required for a particular locale. These\nadditional locales are loaded and a mix of the root and each progressively-specific\nlocale is returned. For example:\n\n</p>\n<ol>\n<li><p>The client demands &quot;dojo/i18n!some/path/nls/someBundle</p>\n</li>\n<li><p>The loader demands load(some/path/nls/someBundle)</p>\n</li>\n<li><p>This plugin require&#39;s &quot;some/path/nls/someBundle&quot;, which is the root bundle.</p>\n</li>\n<li><p>Assuming config.locale is &quot;ab-cd-ef&quot; and the root bundle indicates that localizations\nare available for &quot;ab&quot; and &quot;ab-cd-ef&quot; (note the missing &quot;ab-cd&quot;, then the plugin\nrequires &quot;some/path/nls/ab/someBundle&quot; and &quot;some/path/nls/ab-cd-ef/someBundle&quot;</p>\n</li>\n<li><p>Upon receiving all required bundles, the plugin constructs the value of the bundle\nab-cd-ef as...</p>\n<pre><code> mixin(mixin(mixin({}, require(&quot;some/path/nls/someBundle&quot;),\n     require(&quot;some/path/nls/ab/someBundle&quot;)),\n     require(&quot;some/path/nls/ab-cd-ef/someBundle&quot;));</code></pre>\n</li>\n</ol>\n<p>This value is inserted into the cache and published to the loader at the\nkey/module-id some/path/nls/someBundle/ab-cd-ef.\n\n</p>\n<p>The special preload signature (case 3) instructs the plugin to stop servicing all normal requests\n(further preload requests will be serviced) until all ongoing preloading has completed.\n\n</p>\n<p>The preload signature instructs the plugin that a special rollup module is available that contains\none or more flattened, localized bundles. The JSON array of available locales indicates which locales\nare available. Here is an example:\n\n</p>\n<pre><code>*preload*some/path/nls/someModule*[&quot;root&quot;, &quot;ab&quot;, &quot;ab-cd-ef&quot;]</code></pre>\n<p>This indicates the following rollup modules are available:\n\n</p>\n<pre><code>some/path/nls/someModule_ROOT\nsome/path/nls/someModule_ab\nsome/path/nls/someModule_ab-cd-ef</code></pre>\n<p>Each of these modules is a normal AMD module that contains one or more flattened bundles in a hash.\nFor example, assume someModule contained the bundles some/bundle/path/someBundle and\nsome/bundle/path/someOtherBundle, then some/path/nls/someModule_ab would be expressed as follows:\n\n</p>\n<pre><code>define({\n    some/bundle/path/someBundle:&lt;value of someBundle, flattened with respect to locale ab&gt;,\n    some/bundle/path/someOtherBundle:&lt;value of someOtherBundle, flattened with respect to locale ab&gt;,\n});</code></pre>\n<p>E.g., given this design, preloading for locale==&quot;ab&quot; can execute the following algorithm:\n\n</p>\n<pre><code>require([&quot;some/path/nls/someModule_ab&quot;], function(rollup){\n    for(var p in rollup){\n        var id = p + &quot;/ab&quot;,\n        cache[id] = rollup[p];\n        define(id, rollup[p]);\n    }\n});</code></pre>\n<p>Similarly, if &quot;ab-cd&quot; is requested, the algorithm can determine that &quot;ab&quot; is the best available and\nload accordingly.\n\n</p>\n<p>The builder will write such rollups for every layer if a non-empty localeList  profile property is\nprovided. Further, the builder will include the following cache entry in the cache associated with\nany layer.\n\n</p>\n<pre><code>&quot;*now&quot;:function(r){r([&#39;dojo/i18n!*preload*&lt;path&gt;/nls/&lt;module&gt;*&lt;JSON array of available locales&gt;&#39;]);}</code></pre>\n<p>The *now special cache module instructs the loader to apply the provided function to context-require\nwith respect to the particular layer being defined. This causes the plugin to hold all normal service\nrequests until all preloading is complete.\n\n</p>\n<p>Notice that this algorithm is rarely better than the standard AMD load algorithm. Consider the normal case\nwhere the target locale has a single segment and a layer depends on a single bundle:\n\n</p>\n<p>Without Preloads:\n\n</p>\n<ol>\n<li>Layer loads root bundle.</li>\n<li>bundle is demanded; plugin loads single localized bundle.</li>\n</ol>\n<p>With Preloads:\n\n</p>\n<ol>\n<li>Layer causes preloading of target bundle.</li>\n<li>bundle is demanded; service is delayed until preloading complete; bundle is returned.</li>\n</ol>\n<p>In each case a single transaction is required to load the target bundle. In cases where multiple bundles\nare required and/or the locale has multiple segments, preloads still requires a single transaction whereas\nthe normal path requires an additional transaction for each additional bundle/locale-segment. However all\nof these additional transactions can be done concurrently. Owing to this analysis, the entire preloading\nalgorithm can be discard during a build by setting the has feature dojo-preload-i18n-Api to false.</p>\n"
			},
			{
				"name": "normalize",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "toAbsMid",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>id may be relative.\npreload has form <code>*preload*&lt;path&gt;/nls/&lt;module&gt;*&lt;flattened locales&gt;</code> and\ntherefore never looks like a relative</p>\n"
			},
			{
				"name": "normalizeLocale",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/i18n",
				"parameters": [
					{
						"name": "locale",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"returnDescription": "<p>The locale to assume for loading localized resources in this page,\nspecified according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a>.\nMust be specified entirely in lowercase, e.g. <code>en-us</code> and <code>zh-cn</code>.\nSee the documentation for <code>dojo.i18n</code> and <code>dojo.requireLocalization</code>\nfor details on loading localized resources. If no locale is specified,\nDojo assumes the locale of the user agent, according to <code>navigator.userLanguage</code>\nor <code>navigator.language</code> properties.</p>\n"
			}
		]
	},
	"dojo/i18n.cache": {
		"location": "dojo/i18n.cache",
		"type": "object"
	},
	"dojo/json": {
		"location": "dojo/json",
		"type": "object",
		"summary": "<p>Functions to parse and serialize JSON</p>\n",
		"methods": [
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/json",
				"parameters": [
					{
						"name": "str",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>a string literal of a JSON item, for instance:\n<code>&#39;{ &quot;foo&quot;: [ &quot;bar&quot;, 1, { &quot;baz&quot;: &quot;thud&quot; } ] }&#39;</code></p>\n"
					},
					{
						"name": "strict",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>When set to true, this will ensure that only valid, secure JSON is ever parsed.\nMake sure this is set to true for untrusted content. Note that on browsers/engines\nwithout native JSON support, setting this to true will run slower.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Parses a <a href=\"http://json.org\">JSON</a> string to return a JavaScript object.</p>\n",
				"description": "<p>This function follows <a href=\"https://developer.mozilla.org/en/JSON\">native JSON API</a>\nThrows for invalid JSON strings. This delegates to eval() if native JSON\nsupport is not available. By default this will evaluate any valid JS expression.\nWith the strict parameter set to true, the parser will ensure that only\nvalid JSON strings are parsed (otherwise throwing an error). Without the strict\nparameter, the content passed to this method must come\nfrom a trusted source.</p>\n"
			},
			{
				"name": "stringify",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/json",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>A value to be serialized.</p>\n"
					},
					{
						"name": "replacer",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>A replacer function that is called for each value and can return a replacement</p>\n"
					},
					{
						"name": "spacer",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>A spacer string to be used for pretty printing of JSON</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a <a href=\"http://json.org\">JSON</a> serialization of an object.</p>\n",
				"description": "<p>Returns a <a href=\"http://json.org\">JSON</a> serialization of an object.\nThis function follows <a href=\"https://developer.mozilla.org/en/JSON\">native JSON API</a>\nNote that this doesn&#39;t check for infinite recursion, so don&#39;t do that!</p>\n",
				"examples": [
					"<p>simple serialization of a trivial object\n\n</p>\n<pre><code>define([&quot;dojo/json&quot;], function(JSON){\n    var jsonStr = JSON.stringify({ howdy: &quot;stranger!&quot;, isStrange: true });\n    doh.is(&#39;{&quot;howdy&quot;:&quot;stranger!&quot;,&quot;isStrange&quot;:true}&#39;, jsonStr);</code></pre>\n"
				]
			}
		]
	},
	"dojo/regexp": {
		"location": "dojo/regexp",
		"type": "object",
		"summary": "<p>Regular expressions and Builder resources</p>\n",
		"methods": [
			{
				"name": "buildGroupRE",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/regexp",
				"parameters": [
					{
						"name": "arr",
						"types": [
							"Object",
							"Array"
						],
						"usage": "required",
						"summary": "<p>A single value or an array of values.</p>\n"
					},
					{
						"name": "re",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>A function. Takes one parameter and converts it to a regular\nexpression.</p>\n"
					},
					{
						"name": "nonCapture",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, uses non-capturing match, otherwise matches are retained\nby regular expression. Defaults to false</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Builds a regular expression that groups subexpressions</p>\n",
				"description": "<p>A utility function used by some of the RE generators. The\nsubexpressions are constructed by the function, re, in the second\nparameter.  re builds one subexpression for each elem in the array\na, in the first parameter. Returns a string for a regular\nexpression that groups all the subexpressions.</p>\n"
			},
			{
				"name": "escapeString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/regexp",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "except",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>a String with special characters to be left unescaped</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Adds escape sequences for special characters in regular expressions</p>\n"
			},
			{
				"name": "group",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/regexp",
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "nonCapture",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, uses non-capturing match, otherwise matches are retained\nby regular expression.</p>\n"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>adds group match to expression</p>\n"
			}
		]
	},
	"dojo/cldr/monetary": {
		"location": "dojo/cldr/monetary",
		"type": "object",
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "getData",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/cldr/monetary",
				"parameters": [
					{
						"name": "code",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>an <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO 4217</a> currency code</p>\n"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.</p>\n"
			}
		]
	},
	"havok/filter/HexColor": {
		"location": "havok/filter/HexColor",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/HexColor",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/Lowercase": {
		"location": "havok/filter/Lowercase",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Lowercase",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/Propercase": {
		"location": "havok/filter/Propercase",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Propercase",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/Trim": {
		"location": "havok/filter/Trim",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"summary": "<p>Filter that will remove leading and trailing whitespace</p>\n",
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Trim",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/Uppercase": {
		"location": "havok/filter/Uppercase",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/filter/Base",
		"mixins": [
			"havok/filter/Base"
		],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/filter/Uppercase",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		]
	},
	"havok/filter/config": {
		"location": "havok/filter/config",
		"type": "object",
		"properties": [
			{
				"name": "di",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/filter/config"
			}
		]
	},
	"havok/filter/config.di": {
		"location": "havok/filter/config.di",
		"type": "object",
		"properties": [
			{
				"name": "havok/filter/Chain",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/filter/config"
			},
			{
				"name": "havok/filter/factory",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/filter/config"
			}
		]
	},
	"havok/filter/factory": {
		"location": "havok/filter/factory",
		"type": "object",
		"properties": [
			{
				"name": "abreviations",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "havok/filter/factory"
			}
		],
		"methods": [
			{
				"name": "create",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/filter/factory",
				"parameters": [
					{
						"name": "config",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "expand",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/filter/factory",
				"parameters": [
					{
						"name": "base",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string",
					"undefined"
				]
			}
		]
	},
	"havok/filter/main": {
		"location": "havok/filter/main",
		"type": "undefined"
	},
	"havok/form/Checkbox": {
		"location": "havok/form/Checkbox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/form/_FormWidgetMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/Checkbox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setDisabledAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Checkbox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Checkbox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Checkbox",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Checkbox",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Checkbox",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Checkbox",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_FormWidgetMixin": {
		"location": "havok/form/_FormWidgetMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/_LabelMixin",
		"mixins": [
			"havok/form/_LabelMixin",
			"havok/form/_HelpMessagesMixin",
			"havok/form/_RequiredStarMixin",
			"havok/form/_ActivityMixin"
		],
		"properties": [
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			}
		],
		"methods": [
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormWidgetMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		],
		"events": [
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_LabelMixin": {
		"location": "havok/form/_LabelMixin",
		"type": "constructor",
		"classlike": true,
		"methods": [
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_HelpMessagesMixin": {
		"location": "havok/form/_HelpMessagesMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/_MessagesMixin",
		"mixins": [
			"havok/form/_MessagesMixin"
		],
		"properties": [
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"havok/form/_MessagesMixin": {
		"location": "havok/form/_MessagesMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"havok/form/_RequiredStarMixin": {
		"location": "havok/form/_RequiredStarMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			}
		],
		"methods": [
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_ActivityMixin": {
		"location": "havok/form/_ActivityMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/_FocusMixin",
		"mixins": [
			"dijit/_FocusMixin"
		],
		"properties": [
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			}
		],
		"methods": [
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dijit/_FocusMixin": {
		"location": "dijit/_FocusMixin",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Mixin to widget to provide _onFocus() and _onBlur() methods that\nfire when a widget or its descendants get/lose focus</p>\n",
		"properties": [
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			}
		]
	},
	"dijit/focus": {
		"location": "dijit/focus",
		"type": "instance",
		"classlike": true,
		"superclass": "dojo/Stateful",
		"mixins": [
			"dojo/Stateful",
			"dojo/Evented"
		],
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>Tracks the currently focused node, and which widgets are currently &quot;active&quot;.\nAccess via require([&quot;dijit/focus&quot;], function(focus){ ... }).\n\n</p>\n<p>A widget is considered active if it or a descendant widget has focus,\nor if a non-focusable node of this widget or a descendant was recently clicked.\n\n</p>\n<p>Call focus.watch(&quot;curNode&quot;, callback) to track the current focused DOMNode,\nor focus.watch(&quot;activeStack&quot;, callback) to track the currently focused stack of widgets.\n\n</p>\n<p>Call focus.on(&quot;widget-blur&quot;, func) or focus.on(&quot;widget-focus&quot;, ...) to monitor when\nwhen widgets become active/inactive\n\n</p>\n<p>Finally, focus(node) will focus a node, suppressing errors if the node doesn&#39;t exist.</p>\n",
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"Hash"
				],
				"from": "dojo/Stateful",
				"private": true,
				"summary": "<p>Used across all instances a hash to cache attribute names and their getter \nand setter names.</p>\n"
			},
			{
				"name": "activeStack",
				"scope": "prototype",
				"types": [
					"dijit/_WidgetBase[]"
				],
				"from": "dijit/focus",
				"summary": "<p>List of currently active widgets (focused widget and it&#39;s ancestors)</p>\n"
			},
			{
				"name": "curNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/focus",
				"summary": "<p>Currently focused item on screen</p>\n"
			}
		],
		"methods": [
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "names",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>Hash of names of custom attributes</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Private function that does a get based off a hash of names</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_setStack",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"private": true,
				"parameters": [
					{
						"name": "newStack",
						"types": [
							"String[]"
						],
						"usage": "required",
						"summary": "<p>array of widget id&#39;s, starting from the top (outermost) widget</p>\n"
					},
					{
						"name": "by",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>&quot;mouse&quot; if the focus/touch was caused by a mouse down event</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>The stack of active widgets has changed.  Send out appropriate events and records new stack.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Evented",
				"parameters": [
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "focus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Focus the specified node, suppressing errors if they occur</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The property value on this Stateful instance.</p>\n",
				"summary": "<p>Get a property on a Stateful instance.</p>\n",
				"description": "<p>Get a named property on a Stateful object. The property may\npotentially be retrieved via a getter method in subclasses. In the base class\nthis just retrieves the object&#39;s property.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful({foo: 3});\nstateful.get(&quot;foo&quot;) // returns 3\nstateful.foo // returns 3</code></pre>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Evented",
				"parameters": [
					{
						"name": "type",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "registerIframe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"parameters": [
					{
						"name": "iframe",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>Handle with remove() method to deregister.</p>\n",
				"summary": "<p>Registers listeners on the specified iframe so that any click\nor focus event on that iframe (or anything in it) is reported\nas a focus/click event on the <code>&lt;iframe&gt;</code> itself.</p>\n",
				"description": "<p>Currently only used by editor.</p>\n"
			},
			{
				"name": "registerWin",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"parameters": [
					{
						"name": "targetWindow",
						"types": [
							"Window"
						],
						"usage": "optional",
						"summary": "<p>If specified this is the window associated with the iframe,\ni.e. iframe.contentWindow.</p>\n"
					},
					{
						"name": "effectiveNode",
						"types": [
							"DomNode"
						],
						"usage": "optional",
						"summary": "<p>If specified, report any focus events inside targetWindow as\nan event on effectiveNode, rather than on evt.target.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>Handle with remove() method to deregister.</p>\n",
				"summary": "<p>Registers listeners on the specified window (either the main\nwindow or an iframe&#39;s window) to detect when the user has clicked somewhere\nor focused somewhere.</p>\n",
				"description": "<p>Users should call registerIframe() instead of this method.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"function"
				],
				"returnDescription": "<p>The function returns this dojo.Stateful instance.</p>\n",
				"summary": "<p>Set a property on a Stateful instance</p>\n",
				"description": "<p>Sets named properties on a stateful object and notifies any watchers of\nthe property. A programmatic setter may be defined in subclasses.\nFor example:\n\n</p>\n<pre><code>stateful = new dojo.Stateful();\nstateful.watch(function(name, oldValue, value){\n    // this will be called on the set below\n}\nstateful.set(foo, 5);</code></pre>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n</p>\n<pre><code>myObj.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n})</code></pre>\n<p>This is equivalent to calling set(foo, &quot;Howdy&quot;) and set(bar, 3)\n</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onBlurNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called when focus leaves a node.\nUsually ignored, <em>unless</em> it <em>isn&#39;t</em> followed by touching another node,\nwhich indicates that we tabbed off the last field on the page,\nin which case every widget is marked inactive</p>\n"
			},
			{
				"name": "_onFocusNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Callback when node is focused</p>\n"
			},
			{
				"name": "_onTouchNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/focus",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node that was touched.</p>\n"
					},
					{
						"name": "by",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>&quot;mouse&quot; if the focus/touch was caused by a mouse down event</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Callback when node is focused or mouse-downed</p>\n"
			}
		]
	},
	"dijit/a11y": {
		"location": "dijit/a11y",
		"type": "object",
		"summary": "<p>Accessibility utility functions (keyboard, tab stops, etc.)</p>\n",
		"methods": [
			{
				"name": "_getTabNavigable",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"private": true,
				"parameters": [
					{
						"name": "root",
						"types": [
							"DOMNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Finds descendants of the specified root node.</p>\n",
				"description": "<p>Finds the following descendants of the specified root node:\n\n</p>\n<ul>\n<li>the first tab-navigable element in document order\nwithout a tabIndex or with tabIndex=&quot;0&quot;</li>\n<li>the last tab-navigable element in document order\nwithout a tabIndex or with tabIndex=&quot;0&quot;</li>\n<li>the first element in document order with the lowest\npositive tabIndex value</li>\n<li>the last element in document order with the highest\npositive tabIndex value</li>\n</ul>\n"
			},
			{
				"name": "_isElementShown",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"private": true,
				"parameters": [
					{
						"name": "elem",
						"types": [
							"Element"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				]
			},
			{
				"name": "getFirstInTabbingOrder",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"parameters": [
					{
						"name": "root",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Finds the descendant of the specified root node\nthat is first in the tabbing order</p>\n"
			},
			{
				"name": "getLastInTabbingOrder",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"parameters": [
					{
						"name": "root",
						"types": [
							"String",
							"DOMNode"
						],
						"usage": "required"
					},
					{
						"name": "doc",
						"types": [
							"Document"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Finds the descendant of the specified root node\nthat is last in the tabbing order</p>\n"
			},
			{
				"name": "hasDefaultTabStop",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"parameters": [
					{
						"name": "elem",
						"types": [
							"Element"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"boolean"
				],
				"summary": "<p>Tests if element is tab-navigable even without an explicit tabIndex setting</p>\n"
			},
			{
				"name": "isTabNavigable",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11y",
				"parameters": [
					{
						"name": "elem",
						"types": [
							"Element"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean",
					"undefined"
				],
				"summary": "<p>Tests if an element is tab-navigable</p>\n"
			}
		]
	},
	"havok/form/CheckboxGroup": {
		"location": "havok/form/CheckboxGroup",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/CheckboxGroup",
		"mixins": [
			"havok/widget/CheckboxGroup",
			"havok/form/_FormWidgetMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/ButtonGroup"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/CheckboxGroup"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/CheckboxGroup",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/CheckboxGroup",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CheckboxGroup",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CheckboxGroup",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CheckboxGroup",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/CheckboxGroup": {
		"location": "havok/widget/CheckboxGroup",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/ButtonGroup",
		"mixins": [
			"havok/widget/ButtonGroup"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/ButtonGroup"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/CheckboxGroup",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/CheckboxGroup",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"dijit/a11yclick": {
		"location": "dijit/a11yclick",
		"type": "object",
		"summary": "<p>Custom press, release, and click synthetic events\nwhich trigger on a left mouse click, touch, or space/enter keyup.</p>\n",
		"methods": [
			{
				"name": "click",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11yclick",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Logical click operation for mouse, touch, or keyboard (space/enter key)</p>\n"
			},
			{
				"name": "move",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11yclick",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Mouse cursor or a finger is dragged over the given node.</p>\n"
			},
			{
				"name": "press",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11yclick",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Mousedown (left button), touchstart, or keydown (space or enter) corresponding to logical click operation.</p>\n"
			},
			{
				"name": "release",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dijit/a11yclick",
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "listener",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Mouseup (left button), touchend, or keyup (space or enter) corresponding to logical click operation.</p>\n"
			}
		]
	},
	"havok/widget/ButtonGroup": {
		"location": "havok/widget/ButtonGroup",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_StoreMixin",
			"havok/widget/_ListMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/ButtonGroup"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/_StoreMixin": {
		"location": "havok/widget/_StoreMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			}
		],
		"methods": [
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/_ListMixin": {
		"location": "havok/widget/_ListMixin",
		"type": "constructor",
		"classlike": true,
		"methods": [
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/Color": {
		"location": "havok/form/Color",
		"type": "function",
		"parameters": [
			{
				"name": "color",
				"types": [
					"Array",
					"String",
					"Object"
				],
				"usage": "required"
			}
		],
		"returnTypes": [],
		"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand creates a new Color instance to work from.\n</p>\n",
		"examples": [
			"<p>Work with a Color instance:\n\n</p>\n<pre><code>var c = new Color();\nc.setColor([0,0,0]); // black\nvar hex = c.toHex(); // #000000</code></pre>\n",
			"<p>Work with a node&#39;s color:\n\n</p>\n<pre><code>var color = dojo.style(&quot;someNode&quot;, &quot;backgroundColor&quot;);\nvar n = new Color(color);\n// adjust the color some\nn.r *= .5;\nconsole.log(n.toString()); // rgb(128, 255, 255);</code></pre>\n"
		],
		"properties": [
			{
				"name": "a",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "b",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "g",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "named",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/Color",
				"summary": "<p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.</p>\n"
			},
			{
				"name": "r",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			}
		],
		"methods": [
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"private": true,
				"parameters": [
					{
						"name": "r",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "g",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "b",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "a",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "blendColors",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "start",
						"types": [
							"havok/form/Color"
						],
						"usage": "required"
					},
					{
						"name": "end",
						"types": [
							"havok/form/Color"
						],
						"usage": "required"
					},
					{
						"name": "weight",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,\ncan reuse a previously allocated Color object for the result</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"Array",
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand creates a new Color instance to work from.\n</p>\n",
				"examples": [
					"<p>Work with a Color instance:\n\n</p>\n<pre><code>var c = new Color();\nc.setColor([0,0,0]); // black\nvar hex = c.toHex(); // #000000</code></pre>\n",
					"<p>Work with a node&#39;s color:\n\n</p>\n<pre><code>var color = dojo.style(&quot;someNode&quot;, &quot;backgroundColor&quot;);\nvar n = new Color(color);\n// adjust the color some\nn.r *= .5;\nconsole.log(n.toString()); // rgb(128, 255, 255);</code></pre>\n"
				]
			},
			{
				"name": "fromArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "a",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Builds a <code>Color</code> from a 3 or 4 element array, mapping each\nelement in sequence to the rgb(a) values of the color.</p>\n",
				"examples": [
					"<pre><code>var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha</code></pre>\n"
				]
			},
			{
				"name": "fromHex",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any",
					"null",
					"string"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.\n</p>\n",
				"summary": "<p>Converts a hex string with a &#39;#&#39; prefix to a color object.\nSupports 12-bit #rgb shorthand. Optionally accepts a\n<code>Color</code> object to update with the parsed value.\n</p>\n",
				"examples": [
					"<pre><code>var thing = dojo.colorFromHex(&quot;#ededed&quot;); // grey, longhand</code></pre>\n",
					"<pre><code>var thing = dojo.colorFromHex(&quot;#000&quot;); // black, shorthand</code></pre>\n"
				]
			},
			{
				"name": "fromHsv",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/form/Color",
				"parameters": [
					{
						"name": "hue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "saturation",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Create a Color from an HSV defined color.\nhue from 0-359 (degrees), saturation and value 0-100.</p>\n"
			},
			{
				"name": "fromRgb",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Returns a <code>Color</code> instance from a string of the form\n&quot;rgb(...)&quot; or &quot;rgba(...)&quot;. Optionally accepts a <code>Color</code>\nobject to update with the parsed value and return instead of\ncreating a new object.</p>\n"
			},
			{
				"name": "fromString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Parses <code>str</code> for a color value. Accepts hex, rgb, and rgba\nstyle color values.</p>\n",
				"description": "<p>Acceptable input values for str may include arrays of any form\naccepted by dojo.colorFromArray, hex strings such as &quot;#aaaaaa&quot;, or\nrgb or rgba strings such as &quot;rgb(133, 200, 16)&quot; or &quot;rgba(10, 10,\n10, 50)&quot;</p>\n"
			},
			{
				"name": "sanitize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Ensures the object has correct attributes</p>\n",
				"summary": "<p>Ensures the object has correct attributes</p>\n",
				"description": "<p>the default implementation does nothing, include dojo.colors to\naugment it with real checks</p>\n"
			},
			{
				"name": "setColor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"Array",
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand sets this color instance to that value.\n</p>\n",
				"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand sets this color instance to that value.\n</p>\n",
				"examples": [
					"<pre><code>var c = new Color(); // no color\nc.setColor(&quot;#ededed&quot;); // greyish</code></pre>\n"
				]
			},
			{
				"name": "toCss",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "includeAlpha",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a css color string in rgb(a) representation</p>\n",
				"examples": [
					"<pre><code>var c = new Color(&quot;#FFF&quot;).toCss();\nconsole.log(c); // rgb(&#39;255&#39;,&#39;255&#39;,&#39;255&#39;)</code></pre>\n"
				]
			},
			{
				"name": "toHex",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a CSS color string in hexadecimal representation</p>\n",
				"examples": [
					"<pre><code>console.log(new Color([0,0,0]).toHex()); // #000000</code></pre>\n"
				]
			},
			{
				"name": "toHsv",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Color",
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Convert this Color to an HSV definition.</p>\n"
			},
			{
				"name": "toRgb",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns 3 component array of rgb values</p>\n",
				"examples": [
					"<pre><code>var c = new Color(&quot;#000000&quot;);\nconsole.log(c.toRgb()); // [0,0,0]</code></pre>\n"
				]
			},
			{
				"name": "toRgba",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns a 4 component array of rgba values from the color\nrepresented by this object.</p>\n"
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns a visual representation of the color</p>\n"
			}
		]
	},
	"havok/form/Color.named": {
		"location": "havok/form/Color.named",
		"type": "object",
		"summary": "<p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.</p>\n",
		"properties": [
			{
				"name": "aqua",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "black",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "blue",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "fuchsia",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "gray",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "green",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "lime",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "maroon",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "navy",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "olive",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "purple",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "red",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "silver",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "teal",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "transparent",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "white",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "yellow",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			}
		]
	},
	"dojo/_base/Color": {
		"location": "dojo/_base/Color",
		"type": "function",
		"parameters": [
			{
				"name": "color",
				"types": [
					"Array",
					"String",
					"Object"
				],
				"usage": "required"
			}
		],
		"returnTypes": [],
		"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand creates a new Color instance to work from.\n</p>\n",
		"examples": [
			"<p>Work with a Color instance:\n\n</p>\n<pre><code>var c = new Color();\nc.setColor([0,0,0]); // black\nvar hex = c.toHex(); // #000000</code></pre>\n",
			"<p>Work with a node&#39;s color:\n\n</p>\n<pre><code>var color = dojo.style(&quot;someNode&quot;, &quot;backgroundColor&quot;);\nvar n = new Color(color);\n// adjust the color some\nn.r *= .5;\nconsole.log(n.toString()); // rgb(128, 255, 255);</code></pre>\n"
		],
		"properties": [
			{
				"name": "a",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "b",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "g",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "named",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/Color",
				"summary": "<p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.</p>\n"
			},
			{
				"name": "r",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "dojo/_base/Color"
			}
		],
		"methods": [
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"private": true,
				"parameters": [
					{
						"name": "r",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "g",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "b",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "a",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "blendColors",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "start",
						"types": [
							"havok/form/Color"
						],
						"usage": "required"
					},
					{
						"name": "end",
						"types": [
							"havok/form/Color"
						],
						"usage": "required"
					},
					{
						"name": "weight",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,\ncan reuse a previously allocated Color object for the result</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"Array",
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand creates a new Color instance to work from.\n</p>\n",
				"examples": [
					"<p>Work with a Color instance:\n\n</p>\n<pre><code>var c = new Color();\nc.setColor([0,0,0]); // black\nvar hex = c.toHex(); // #000000</code></pre>\n",
					"<p>Work with a node&#39;s color:\n\n</p>\n<pre><code>var color = dojo.style(&quot;someNode&quot;, &quot;backgroundColor&quot;);\nvar n = new Color(color);\n// adjust the color some\nn.r *= .5;\nconsole.log(n.toString()); // rgb(128, 255, 255);</code></pre>\n"
				]
			},
			{
				"name": "fromArray",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "a",
						"types": [
							"Array"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Builds a <code>Color</code> from a 3 or 4 element array, mapping each\nelement in sequence to the rgb(a) values of the color.</p>\n",
				"examples": [
					"<pre><code>var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha</code></pre>\n"
				]
			},
			{
				"name": "fromHex",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any",
					"null",
					"string"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.\n</p>\n",
				"summary": "<p>Converts a hex string with a &#39;#&#39; prefix to a color object.\nSupports 12-bit #rgb shorthand. Optionally accepts a\n<code>Color</code> object to update with the parsed value.\n</p>\n",
				"examples": [
					"<pre><code>var thing = dojo.colorFromHex(&quot;#ededed&quot;); // grey, longhand</code></pre>\n",
					"<pre><code>var thing = dojo.colorFromHex(&quot;#000&quot;); // black, shorthand</code></pre>\n"
				]
			},
			{
				"name": "fromHsv",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/form/Color",
				"extensionModule": true,
				"parameters": [
					{
						"name": "hue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "saturation",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Create a Color from an HSV defined color.\nhue from 0-359 (degrees), saturation and value 0-100.</p>\n"
			},
			{
				"name": "fromRgb",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Returns a <code>Color</code> instance from a string of the form\n&quot;rgb(...)&quot; or &quot;rgba(...)&quot;. Optionally accepts a <code>Color</code>\nobject to update with the parsed value and return instead of\ncreating a new object.</p>\n"
			},
			{
				"name": "fromString",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "obj",
						"types": [
							"havok/form/Color"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>A Color object. If obj is passed, it will be the return value.</p>\n",
				"summary": "<p>Parses <code>str</code> for a color value. Accepts hex, rgb, and rgba\nstyle color values.</p>\n",
				"description": "<p>Acceptable input values for str may include arrays of any form\naccepted by dojo.colorFromArray, hex strings such as &quot;#aaaaaa&quot;, or\nrgb or rgba strings such as &quot;rgb(133, 200, 16)&quot; or &quot;rgba(10, 10,\n10, 50)&quot;</p>\n"
			},
			{
				"name": "sanitize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Ensures the object has correct attributes</p>\n",
				"summary": "<p>Ensures the object has correct attributes</p>\n",
				"description": "<p>the default implementation does nothing, include dojo.colors to\naugment it with real checks</p>\n"
			},
			{
				"name": "setColor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "color",
						"types": [
							"Array",
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand sets this color instance to that value.\n</p>\n",
				"summary": "<p>Takes a named string, hex string, array of rgb or rgba values,\nan object with r, g, b, and a properties, or another <code>Color</code> object\nand sets this color instance to that value.\n</p>\n",
				"examples": [
					"<pre><code>var c = new Color(); // no color\nc.setColor(&quot;#ededed&quot;); // greyish</code></pre>\n"
				]
			},
			{
				"name": "toCss",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [
					{
						"name": "includeAlpha",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a css color string in rgb(a) representation</p>\n",
				"examples": [
					"<pre><code>var c = new Color(&quot;#FFF&quot;).toCss();\nconsole.log(c); // rgb(&#39;255&#39;,&#39;255&#39;,&#39;255&#39;)</code></pre>\n"
				]
			},
			{
				"name": "toHex",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a CSS color string in hexadecimal representation</p>\n",
				"examples": [
					"<pre><code>console.log(new Color([0,0,0]).toHex()); // #000000</code></pre>\n"
				]
			},
			{
				"name": "toHsv",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Color",
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Convert this Color to an HSV definition.</p>\n"
			},
			{
				"name": "toRgb",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns 3 component array of rgb values</p>\n",
				"examples": [
					"<pre><code>var c = new Color(&quot;#000000&quot;);\nconsole.log(c.toRgb()); // [0,0,0]</code></pre>\n"
				]
			},
			{
				"name": "toRgba",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns a 4 component array of rgba values from the color\nrepresented by this object.</p>\n"
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/Color",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns a visual representation of the color</p>\n"
			}
		]
	},
	"dojo/_base/Color.named": {
		"location": "dojo/_base/Color.named",
		"type": "object",
		"summary": "<p>Dictionary list of all CSS named colors, by name. Values are 3-item arrays with corresponding RG and B values.</p>\n",
		"properties": [
			{
				"name": "aqua",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "black",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "blue",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "fuchsia",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "gray",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "green",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "lime",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "maroon",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "navy",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "olive",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "purple",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "red",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "silver",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "teal",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "transparent",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "white",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			},
			{
				"name": "yellow",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "dojo/_base/Color"
			}
		]
	},
	"havok/form/ColorPicker": {
		"location": "havok/form/ColorPicker",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"dijit/_WidgetsInTemplateMixin",
			"havok/form/_FormWidgetMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/ColorPicker"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/ColorPicker"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "value",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/ColorPicker"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onBoxClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onBoxHandleClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onBoxHandleMoved",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onHueClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onHueHandleClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onHueHandleMoved",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ColorPicker",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/HexColor": {
		"location": "havok/form/HexColor",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/ValidationTextBox",
		"mixins": [
			"havok/form/ValidationTextBox"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/HexColor"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/HexColor"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "validator",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/HexColor"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/HexColor",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/ValidationTextBox": {
		"location": "havok/form/ValidationTextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/TextBox",
		"mixins": [
			"havok/form/TextBox",
			"havok/form/_ValidationMixin",
			"havok/form/_ValidationMessagesMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/TextBox": {
		"location": "havok/form/TextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/form/_TextBoxMixin",
			"havok/form/_AppendageMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_TextBoxMixin": {
		"location": "havok/form/_TextBoxMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/_FormWidgetMixin",
		"mixins": [
			"havok/form/_FormWidgetMixin",
			"havok/form/_FilterMixin"
		],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			}
		],
		"methods": [
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_FilterMixin": {
		"location": "havok/form/_FilterMixin",
		"type": "constructor",
		"classlike": true,
		"methods": [
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			}
		]
	},
	"havok/form/_AppendageMixin": {
		"location": "havok/form/_AppendageMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_ValidationMixin": {
		"location": "havok/form/_ValidationMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/_ValidationStyleMixin",
		"mixins": [
			"havok/form/_ValidationStyleMixin",
			"havok/form/_ValidationMessagesMixin"
		],
		"properties": [
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "havok/form/_ValidationMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"summary": "<p>Shows current state (ie, validation result) of input (&#39;&#39; | Incomplete | Error | Validating)\nAn empty string indicates successful validation.\nState will start as <code>Validating</code> until validation has executed the first time.</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			}
		],
		"methods": [
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"mystique/Result": {
		"location": "mystique/Result",
		"type": "function",
		"parameters": [
			{
				"name": "options",
				"types": [
					"undefined"
				],
				"usage": "required"
			}
		],
		"returnTypes": [],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "mystique/Result",
				"parameters": [
					{
						"name": "options",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/form/_ValidationStyleMixin": {
		"location": "havok/form/_ValidationStyleMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			}
		],
		"methods": [
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_ValidationMessagesMixin": {
		"location": "havok/form/_ValidationMessagesMixin",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/_MessagesMixin",
		"mixins": [
			"havok/form/_MessagesMixin"
		],
		"properties": [
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			}
		],
		"methods": [
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"mystique/Required": {
		"location": "mystique/Required",
		"type": "undefined"
	},
	"mystique/Base": {
		"location": "mystique/Base",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "mystique/Base",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "extend",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "mystique/Base",
				"parameters": [
					{
						"name": "mixin",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"function"
				]
			}
		]
	},
	"mystique/NotRequired": {
		"location": "mystique/NotRequired",
		"type": "undefined"
	},
	"mystique/Chain": {
		"location": "mystique/Chain",
		"type": "undefined"
	},
	"mystique/HexColor": {
		"location": "mystique/HexColor",
		"type": "undefined"
	},
	"havok/widget/DropdownToggle": {
		"location": "havok/widget/DropdownToggle",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_HideableMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/DropdownToggle"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_HideableMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "placement",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/DropdownToggle"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/DropdownToggle"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandlers",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeKeypressHandlers",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "position",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/DropdownContainer": {
		"location": "havok/widget/DropdownContainer",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_DropdownBase",
		"mixins": [
			"havok/widget/_DropdownBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownContainer",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			},
			{
				"name": "watchChildHasMouse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "childWidget",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/_DropdownBase": {
		"location": "havok/widget/_DropdownBase",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			},
			{
				"name": "watchChildHasMouse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "childWidget",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/Moveable": {
		"location": "havok/widget/Moveable",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/_WidgetBase",
		"mixins": [
			"dijit/_WidgetBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "focused",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"extensionModule": true,
				"summary": "<p>This widget or a widget it contains has focus, or is &quot;active&quot; because\nit was recently clicked.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Construct the UI for this widget, setting this.domNode.\nMost widgets will mixin <code>dijit._TemplatedMixin</code>, which implements this method.</p>\n"
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "keypress",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "mousedown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "mousemove",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "mouseup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "move",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [
					{
						"name": "x",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "y",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "setLastPosition",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Moveable",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they stop being active,\nsuch as changing CSS classes.  See onBlur() for more details.</p>\n"
			},
			{
				"name": "_onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they are active,\nsuch as changing CSS classes.  See onFocus() for more details.</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget stops being &quot;active&quot; because\nfocus moved to something outside of it, or the user\nclicked somewhere outside of it, or the widget was\nhidden.</p>\n"
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget becomes &quot;active&quot; because\nit or a widget inside of it either has focus, or has recently\nbeen clicked.</p>\n"
			}
		]
	},
	"havok/form/CreditCardExpiry": {
		"location": "havok/form/CreditCardExpiry",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/Form",
		"mixins": [
			"havok/form/Form",
			"dijit/_WidgetsInTemplateMixin",
			"havok/form/_FormWidgetMixin",
			"havok/form/_ValidationMessagesMixin",
			"havok/form/_ValidationStyleMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/form/_FormMixin",
				"tags": [
					"readonly"
				],
				"summary": "<p>Will be &quot;Error&quot; if one or more of the child widgets has an invalid value,\n&quot;Incomplete&quot; if not all of the required child widgets are filled in.  Otherwise, &quot;&quot;,\nwhich indicates that the form is ready to be submitted.</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/CreditCardExpiry"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDescendantFormWidgets",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "children",
						"types": [
							"dijit/_WidgetBase[]"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all form widget descendants, searching through non-form child widgets like BorderContainer</p>\n"
			},
			{
				"name": "_getInvalidWidgetsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Compute what this.state should be based on state of children</p>\n"
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns Object representing form values.   See description of <code>value</code> for details.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setInputsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"havok/array"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPostActivityAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fill in form values from according to an Object (in the format returned by get(&#39;value&#39;))</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "connectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "inStartup",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>You can call this function directly, ex. in the event that you\nprogrammatically add a widget to the form <em>after</em> the form has been\ninitialized.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "disconnectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Deprecated method.   Applications no longer need to call this.   Remove for 2.0.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "getValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::getValues() is deprecated. Use get('value') instead. -- will be removed in version: 2.0"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "isValid",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if all of the widgets are valid.\nDeprecated, will be removed in 2.0.  Use get(&quot;state&quot;) instead.</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CreditCardExpiry",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "reset",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "setValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::setValues() is deprecated. Use set('value', val) instead. -- will be removed in version: 2.0"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CreditCardExpiry",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>returns if the form is valid - same as isValid - but\nprovides a few additional (ui-specific) features:\n\n</p>\n<ol>\n<li>it will highlight any sub-widgets that are not valid</li>\n<li>it will call focus() on the first invalid sub-widget</li>\n</ol>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onChildChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called when child&#39;s value or disabled state changes</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onValidStateChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "isValid",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Stub function to connect to if you want to do something\n(like disable/enable a submit button) when the valid\nstate changes on the form as a whole.\n\n</p>\n<p>Deprecated.  Will be removed in 2.0.  Use watch(&quot;state&quot;, ...) instead.</p>\n"
			}
		]
	},
	"havok/form/Form": {
		"location": "havok/form/Form",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/form/_FormMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/form/_FormMixin",
				"tags": [
					"readonly"
				],
				"summary": "<p>Will be &quot;Error&quot; if one or more of the child widgets has an invalid value,\n&quot;Incomplete&quot; if not all of the required child widgets are filled in.  Otherwise, &quot;&quot;,\nwhich indicates that the form is ready to be submitted.</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/Form"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDescendantFormWidgets",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "children",
						"types": [
							"dijit/_WidgetBase[]"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all form widget descendants, searching through non-form child widgets like BorderContainer</p>\n"
			},
			{
				"name": "_getInvalidWidgetsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Compute what this.state should be based on state of children</p>\n"
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Returns Object representing form values.   See description of <code>value</code> for details.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setInputsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"havok/array"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPostActivityAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Fill in form values from according to an Object (in the format returned by get(&#39;value&#39;))</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "connectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "inStartup",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>You can call this function directly, ex. in the event that you\nprogrammatically add a widget to the form <em>after</em> the form has been\ninitialized.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "disconnectChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Deprecated method.   Applications no longer need to call this.   Remove for 2.0.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "getValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::getValues() is deprecated. Use get('value') instead. -- will be removed in version: 2.0"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "isValid",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Returns true if all of the widgets are valid.\nDeprecated, will be removed in 2.0.  Use get(&quot;state&quot;) instead.</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "reset",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "setValues",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"deprecated": "undefined::setValues() is deprecated. Use set('value', val) instead. -- will be removed in version: 2.0"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>returns if the form is valid - same as isValid - but\nprovides a few additional (ui-specific) features:\n\n</p>\n<ol>\n<li>it will highlight any sub-widgets that are not valid</li>\n<li>it will call focus() on the first invalid sub-widget</li>\n</ol>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onChildChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"private": true,
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called when child&#39;s value or disabled state changes</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onValidStateChange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_FormMixin",
				"parameters": [
					{
						"name": "isValid",
						"types": [
							"Boolean"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Stub function to connect to if you want to do something\n(like disable/enable a submit button) when the valid\nstate changes on the form as a whole.\n\n</p>\n<p>Deprecated.  Will be removed in 2.0.  Use watch(&quot;state&quot;, ...) instead.</p>\n"
			}
		]
	},
	"mystique/CreditCardExpiry": {
		"location": "mystique/CreditCardExpiry",
		"type": "undefined"
	},
	"havok/form/Select": {
		"location": "havok/form/Select",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"dijit/_WidgetsInTemplateMixin",
			"havok/form/_FormWidgetMixin",
			"havok/form/_DropdownMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/Select",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/Select"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryOptionsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryThrottleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setQueryOptionsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setQueryThrottleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/_DropdownMixin": {
		"location": "havok/form/_DropdownMixin",
		"type": "constructor",
		"classlike": true,
		"methods": [
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryOptionsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryThrottleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setQueryOptionsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setQueryThrottleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/Dropdown": {
		"location": "havok/widget/Dropdown",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_DropdownBase",
		"mixins": [
			"havok/widget/_DropdownBase",
			"havok/widget/_StoreMixin",
			"havok/widget/_ListMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_removeKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			},
			{
				"name": "watchChildHasMouse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "childWidget",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/string": {
		"location": "havok/string",
		"type": "object",
		"summary": "<p>String utilities for Dojo</p>\n",
		"methods": [
			{
				"name": "pad",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "text",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the string to pad</p>\n"
					},
					{
						"name": "size",
						"types": [
							"Integer"
						],
						"usage": "required",
						"summary": "<p>length to provide padding</p>\n"
					},
					{
						"name": "ch",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>character to pad, defaults to &#39;0&#39;</p>\n"
					},
					{
						"name": "end",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>adds padding at the end if true, otherwise pads at start</p>\n"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Pad a string to guarantee that it is at least <code>size</code> length by\nfilling with the character <code>ch</code> at either the start or end of the\nstring. Pads at the start, by default.</p>\n",
				"examples": [
					"<pre><code>// Fill the string to length 10 with &quot;+&quot; characters on the right.  Yields &quot;Dojo++++++&quot;.\nstring.pad(&quot;Dojo&quot;, 10, &quot;+&quot;, true);</code></pre>\n"
				]
			},
			{
				"name": "rep",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>the string to replicate</p>\n"
					},
					{
						"name": "num",
						"types": [
							"Integer"
						],
						"usage": "required",
						"summary": "<p>number of times to replicate the string</p>\n"
					}
				],
				"returnTypes": [
					"string",
					"undefined"
				],
				"summary": "<p>Efficiently replicate a string <code>n</code> times.</p>\n"
			},
			{
				"name": "substitute",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "template",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>a string with expressions in the form <code>${key}</code> to be replaced or\n<code>${key:format}</code> which specifies a format function. keys are case-sensitive.</p>\n"
					},
					{
						"name": "map",
						"types": [
							"Object",
							"Array"
						],
						"usage": "required",
						"summary": "<p>hash to search for substitutions</p>\n"
					},
					{
						"name": "transform",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>a function to process all parameters before substitution takes\nplace, e.g. mylib.encodeXML</p>\n"
					},
					{
						"name": "thisObject",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>where to look for optional format function; default to the global\nnamespace</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Performs parameterized substitutions on a string. Throws an\nexception if any parameter is unmatched.</p>\n",
				"examples": [
					"<p>Substitutes two expressions in a string from an Array or Object\n\n</p>\n<pre><code>// returns &quot;File &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\n// by providing substitution data in an Array\nstring.substitute(\n    &quot;File &#39;${0}&#39; is not found in directory &#39;${1}&#39;.&quot;,\n    [&quot;foo.html&quot;,&quot;/temp&quot;]\n);\n\n// also returns &quot;File &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\n// but provides substitution data in an Object structure.  Dotted\n// notation may be used to traverse the structure.\nstring.substitute(\n    &quot;File &#39;${name}&#39; is not found in directory &#39;${info.dir}&#39;.&quot;,\n    { name: &quot;foo.html&quot;, info: { dir: &quot;/temp&quot; } }\n);</code></pre>\n",
					"<p>Use a transform function to modify the values:\n\n</p>\n<pre><code>// returns &quot;file &#39;foo.html&#39; is not found in directory &#39;/temp&#39;.&quot;\nstring.substitute(\n    &quot;${0} is not found in ${1}.&quot;,\n    [&quot;foo.html&quot;,&quot;/temp&quot;],\n    function(str){\n        // try to figure out the type\n        var prefix = (str.charAt(0) == &quot;/&quot;) ? &quot;directory&quot;: &quot;file&quot;;\n        return prefix + &quot; &#39;&quot; + str + &quot;&#39;&quot;;\n    }\n);</code></pre>\n",
					"<p>Use a formatter\n\n</p>\n<pre><code>// returns &quot;thinger -- howdy&quot;\nstring.substitute(\n    &quot;${0:postfix}&quot;, [&quot;thinger&quot;], null, {\n        postfix: function(value, key){\n            return value + &quot; -- howdy&quot;;\n        }\n    }\n);</code></pre>\n"
				]
			},
			{
				"name": "trim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/string",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>String to be trimmed</p>\n"
					}
				],
				"returnTypes": [
					"String",
					"string"
				],
				"returnDescription": "<p>Returns the trimmed string</p>\n",
				"summary": "<p>Trims whitespace from both sides of the string</p>\n",
				"description": "<p>This version of trim() was taken from <a href=\"http://blog.stevenlevithan.com/archives/faster-trim-javascript\">Steven Levithan&#39;s blog</a>.\nThe short yet performant version of this function is dojo.trim(),\nwhich is part of Dojo base.  Uses String.prototype.trim instead, if available.</p>\n"
			},
			{
				"name": "ucFirst",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/string",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Makes the first letter of a string uppercase</p>\n"
			}
		]
	},
	"havok/widget/DropdownSubmenu": {
		"location": "havok/widget/DropdownSubmenu",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/DropdownToggle",
		"mixins": [
			"havok/widget/DropdownToggle"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/DropdownSubmenu"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_HideableMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "placement",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/DropdownSubmenu"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/DropdownSubmenu"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandlers",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeKeypressHandlers",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "position",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownSubmenu",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownSubmenu",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DropdownToggle",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/form/ValidationGroup": {
		"location": "havok/form/ValidationGroup",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/form/_FormWidgetMixin",
			"havok/form/_ValidationMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "havok/form/_ValidationMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"summary": "<p>Shows current state (ie, validation result) of input (&#39;&#39; | Incomplete | Error | Validating)\nAn empty string indicates successful validation.\nState will start as <code>Validating</code> until validation has executed the first time.</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/ValidationGroup"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/ValidationGroup"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ValidationGroup",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ValidationGroup",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/CurrencyTextBox": {
		"location": "havok/form/CurrencyTextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/ValidationTextBox",
		"mixins": [
			"havok/form/ValidationTextBox",
			"havok/form/_NumberTextBoxMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "currency",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/CurrencyTextBox"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "placeholder",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/CurrencyTextBox"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "validator",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/CurrencyTextBox"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_formatter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"__FormatOptions"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Format a Number as a currency, using locale-specific settings\n</p>\n",
				"description": "<p>Create a string from a Number using a known, localized pattern.\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Elements\">Formatting patterns</a>\nappropriate to the locale are chosen from the <a href=\"http://unicode.org/cldr\">CLDR</a>\nas well as the appropriate symbols and delimiters and number of decimal places.\n</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_parser",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"private": true,
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>type (String, optional): <p>Should not be set.  Value is assumed to be currency.</p>\n</li><li>currency (String, optional): <p>an <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code, a three letter sequence like &quot;USD&quot;.\nFor use with dojo.currency only.</p>\n</li><li>symbol (String, optional): <p>localized currency symbol. The default will be looked up in table of supported currencies in <code>dojo.cldr</code>\nA <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code will be used if not found.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to accept.  The default is determined based on which currency is used.</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by the currency\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.\nBy default for currencies, it the fractional portion is optional.</p>\n</li><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setCurrencyAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"number.__FormatOptions"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				],
				"summary": "<p>Formats the value as a Number, according to constraints.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/CurrencyTextBox",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"number.__FormatOptions"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"String",
					"undefined"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a number value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/currency": {
		"location": "dojo/currency",
		"type": "object",
		"summary": "<p>localized formatting and parsing routines for currencies</p>\n",
		"description": "<p>extends dojo.number to provide culturally-appropriate formatting of values\nin various world currencies, including use of a currency symbol.  The currencies are specified\nby a three-letter international symbol in all uppercase, and support for the currencies is\nprovided by the data in <code>dojo.cldr</code>.  The scripts generating dojo.cldr specify which\ncurrency support is included.  A fixed number of decimal places is determined based\non the currency type and is not determined by the &#39;pattern&#39; argument.  The fractional\nportion is optional, by default, and variable length decimals are not supported.</p>\n",
		"methods": [
			{
				"name": "__FormatOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/currency",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__ParseOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/currency",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_mixInDefaults",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"private": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "format",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"__FormatOptions"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Format a Number as a currency, using locale-specific settings\n</p>\n",
				"description": "<p>Create a string from a Number using a known, localized pattern.\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Elements\">Formatting patterns</a>\nappropriate to the locale are chosen from the <a href=\"http://unicode.org/cldr\">CLDR</a>\nas well as the appropriate symbols and delimiters and number of decimal places.\n</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>type (String, optional): <p>Should not be set.  Value is assumed to be currency.</p>\n</li><li>currency (String, optional): <p>an <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code, a three letter sequence like &quot;USD&quot;.\nFor use with dojo.currency only.</p>\n</li><li>symbol (String, optional): <p>localized currency symbol. The default will be looked up in table of supported currencies in <code>dojo.cldr</code>\nA <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code will be used if not found.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to accept.  The default is determined based on which currency is used.</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by the currency\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.\nBy default for currencies, it the fractional portion is optional.</p>\n</li><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "regexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/currency",
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>places (Number|String, optional): <p>number of decimal places to accept: Infinity, a positive number, or\na range &quot;n,m&quot;.  Defined by pattern or Infinity if pattern not provided.</p>\n</li></ul>"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dojo/currency.__FormatOptions": {
		"location": "dojo/currency.__FormatOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "currency",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/currency",
				"summary": "<p>an <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code, a three letter sequence like &quot;USD&quot;.\nFor use with dojo.currency only.</p>\n"
			},
			{
				"name": "fractional",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/number",
				"summary": "<p>If false, show no decimal places, overriding places and pattern settings.</p>\n"
			},
			{
				"name": "locale",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override the locale used to determine formatting rules</p>\n"
			},
			{
				"name": "pattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "places",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/currency",
				"summary": "<p>number of decimal places to show.  Default is defined based on which currency is used.</p>\n"
			},
			{
				"name": "round",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/number",
				"summary": "<p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n"
			},
			{
				"name": "symbol",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/currency",
				"summary": "<p>localized currency symbol. The default will be looked up in table of supported currencies in <code>dojo.cldr</code>\nA <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code will be used if not found.</p>\n"
			},
			{
				"name": "type",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/currency",
				"summary": "<p>Should not be set.  Value is assumed to be &quot;currency&quot;.</p>\n"
			}
		]
	},
	"dojo/currency.__ParseOptions": {
		"location": "dojo/currency.__ParseOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "currency",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/currency",
				"summary": "<p>an <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code, a three letter sequence like &quot;USD&quot;.\nFor use with dojo.currency only.</p>\n"
			},
			{
				"name": "fractional",
				"scope": "prototype",
				"types": [
					"Boolean",
					"Array"
				],
				"from": "dojo/currency",
				"summary": "<p>Whether to include the fractional portion, where the number of decimal places are implied by the currency\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.\nBy default for currencies, it the fractional portion is optional.</p>\n"
			},
			{
				"name": "locale",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override the locale used to determine formatting rules</p>\n"
			},
			{
				"name": "pattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/number",
				"summary": "<p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "places",
				"scope": "prototype",
				"types": [
					"Number"
				],
				"from": "dojo/currency",
				"summary": "<p>fixed number of decimal places to accept.  The default is determined based on which currency is used.</p>\n"
			},
			{
				"name": "strict",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/number",
				"summary": "<p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n"
			},
			{
				"name": "symbol",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/currency",
				"summary": "<p>localized currency symbol. The default will be looked up in table of supported currencies in <code>dojo.cldr</code>\nA <a href=\"http://en.wikipedia.org/wiki/ISO_4217\">ISO4217</a> currency code will be used if not found.</p>\n"
			},
			{
				"name": "type",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/currency",
				"summary": "<p>Should not be set.  Value is assumed to be currency.</p>\n"
			}
		]
	},
	"havok/form/_NumberTextBoxMixin": {
		"location": "havok/form/_NumberTextBoxMixin",
		"type": "constructor",
		"classlike": true,
		"methods": [
			{
				"name": "_formatter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				],
				"summary": "<p>Format a Number as a String, using locale-specific settings</p>\n",
				"description": "<p>Create a string from a Number using a known localized pattern.\nFormatting patterns appropriate to the locale are chosen from the\n<a href=\"http://unicode.org/cldr\">Common Locale Data Repository</a> as well as the appropriate symbols and\ndelimiters.\nIf value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</p>\n"
			},
			{
				"name": "_parser",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representation of a Number</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by pattern\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Convert a properly formatted string to a primitive Number, using\nlocale-specific settings.</p>\n",
				"description": "<p>Create a Number from a string using a known localized pattern.\nFormatting patterns are chosen appropriate to the locale\nand follow the syntax described by\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">unicode.org TR35</a>\nNote that literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Formats the value as a Number, according to constraints.</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Formats the value as a Number, according to constraints.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a number value</p>\n"
			}
		]
	},
	"havok/validator/Currency": {
		"location": "havok/validator/Currency",
		"type": "undefined"
	},
	"havok/form/DateTextBox": {
		"location": "havok/form/DateTextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/ValidationTextBox",
		"mixins": [
			"havok/form/ValidationTextBox",
			"dijit/_WidgetsInTemplateMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "formatLength",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/DateTextBox"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "placeholder",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/DateTextBox"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/DateTextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "validator",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/DateTextBox"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_dropdownToggleWatcher",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/DateTextBox",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/DateTextBox",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/DateTextBox",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/DateTextBox",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/DateTextBox",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/DateTextBox",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"dojo/date/locale": {
		"location": "dojo/date/locale",
		"type": "object",
		"summary": "<p>This modules defines dojo/date/locale, localization methods for Date.</p>\n",
		"methods": [
			{
				"name": "__FormatOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/date/locale",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_getDayOfYear",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"private": true,
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>gets the day of the year as represented by dateObject</p>\n"
			},
			{
				"name": "_getGregorianBundle",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"private": true,
				"parameters": [
					{
						"name": "locale",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getWeekOfYear",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"private": true,
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required"
					},
					{
						"name": "firstDayOfWeek",
						"types": [
							"Number"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_getZone",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"private": true,
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>the date and/or time being formatted.\n</p>\n"
					},
					{
						"name": "getName",
						"types": [
							"boolean"
						],
						"usage": "required",
						"summary": "<p>Whether to return the timezone string (if true), or the offset (if false)\n</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The options being used for formatting</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>selector (String): <p>choice of &#39;time&#39;,&#39;date&#39; (default: date and time)</p>\n</li><li>formatLength (String): <p>choice of long, short, medium or full (plus any custom additions).  Defaults to &#39;short&#39;</p>\n</li><li>datePattern (String): <p>override pattern with this string</p>\n</li><li>timePattern (String): <p>override pattern with this string</p>\n</li><li>am (String): <p>override strings for am in times</p>\n</li><li>pm (String): <p>override strings for pm in times</p>\n</li><li>locale (String): <p>override the locale used to determine formatting rules</p>\n</li><li>fullYear (Boolean): <p>(format only) use 4 digit years whenever 2 digit years are called for</p>\n</li><li>strict (Boolean): <p>(parse only) strict parsing, off by default</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns the zone (or offset) for the given date and options.  This\nis broken out into a separate function so that it can be overridden\nby timezone-aware code.\n</p>\n"
			},
			{
				"name": "_parseInfo",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"private": true,
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>selector (String): <p>choice of &#39;time&#39;,&#39;date&#39; (default: date and time)</p>\n</li><li>formatLength (String): <p>choice of long, short, medium or full (plus any custom additions).  Defaults to &#39;short&#39;</p>\n</li><li>datePattern (String): <p>override pattern with this string</p>\n</li><li>timePattern (String): <p>override pattern with this string</p>\n</li><li>am (String): <p>override strings for am in times</p>\n</li><li>pm (String): <p>override strings for pm in times</p>\n</li><li>locale (String): <p>override the locale used to determine formatting rules</p>\n</li><li>fullYear (Boolean): <p>(format only) use 4 digit years whenever 2 digit years are called for</p>\n</li><li>strict (Boolean): <p>(parse only) strict parsing, off by default</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "addCustomFormats",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"parameters": [
					{
						"name": "packageName",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "bundleName",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Add a reference to a bundle containing localized custom formats to be\nused by date/time formatting and parsing routines.\n</p>\n",
				"description": "<p>The user may add custom localized formats where the bundle has properties following the\nsame naming convention used by dojo.cldr: <code>dateFormat-xxxx</code> / <code>timeFormat-xxxx</code>\nThe pattern string should match the format used by the CLDR.\nSee dojo/date/locale.format() for details.\nThe resources must be loaded by dojo.requireLocalization() prior to use</p>\n"
			},
			{
				"name": "format",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>the date and/or time to be formatted.  If a time only is formatted,\nthe values in the year, month, and day fields are irrelevant.  The\nopposite is true when formatting only dates.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>selector (String): <p>choice of &#39;time&#39;,&#39;date&#39; (default: date and time)</p>\n</li><li>formatLength (String): <p>choice of long, short, medium or full (plus any custom additions).  Defaults to &#39;short&#39;</p>\n</li><li>datePattern (String): <p>override pattern with this string</p>\n</li><li>timePattern (String): <p>override pattern with this string</p>\n</li><li>am (String): <p>override strings for am in times</p>\n</li><li>pm (String): <p>override strings for pm in times</p>\n</li><li>locale (String): <p>override the locale used to determine formatting rules</p>\n</li><li>fullYear (Boolean): <p>(format only) use 4 digit years whenever 2 digit years are called for</p>\n</li><li>strict (Boolean): <p>(parse only) strict parsing, off by default</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Format a Date object as a String, using locale-specific settings.\n</p>\n",
				"description": "<p>Create a string from a Date object using a known localized pattern.\nBy default, this method formats both date and time from dateObject.\nFormatting patterns are chosen appropriate to the locale.  Different\nformatting lengths may be chosen, with &quot;full&quot; used by default.\nCustom patterns may be used or registered with translations using\nthe dojo/date/locale.addCustomFormats() method.\nFormatting patterns are implemented using <a href=\"http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns\">the syntax described at\nunicode.org</a>\n</p>\n"
			},
			{
				"name": "getNames",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"parameters": [
					{
						"name": "item",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>&#39;months&#39; || &#39;days&#39;</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>&#39;wide&#39; || &#39;abbr&#39; || &#39;narrow&#39; (e.g. &quot;Monday&quot;, &quot;Mon&quot;, or &quot;M&quot; respectively, in English)</p>\n"
					},
					{
						"name": "context",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>&#39;standAlone&#39; || &#39;format&#39; (default)</p>\n"
					},
					{
						"name": "locale",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>override locale used to find the names</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Used to get localized strings from dojo.cldr for day or month names.\n</p>\n"
			},
			{
				"name": "isWeekend",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "optional"
					},
					{
						"name": "locale",
						"types": [
							"String"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Determines if the date falls on a weekend, according to local custom.</p>\n"
			},
			{
				"name": "parse",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representation of a date</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>selector (String): <p>choice of &#39;time&#39;,&#39;date&#39; (default: date and time)</p>\n</li><li>formatLength (String): <p>choice of long, short, medium or full (plus any custom additions).  Defaults to &#39;short&#39;</p>\n</li><li>datePattern (String): <p>override pattern with this string</p>\n</li><li>timePattern (String): <p>override pattern with this string</p>\n</li><li>am (String): <p>override strings for am in times</p>\n</li><li>pm (String): <p>override strings for pm in times</p>\n</li><li>locale (String): <p>override the locale used to determine formatting rules</p>\n</li><li>fullYear (Boolean): <p>(format only) use 4 digit years whenever 2 digit years are called for</p>\n</li><li>strict (Boolean): <p>(parse only) strict parsing, off by default</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				],
				"summary": "<p>Convert a properly formatted string to a primitive Date object,\nusing locale-specific settings.\n</p>\n",
				"description": "<p>Create a Date object from a string using a known localized pattern.\nBy default, this method parses looking for both date and time in the string.\nFormatting patterns are chosen appropriate to the locale.  Different\nformatting lengths may be chosen, with &quot;full&quot; used by default.\nCustom patterns may be used or registered with translations using\nthe dojo/date/locale.addCustomFormats() method.\n\n</p>\n<p>Formatting patterns are implemented using <a href=\"http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns\">the syntax described at\nunicode.org</a>\nWhen two digit years are used, a century is chosen according to a sliding\nwindow of 80 years before and 20 years after present year, for both <code>yy</code> and <code>yyyy</code> patterns.\nyear &lt; 100CE requires strict mode.\n</p>\n"
			},
			{
				"name": "regexp",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date/locale",
				"parameters": [
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>selector (String): <p>choice of &#39;time&#39;,&#39;date&#39; (default: date and time)</p>\n</li><li>formatLength (String): <p>choice of long, short, medium or full (plus any custom additions).  Defaults to &#39;short&#39;</p>\n</li><li>datePattern (String): <p>override pattern with this string</p>\n</li><li>timePattern (String): <p>override pattern with this string</p>\n</li><li>am (String): <p>override strings for am in times</p>\n</li><li>pm (String): <p>override strings for pm in times</p>\n</li><li>locale (String): <p>override the locale used to determine formatting rules</p>\n</li><li>fullYear (Boolean): <p>(format only) use 4 digit years whenever 2 digit years are called for</p>\n</li><li>strict (Boolean): <p>(parse only) strict parsing, off by default</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Builds the regular needed to parse a localized date</p>\n"
			}
		]
	},
	"dojo/date/locale.__FormatOptions": {
		"location": "dojo/date/locale.__FormatOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "am",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>override strings for am in times</p>\n"
			},
			{
				"name": "datePattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>override pattern with this string</p>\n"
			},
			{
				"name": "formatLength",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>choice of long, short, medium or full (plus any custom additions).  Defaults to &#39;short&#39;</p>\n"
			},
			{
				"name": "fullYear",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/date/locale",
				"summary": "<p>(format only) use 4 digit years whenever 2 digit years are called for</p>\n"
			},
			{
				"name": "locale",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>override the locale used to determine formatting rules</p>\n"
			},
			{
				"name": "pm",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>override strings for pm in times</p>\n"
			},
			{
				"name": "selector",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>choice of &#39;time&#39;,&#39;date&#39; (default: date and time)</p>\n"
			},
			{
				"name": "strict",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/date/locale",
				"summary": "<p>(parse only) strict parsing, off by default</p>\n"
			},
			{
				"name": "timePattern",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/date/locale",
				"summary": "<p>override pattern with this string</p>\n"
			}
		]
	},
	"dojo/date": {
		"location": "dojo/date",
		"type": "object",
		"summary": "<p>Date manipulation utilities</p>\n",
		"methods": [
			{
				"name": "add",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"parameters": [
					{
						"name": "date",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Date object to start with</p>\n"
					},
					{
						"name": "interval",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representing the interval.  One of the following:\n&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;,\n&quot;millisecond&quot;, &quot;quarter&quot;, &quot;week&quot;, &quot;weekday&quot;</p>\n"
					},
					{
						"name": "amount",
						"types": [
							"int"
						],
						"usage": "required",
						"summary": "<p>How much to add to the date.</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Add to a Date in intervals of different size, from milliseconds to years</p>\n"
			},
			{
				"name": "compare",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"parameters": [
					{
						"name": "date1",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Date object</p>\n"
					},
					{
						"name": "date2",
						"types": [
							"Date"
						],
						"usage": "optional",
						"summary": "<p>Date object.  If not specified, the current Date is used.</p>\n"
					},
					{
						"name": "portion",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>A string indicating the &quot;date&quot; or &quot;time&quot; portion of a Date object.\nCompares both &quot;date&quot; and &quot;time&quot; by default.  One of the following:\n&quot;date&quot;, &quot;time&quot;, &quot;datetime&quot;</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Compare two date objects by date, time, or both.</p>\n",
				"description": "<p>Returns 0 if equal, positive if a &gt; b, else negative.</p>\n"
			},
			{
				"name": "difference",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"parameters": [
					{
						"name": "date1",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Date object</p>\n"
					},
					{
						"name": "date2",
						"types": [
							"Date"
						],
						"usage": "optional",
						"summary": "<p>Date object.  If not specified, the current Date is used.</p>\n"
					},
					{
						"name": "interval",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>A string representing the interval.  One of the following:\n&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;,\n&quot;millisecond&quot;, &quot;quarter&quot;, &quot;week&quot;, &quot;weekday&quot;\n\n</p>\n<p>Defaults to &quot;day&quot;.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Get the difference in a specific unit of time (e.g., number of\nmonths, weeks, days, etc.) between two dates, rounded to the\nnearest integer.</p>\n"
			},
			{
				"name": "getDaysInMonth",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns the number of days in the month used by dateObject</p>\n"
			},
			{
				"name": "getTimezoneName",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required",
						"summary": "<p>Needed because the timezone may vary with time (daylight savings)</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Get the user&#39;s time zone as provided by the browser</p>\n",
				"description": "<p>Try to get time zone info from toString or toLocaleString method of\nthe Date object -- UTC offset is not a time zone.  See\n<a href=\"http://www.twinsun.com/tz/tz-link.htm\">http://www.twinsun.com/tz/tz-link.htm</a> Note: results may be\ninconsistent across browsers.</p>\n"
			},
			{
				"name": "isLeapYear",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/date",
				"parameters": [
					{
						"name": "dateObject",
						"types": [
							"Date"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Determines if the year of the dateObject is a leap year</p>\n",
				"description": "<p>Leap years are years with an additional day YYYY-02-29, where the\nyear number is a multiple of four with the following exception: If\na year is a multiple of 100, then it is only a leap year if it is\nalso a multiple of 400. For example, 1900 was not a leap year, but\n2000 is one.</p>\n"
			}
		]
	},
	"dojo/cldr/supplemental": {
		"location": "dojo/cldr/supplemental",
		"type": "object",
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "_region",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/cldr/supplemental",
				"private": true,
				"parameters": [
					{
						"name": "locale",
						"types": [
							"String"
						],
						"usage": "optional"
					}
				],
				"returnTypes": []
			},
			{
				"name": "getFirstDayOfWeek",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/cldr/supplemental",
				"parameters": [
					{
						"name": "locale",
						"types": [
							"String"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a zero-based index for first day of the week</p>\n",
				"description": "<p>Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.\ne.g. Sunday (returns 0), or Monday (returns 1)</p>\n"
			},
			{
				"name": "getWeekend",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/cldr/supplemental",
				"parameters": [
					{
						"name": "locale",
						"types": [
							"String"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns a hash containing the start and end days of the weekend</p>\n",
				"description": "<p>Returns a hash containing the start and end days of the weekend according to local custom using locale,\nor by default in the user&#39;s locale.\ne.g. {start:6, end:0}</p>\n"
			}
		]
	},
	"havok/widget/DateDropdown": {
		"location": "havok/widget/DateDropdown",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_DropdownBase",
		"mixins": [
			"havok/widget/_DropdownBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_mode",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/DateDropdown",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/DateDropdown"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/DateDropdown"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fill",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_fillDay",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_fillMonth",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_fillYear",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setDateAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			},
			{
				"name": "watchChildHasMouse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "childWidget",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onNext",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onPrev",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onSelect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/DateDropdown",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"mystique/Date": {
		"location": "mystique/Date",
		"type": "undefined"
	},
	"havok/form/EmailTextBox": {
		"location": "havok/form/EmailTextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/ValidationTextBox",
		"mixins": [
			"havok/form/ValidationTextBox"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/EmailTextBox"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "validator",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/EmailTextBox"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"mystique/Email": {
		"location": "mystique/Email",
		"type": "undefined"
	},
	"havok/form/NumberTextBox": {
		"location": "havok/form/NumberTextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/TextBox",
		"mixins": [
			"havok/form/TextBox",
			"havok/form/_NumberTextBoxMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_formatter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>the number to be formatted</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>places (Number, optional): <p>fixed number of decimal places to show.  This overrides any\ninformation in the provided pattern.</p>\n</li><li>round (Number, optional): <p>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1\nmeans do not round.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>fractional (Boolean, optional): <p>If false, show no decimal places, overriding places and pattern settings.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				],
				"summary": "<p>Format a Number as a String, using locale-specific settings</p>\n",
				"description": "<p>Create a string from a Number using a known localized pattern.\nFormatting patterns appropriate to the locale are chosen from the\n<a href=\"http://unicode.org/cldr\">Common Locale Data Repository</a> as well as the appropriate symbols and\ndelimiters.\nIf value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_parser",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_NumberTextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "expression",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>A string representation of a Number</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"description": "<p>An object with the following properties:</p><ul><li>pattern (String, optional): <p>override <a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">formatting pattern</a>\nwith this string.  Default value is based on locale.  Overriding this property will defeat\nlocalization.  Literal characters in patterns are not supported.</p>\n</li><li>type (String, optional): <p>choose a format type based on the locale from the following:\ndecimal, scientific (not yet supported), percent, currency. decimal by default.</p>\n</li><li>locale (String, optional): <p>override the locale used to determine formatting rules</p>\n</li><li>strict (Boolean, optional): <p>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.\nNon-strict is more permissive, e.g. flexible on white space, omitting thousands separators</p>\n</li><li>fractional (Boolean|Array, optional): <p>Whether to include the fractional portion, where the number of decimal places are implied by pattern\nor explicit &#39;places&#39; parameter.  The value [true,false] makes the fractional portion optional.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>Convert a properly formatted string to a primitive Number, using\nlocale-specific settings.</p>\n",
				"description": "<p>Create a Number from a string using a known localized pattern.\nFormatting patterns are chosen appropriate to the locale\nand follow the syntax described by\n<a href=\"http://www.unicode.org/reports/tr35/#Number_Format_Patterns\">unicode.org TR35</a>\nNote that literal characters in patterns are not supported.</p>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/PasswordTextBox": {
		"location": "havok/form/PasswordTextBox",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/ValidationTextBox",
		"mixins": [
			"havok/form/ValidationTextBox"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/PasswordTextBox"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "validator",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/PasswordTextBox"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"mystique/Password": {
		"location": "mystique/Password",
		"type": "undefined"
	},
	"mystique/Length": {
		"location": "mystique/Length",
		"type": "undefined"
	},
	"havok/form/RadioGroup": {
		"location": "havok/form/RadioGroup",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/RadioGroup",
		"mixins": [
			"havok/widget/RadioGroup",
			"havok/form/_FormWidgetMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/ButtonGroup"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/RadioGroup"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/RadioGroup",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/RadioGroup",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/RadioGroup",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/RadioGroup",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/RadioGroup": {
		"location": "havok/widget/RadioGroup",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/ButtonGroup",
		"mixins": [
			"havok/widget/ButtonGroup"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/ButtonGroup"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ButtonGroup",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/RadioGroup",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/form/TextEditor": {
		"location": "havok/form/TextEditor",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/TextEditor",
		"mixins": [
			"havok/widget/TextEditor",
			"havok/form/_FilterMixin",
			"havok/form/_ValidationMixin",
			"havok/form/_FormWidgetMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/TextEditor"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "havok/form/_ValidationMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"summary": "<p>Shows current state (ie, validation result) of input (&#39;&#39; | Incomplete | Error | Validating)\nAn empty string indicates successful validation.\nState will start as <code>Validating</code> until validation has executed the first time.</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/TextEditor"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getTextAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setTextAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/TextEditor",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/TextEditor",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/TextEditor",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/TextEditor": {
		"location": "havok/widget/TextEditor",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"dijit/_WidgetsInTemplateMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/TextEditor"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getTextAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setTextAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextEditor",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/TextToolbar": {
		"location": "havok/widget/TextToolbar",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"dijit/_WidgetsInTemplateMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_buttonCommands",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/widget/TextToolbar",
				"private": true
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_groups",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/widget/TextToolbar",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "_toggleCommands",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/widget/TextToolbar",
				"private": true
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/TextToolbar"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "view",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/TextToolbar"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_resize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setViewAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "execCommand",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [
					{
						"name": "command",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "args",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getCurrentRange",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "restoreSelection",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "saveSelection",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateToolbar",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TextToolbar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/Tooltip": {
		"location": "havok/widget/Tooltip",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_HideableMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Tooltip"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "eventHide",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Tooltip"
			},
			{
				"name": "eventShow",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Tooltip"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/Tooltip"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "placement",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Tooltip"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Tooltip"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Tooltip",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_position",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Tooltip",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Tooltip",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Tooltip",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Tooltip",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/ToggleButton": {
		"location": "havok/widget/ToggleButton",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/Button",
		"mixins": [
			"havok/widget/Button"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "keyTarget",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/_KeypressMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Button"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_resetKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ToggleButton",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setKeysAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setKeyTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Button",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ToggleButton",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ToggleButton",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/form/Textarea": {
		"location": "havok/form/Textarea",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/form/_TextBoxMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/Textarea"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Textarea",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Textarea",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/ToggleButton": {
		"location": "havok/form/ToggleButton",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/ToggleButton",
		"mixins": [
			"havok/widget/ToggleButton",
			"havok/form/_FormWidgetMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "keyTarget",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/_KeypressMixin"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Button"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "value",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/ToggleButton"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ToggleButton",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_removeKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_resetKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ToggleButton",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setKeysAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setKeyTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_KeypressMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_LabelMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/ToggleButton",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Button",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ToggleButton",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/ToggleButton",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ActivityMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/Typeahead": {
		"location": "havok/form/Typeahead",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/ValidationTextBox",
		"mixins": [
			"havok/form/ValidationTextBox",
			"dijit/_WidgetsInTemplateMixin",
			"havok/form/_DropdownMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_earlyTemplatedStartup",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"private": true,
				"summary": "<p>A fallback to preserve the 1.0 - 1.3 behavior of children in\ntemplates having their startup called before the parent widget\nfires postCreate. Defaults to &#39;false&#39;, causing child widgets to\nhave their .startup() called immediately before a parent widget\n.startup(), but always after the parent .postCreate(). Set to\n&#39;true&#39; to re-enable to previous, arguably broken, behavior.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "contextRequire",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"summary": "<p>Used to provide a context require to the dojo/parser in order to be\nable to use relative MIDs (e.g. <code>./Widget</code>) in the widget&#39;s template.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxItems",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/Typeahead"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "minLength",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/Typeahead"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "prepend",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/_AppendageMixin",
				"summary": "<p>An array of prepend nodes.</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/form/Typeahead"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			},
			{
				"name": "widgetsInTemplate",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetsInTemplateMixin",
				"tags": [
					"protected"
				],
				"summary": "<p>Should we parse the template to find widgets that might be\ndeclared in markup inside it?  (Remove for 2.0 and assume true)</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createAppendagesWrapper",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryOptionsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryThrottleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_removeAppendages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "prepend",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAppendAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setMaxItemsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Typeahead",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPrependAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setQueryOptionsAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setQueryThrottleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_DropdownMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_valueWatcher",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Typeahead",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addAppendage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "addPrependage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_AppendageMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Typeahead",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/TypeaheadDropdown": {
		"location": "havok/form/TypeaheadDropdown",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/Dropdown",
		"mixins": [
			"havok/widget/Dropdown"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Dropdown"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_DropdownBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_addKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/TypeaheadDropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_highlight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/TypeaheadDropdown",
				"private": true,
				"parameters": [
					{
						"name": "text",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/TypeaheadDropdown",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_removeKeypressHandler",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dropdown",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			},
			{
				"name": "watchChildHasMouse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "childWidget",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_DropdownBase",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/form/ValidationTextarea": {
		"location": "havok/form/ValidationTextarea",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/form/Textarea",
		"mixins": [
			"havok/form/Textarea",
			"havok/form/_ValidationMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "__skipInputEvent",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_focusManager",
				"scope": "prototype",
				"types": [
					"instance"
				],
				"from": "dijit/_FocusMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setValueTimestamp",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true
			},
			{
				"name": "_skipFocusFormat",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "blockTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "delay",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_ValidationMixin"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "filter",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "inlineTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_FormWidgetMixin"
			},
			{
				"name": "inputClasses",
				"scope": "prototype",
				"types": [
					"array"
				],
				"from": "havok/form/_TextBoxMixin",
				"summary": "<p>An array of css classes to be applied directly to the native input tag</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "maxMessageId",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messageObjects",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/form/_MessagesMixin"
			},
			{
				"name": "messagePosition",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_MessagesMixin",
				"summary": "<p>Possible values are:\nauto: if the message is one line, display inline. If it is multiline, display block\ninline: always display message inline. If the message is more than one line, only the first will be shown.\nblock: always display message as block, even when there is only one line.</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "requiredStarTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_RequiredStarMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "state",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/_TextBoxMixin"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "suppressValidationMessages",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationMessagesMixin"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/form/Textarea"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "validationStyle",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/form/_ValidationStyleMixin"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getChildrenState",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "_getLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_RequiredStarMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_processValidationResult",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "resultObject",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "timestamp",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null"
				]
			},
			{
				"name": "_renderMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setFilterAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the filter. The value must be an instance of Base parameter may be one of three\ntypes:\n\n</p>\n<p>Instance of Base - the filter property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of filters, or filter definitions.\nThe array will be passed to filterFactory.create(). The validator property\nwill be set to the returned instance of FilterGroup\n\n</p>\n<p>Object - an an object, it is assumbed to be a filter definition.\nThe definition will be passed to filterFactory.create(). The filter property\nwill be set to the returned instance of BaseValdiator\n</p>\n"
			},
			{
				"name": "_setHelpMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setLabelAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlaceholderAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_setSuppressValidationAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSuppressValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationMessagesAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [
					{
						"name": "messages",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidationStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setValidatorAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Will set the validator. May be one of three\ntypes:\n\n</p>\n<p>Instance of mystique/Base - the validator property is set equal to this instance.\n\n</p>\n<p>Array - if an array, it is assumed to be an array of validators, or validator definitions.\nThe array will be passed to validatorFactory.create(). The validator property\nwill be set to the returned instance of Validator/Group\n\n</p>\n<p>Object - an an object, it is assumbed to be a validator definition.\nThe definition will be passed to havok/validator/factory.create(). The validator property\nwill be set to the returned instance of mytique/Base</p>\n"
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_startValidateTimer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_triggerValidate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [
					{
						"name": "property",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "oldValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "newValue",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_updateValidationMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_validate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "applyFilter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_FilterMixin",
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"instance"
				]
			},
			{
				"name": "blurFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Textarea",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "focusFormat",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Replaceable function to convert a value to a properly formatted string.</p>\n"
			},
			{
				"name": "formatHelpMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_HelpMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string"
				]
			},
			{
				"name": "formatValidationMessage",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMessagesMixin",
				"parameters": [
					{
						"name": "message",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"null",
					"undefined"
				]
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "parse",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"tags": [
					"extension",
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "constraints",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String"
				],
				"summary": "<p>Replaceable function to convert a formatted string to a value</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/Textarea",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateMessages",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_MessagesMixin",
				"parameters": [
					{
						"name": "messagesToAdd",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "messageObjectsToRemove",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "updateValidationStyle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationStyleMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "validateNow",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_ValidationMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"private": true,
				"parameters": [
					{
						"name": "evt",
						"types": [
							"Event"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Called AFTER the input event has happened</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/form/_TextBoxMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/form/main": {
		"location": "havok/form/main",
		"type": "undefined"
	},
	"dijit/form/_ExpandingTextAreaMixin": {
		"location": "dijit/form/_ExpandingTextAreaMixin",
		"type": "constructor",
		"classlike": true,
		"summary": "<p>Mixin for textarea widgets to add auto-expanding capability</p>\n",
		"methods": [
			{
				"name": "_estimateHeight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Approximate the height when the textarea is invisible with the number of lines in the text.\nFails when someone calls setValue with a long wrapping line, but the layout fixes itself when the user clicks inside so . . .\nIn IE, the resize event is supposed to fire when the textarea becomes visible again and that will correct the size automatically.\n</p>\n"
			},
			{
				"name": "_resizeLater",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_setValueAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "resize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Resizes the textarea vertically (should be called after a style/value change)</p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"parameters": [],
				"returnTypes": []
			}
		],
		"events": [
			{
				"name": "_onInput",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/form/_ExpandingTextAreaMixin",
				"private": true,
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dijit/Viewport": {
		"location": "dijit/Viewport",
		"type": "object",
		"summary": "<p>Utility singleton to watch for viewport resizes, avoiding duplicate notifications\nwhich can lead to infinite loops.</p>\n",
		"description": "<p>Usage: Viewport.on(&quot;resize&quot;, myCallback).\n\n</p>\n<p>myCallback() is called without arguments in case it&#39;s _WidgetBase.resize(),\nwhich would interpret the argument as the size to make the widget.</p>\n"
	},
	"havok/less": {
		"location": "havok/less",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/less",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/main": {
		"location": "havok/main",
		"type": "undefined"
	},
	"havok/parseComplete": {
		"location": "havok/parseComplete",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/parseComplete",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/router/main": {
		"location": "havok/router/main",
		"type": "undefined"
	},
	"havok/router/started": {
		"location": "havok/router/started",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/router/started",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/router/router": {
		"location": "havok/router/router",
		"type": "object",
		"properties": [
			{
				"name": "routes",
				"scope": "normal",
				"types": [
					"array"
				],
				"from": "havok/router/router"
			}
		],
		"methods": [
			{
				"name": "go",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/router/router",
				"parameters": [
					{
						"name": "route",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "surpressPushState",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				]
			},
			{
				"name": "resolve",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/router/router",
				"parameters": [
					{
						"name": "route",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "startup",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/router/router",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/router/exception/RouteNotFound": {
		"location": "havok/router/exception/RouteNotFound",
		"type": "undefined"
	},
	"havok/router/baseUrl": {
		"location": "havok/router/baseUrl",
		"type": "object",
		"methods": [
			{
				"name": "load",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/router/baseUrl",
				"parameters": [
					{
						"name": "id",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "require",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "callback",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/store/main": {
		"location": "havok/store/main",
		"type": "undefined"
	},
	"havok/store/manager": {
		"location": "havok/store/manager",
		"type": "object",
		"properties": [
			{
				"name": "stores",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/store/manager"
			}
		],
		"methods": [
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/store/manager",
				"parameters": [
					{
						"name": "ref",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "getStore",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/store/manager",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"havok/store/manager.stores": {
		"location": "havok/store/manager.stores",
		"type": "object"
	},
	"havok/widget/main": {
		"location": "havok/widget/main",
		"type": "undefined"
	},
	"havok/widget/Accordion": {
		"location": "havok/widget/Accordion",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Accordion"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "itemTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Accordion"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getToggleFx",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Accordion",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_renderItem",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Accordion",
				"private": true,
				"parameters": [
					{
						"name": "srcNode",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "_toggleItem",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Accordion",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Accordion",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Accordion",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"dojo/_base/fx": {
		"location": "dojo/_base/fx",
		"type": "object",
		"summary": "<p>This module defines the base dojo/_base/fx implementation.</p>\n",
		"methods": [
			{
				"name": "_defaultEasing",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>The default easing function for Animation(s)</p>\n"
			},
			{
				"name": "_fade",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns an animation that will fade the node defined by\nargs.node from the start to end values passed (args.start\nargs.end) (end is mandatory, start is optional)</p>\n"
			},
			{
				"name": "_Line",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"private": true,
				"parameters": [
					{
						"name": "start",
						"types": [
							"int"
						],
						"usage": "required",
						"summary": "<p>Beginning value for range</p>\n"
					},
					{
						"name": "end",
						"types": [
							"int"
						],
						"usage": "required",
						"summary": "<p>Ending value for range</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Object used to generate values from a start value to an end value</p>\n"
			},
			{
				"name": "anim",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required",
						"summary": "<p>a DOM node or the id of a node to animate CSS properties on</p>\n"
					},
					{
						"name": "properties",
						"types": [
							"Object"
						],
						"usage": "required"
					},
					{
						"name": "duration",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The number of milliseconds over which the animation\nshould run. Defaults to the global animation default duration\n(350ms).</p>\n"
					},
					{
						"name": "easing",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>An easing function over which to calculate acceleration\nand deceleration of the animation through its duration.\nA default easing algorithm is provided, but you may\nplug in any you wish. A large selection of easing algorithms\nare available in <code>dojo/fx/easing</code>.</p>\n"
					},
					{
						"name": "onEnd",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>A function to be called when the animation finishes\nrunning.</p>\n"
					},
					{
						"name": "delay",
						"types": [
							"Integer"
						],
						"usage": "optional",
						"summary": "<p>The number of milliseconds to delay beginning the\nanimation by. The default is 0.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>A simpler interface to <code>animateProperty()</code>, also returns\nan instance of <code>Animation</code> but begins the animation\nimmediately, unlike nearly every other Dojo animation API.</p>\n",
				"description": "<p>Simpler (but somewhat less powerful) version\nof <code>animateProperty</code>.  It uses defaults for many basic properties\nand allows for positional parameters to be used in place of the\npacked &quot;property bag&quot; which is used for other Dojo animation\nmethods.\n\n</p>\n<p>The <code>Animation</code> object returned will be already playing, so\ncalling play() on it again is (usually) a no-op.</p>\n",
				"examples": [
					"<p>Fade out a node\n\n</p>\n<pre><code>basefx.anim(&quot;id&quot;, { opacity: 0 });</code></pre>\n",
					"<p>Fade out a node over a full second\n\n</p>\n<pre><code>basefx.anim(&quot;id&quot;, { opacity: 0 }, 1000);</code></pre>\n"
				]
			},
			{
				"name": "animateProperty",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>properties (Object, optional): <p>A hash map of style properties to Objects describing the transition,\nsuch as the properties of _Line with an additional &#39;units&#39; property</p>\n</li><li>node (DOMNode|String): <p>The node referenced in the animation</p>\n</li><li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p>\n</li><li>easing (Function, optional): <p>An easing function.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"instance",
					"undefined"
				],
				"summary": "<p>Returns an animation that will transition the properties of\nnode defined in <code>args</code> depending how they are defined in\n<code>args.properties</code>\n</p>\n",
				"description": "<p>Foundation of most <code>dojo/_base/fx</code>\nanimations. It takes an object of &quot;properties&quot; corresponding to\nstyle properties, and animates them in parallel over a set\nduration.\n</p>\n",
				"examples": [
					"<p>A simple animation that changes the width of the specified node.\n\n</p>\n<pre><code>basefx.animateProperty({\n    node: &quot;nodeId&quot;,\n    properties: { width: 400 },\n}).play();</code></pre>\n<p>Dojo figures out the start value for the width and converts the\n\n</p>\n<p>integer specified for the width to the more expressive but\nverbose form <code>{ width: { end: &#39;400&#39;, units: &#39;px&#39; } }</code> which you\ncan also specify directly. Defaults to &#39;px&#39; if omitted.\n</p>\n",
					"<p>Animate width, height, and padding over 2 seconds... the\npedantic way:\n\n</p>\n<pre><code>basefx.animateProperty({ node: node, duration:2000,\n    properties: {\n        width: { start: &#39;200&#39;, end: &#39;400&#39;, units:&quot;px&quot; },\n        height: { start:&#39;200&#39;, end: &#39;400&#39;, units:&quot;px&quot; },\n        paddingTop: { start:&#39;5&#39;, end:&#39;50&#39;, units:&quot;px&quot; }\n    }\n}).play();</code></pre>\n<p>Note &#39;paddingTop&#39; is used over &#39;padding-top&#39;. Multi-name CSS properties\n\n</p>\n<p>are written using &quot;mixed case&quot;, as the hyphen is illegal as an object key.\n</p>\n",
					"<p>Plug in a different easing function and register a callback for\nwhen the animation ends. Easing functions accept values between\nzero and one and return a value on that basis. In this case, an\nexponential-in curve.\n\n</p>\n<pre><code>basefx.animateProperty({\n    node: &quot;nodeId&quot;,\n    // dojo figures out the start value\n    properties: { width: { end: 400 } },\n    easing: function(n){\n        return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));\n    },\n    onEnd: function(node){\n        // called when the animation finishes. The animation\n        // target is passed to this function\n    }\n}).play(500); // delay playing half a second</code></pre>\n",
					"<p>Like all <code>Animation</code>s, animateProperty returns a handle to the\nAnimation instance, which fires the events common to Dojo FX. Use <code>aspect.after</code>\nto access these events outside of the Animation definition:\n\n</p>\n<pre><code>var anim = basefx.animateProperty({\n    node:&quot;someId&quot;,\n    properties:{\n        width:400, height:500\n    }\n});\naspect.after(anim, &quot;onEnd&quot;, function(){\n    console.log(&quot;animation ended&quot;);\n}, true);\n// play the animation now:\nanim.play();</code></pre>\n",
					"<p>Each property can be a function whose return value is substituted along.\nAdditionally, each measurement (eg: start, end) can be a function. The node\nreference is passed directly to callbacks.\n\n</p>\n<pre><code>basefx.animateProperty({\n    node:&quot;mine&quot;,\n    properties:{\n        height:function(node){\n            // shrink this node by 50%\n            return domGeom.position(node).h / 2\n        },\n        width:{\n            start:function(node){ return 100; },\n            end:function(node){ return 200; }\n        }\n    }\n}).play();</code></pre>\n"
				]
			},
			{
				"name": "Animation",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The &#39;magic argument&#39;, mixing all the properties into this\nanimation instance.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>A generic animation class that fires callbacks into its handlers\nobject at various states.</p>\n",
				"description": "<p>A generic animation class that fires callbacks into its handlers\nobject at various states. Nearly all dojo animation functions\nreturn an instance of this method, usually without calling the\n.play() method beforehand. Therefore, you will likely need to\ncall .play() on instances of <code>Animation</code> when one is\nreturned.</p>\n"
			},
			{
				"name": "fadeIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>node (DOMNode|String): <p>The node referenced in the animation</p>\n</li><li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p>\n</li><li>easing (Function, optional): <p>An easing function.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns an animation that will fade node defined in &#39;args&#39; from\nits current opacity to fully opaque.</p>\n"
			},
			{
				"name": "fadeOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>node (DOMNode|String): <p>The node referenced in the animation</p>\n</li><li>duration (Integer, optional): <p>Duration of the animation in milliseconds.</p>\n</li><li>easing (Function, optional): <p>An easing function.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Returns an animation that will fade node defined in &#39;args&#39;\nfrom its current opacity to fully transparent.</p>\n"
			}
		]
	},
	"dojo/fx": {
		"location": "dojo/fx",
		"type": "object",
		"summary": "<p>Effects library on top of Base animations</p>\n",
		"properties": [
			{
				"name": "easing",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"summary": "<p>Collection of easing functions to use beyond the default\n<code>dojo._defaultEasing</code> function.</p>\n",
				"description": "<p>Easing functions are used to manipulate the iteration through\nan <code>dojo.Animation</code>s _Line. _Line being the properties of an Animation,\nand the easing function progresses through that Line determining\nhow quickly (or slowly) it should go. Or more accurately: modify\nthe value of the _Line based on the percentage of animation completed.\n\n</p>\n<p>All functions follow a simple naming convention of &quot;ease type&quot; + &quot;when&quot;.\nIf the name of the function ends in Out, the easing described appears\ntowards the end of the animation. &quot;In&quot; means during the beginning,\nand InOut means both ranges of the Animation will applied, both\nbeginning and end.\n\n</p>\n<p>One does not call the easing function directly, it must be passed to\nthe <code>easing</code> property of an animation.</p>\n",
				"examples": [
					"<pre><code>dojo.require(&quot;dojo.fx.easing&quot;);\nvar anim = dojo.fadeOut({\n    node: &#39;node&#39;,\n    duration: 2000,\n    //  note there is no ()\n    easing: dojo.fx.easing.quadIn\n}).play();</code></pre>\n"
				]
			}
		],
		"methods": [
			{
				"name": "chain",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"parameters": [
					{
						"name": "animations",
						"types": [
							"dojo/_base/fx.Animation[]"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Chain a list of <code>dojo.Animation</code>s to run in sequence\n</p>\n",
				"description": "<p>Return a <code>dojo.Animation</code> which will play all passed\n<code>dojo.Animation</code> instances in sequence, firing its own\nsynthesized events simulating a single animation. (eg:\nonEnd of this animation means the end of the chain,\nnot the individual animations within)\n</p>\n",
				"examples": [
					"<p>Once <code>node</code> is faded out, fade in <code>otherNode</code>\n\n</p>\n<pre><code>fx.chain([\n    dojo.fadeIn({ node:node }),\n    dojo.fadeOut({ node:otherNode })\n]).play();</code></pre>\n"
				]
			},
			{
				"name": "combine",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"parameters": [
					{
						"name": "animations",
						"types": [
							"dojo/_base/fx.Animation[]"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>Combine a list of <code>dojo.Animation</code>s to run in parallel\n</p>\n",
				"description": "<p>Combine an array of <code>dojo.Animation</code>s to run in parallel,\nproviding a new <code>dojo.Animation</code> instance encompasing each\nanimation, firing standard animation events.\n</p>\n",
				"examples": [
					"<p>Fade out <code>node</code> while fading in <code>otherNode</code> simultaneously\n\n</p>\n<pre><code>fx.combine([\n    dojo.fadeIn({ node:node }),\n    dojo.fadeOut({ node:otherNode })\n]).play();</code></pre>\n",
					"<p>When the longest animation ends, execute a function:\n\n</p>\n<pre><code>var anim = fx.combine([\n    dojo.fadeIn({ node: n, duration:700 }),\n    dojo.fadeOut({ node: otherNode, duration: 300 })\n]);\naspect.after(anim, &quot;onEnd&quot;, function(){\n    // overall animation is done.\n}, true);\nanim.play(); // play the animation</code></pre>\n"
				]
			},
			{
				"name": "slideTo",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>A hash-map of standard <code>dojo.Animation</code> constructor properties\n(such as easing: node: duration: and so on). Special args members\nare <code>top</code> and <code>left</code>, which indicate the new position to slide to.\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Slide a node to a new top/left position\n</p>\n",
				"description": "<p>Returns an animation that will slide &quot;node&quot;\ndefined in args Object from its current position to\nthe position defined by (args.left, args.top).\n</p>\n",
				"examples": [
					"<pre><code>.slideTo({ node: node, left:&quot;40&quot;, top:&quot;50&quot;, units:&quot;px&quot; }).play()</code></pre>\n"
				]
			},
			{
				"name": "wipeIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>A hash-map of standard <code>dojo.Animation</code> constructor properties\n(such as easing: node: duration: and so on)\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Expand a node to it&#39;s natural height.\n</p>\n",
				"description": "<p>Returns an animation that will expand the\nnode defined in &#39;args&#39; object from it&#39;s current height to\nit&#39;s natural height (with no scrollbar).\nNode must have no margin/border/padding.\n</p>\n",
				"examples": [
					"<pre><code>fx.wipeIn({\n    node:&quot;someId&quot;\n}).play()</code></pre>\n"
				]
			},
			{
				"name": "wipeOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>A hash-map of standard <code>dojo.Animation</code> constructor properties\n(such as easing: node: duration: and so on)\n</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Shrink a node to nothing and hide it.\n</p>\n",
				"description": "<p>Returns an animation that will shrink node defined in &quot;args&quot;\nfrom it&#39;s current height to 1px, and then hide it.\n</p>\n",
				"examples": [
					"<pre><code>fx.wipeOut({ node:&quot;someId&quot; }).play()</code></pre>\n"
				]
			}
		]
	},
	"dojo/fx.easing": {
		"location": "dojo/fx.easing",
		"type": "object",
		"summary": "<p>Collection of easing functions to use beyond the default\n<code>dojo._defaultEasing</code> function.</p>\n",
		"description": "<p>Easing functions are used to manipulate the iteration through\nan <code>dojo.Animation</code>s _Line. _Line being the properties of an Animation,\nand the easing function progresses through that Line determining\nhow quickly (or slowly) it should go. Or more accurately: modify\nthe value of the _Line based on the percentage of animation completed.\n\n</p>\n<p>All functions follow a simple naming convention of &quot;ease type&quot; + &quot;when&quot;.\nIf the name of the function ends in Out, the easing described appears\ntowards the end of the animation. &quot;In&quot; means during the beginning,\nand InOut means both ranges of the Animation will applied, both\nbeginning and end.\n\n</p>\n<p>One does not call the easing function directly, it must be passed to\nthe <code>easing</code> property of an animation.</p>\n",
		"examples": [
			"<pre><code>dojo.require(&quot;dojo.fx.easing&quot;);\nvar anim = dojo.fadeOut({\n    node: &#39;node&#39;,\n    duration: 2000,\n    //  note there is no ()\n    easing: dojo.fx.easing.quadIn\n}).play();</code></pre>\n"
		],
		"methods": [
			{
				"name": "backIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that starts away from the target,\nand quickly accelerates towards the end value.\n\n</p>\n<p>Use caution when the easing will cause values to become\nnegative as some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "backInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function combining the effects of <code>backIn</code> and <code>backOut</code></p>\n",
				"description": "<p>An easing function combining the effects of <code>backIn</code> and <code>backOut</code>.\nUse caution when the easing will cause values to become negative\nas some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "backOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that pops past the range briefly, and slowly comes back.</p>\n",
				"description": "<p>An easing function that pops past the range briefly, and slowly comes back.\n\n</p>\n<p>Use caution when the easing will cause values to become negative as some\nproperties cannot be set to negative values.</p>\n"
			},
			{
				"name": "bounceIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that &#39;bounces&#39; near the beginning of an Animation</p>\n"
			},
			{
				"name": "bounceInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that &#39;bounces&#39; at the beginning and end of the Animation</p>\n"
			},
			{
				"name": "bounceOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that &#39;bounces&#39; near the end of an Animation</p>\n"
			},
			{
				"name": "circIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "circInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "circOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "cubicIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "cubicInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "cubicOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "elasticIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Decimal",
					"number"
				],
				"summary": "<p>An easing function the elastically snaps from the start value</p>\n",
				"description": "<p>An easing function the elastically snaps from the start value\n\n</p>\n<p>Use caution when the elasticity will cause values to become negative\nas some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "elasticInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that elasticly snaps around the value, near\nthe beginning and end of the Animation.</p>\n",
				"description": "<p>An easing function that elasticly snaps around the value, near\nthe beginning and end of the Animation.\n\n</p>\n<p>Use caution when the elasticity will cause values to become\nnegative as some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "elasticOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Decimal",
					"number"
				],
				"summary": "<p>An easing function that elasticly snaps around the target value,\nnear the end of the Animation</p>\n",
				"description": "<p>An easing function that elasticly snaps around the target value,\nnear the end of the Animation\n\n</p>\n<p>Use caution when the elasticity will cause values to become\nnegative as some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "expoIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "expoInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "expoOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "linear",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Decimal"
				],
				"summary": "<p>A linear easing function</p>\n"
			},
			{
				"name": "quadIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "quadInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quadOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quartIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "quartInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quartOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quintIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "quintInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quintOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "sineIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "sineInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "sineOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"extensionModule": true,
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"dojo/fx/easing": {
		"location": "dojo/fx/easing",
		"type": "object",
		"summary": "<p>Collection of easing functions to use beyond the default\n<code>dojo._defaultEasing</code> function.</p>\n",
		"description": "<p>Easing functions are used to manipulate the iteration through\nan <code>dojo.Animation</code>s _Line. _Line being the properties of an Animation,\nand the easing function progresses through that Line determining\nhow quickly (or slowly) it should go. Or more accurately: modify\nthe value of the _Line based on the percentage of animation completed.\n\n</p>\n<p>All functions follow a simple naming convention of &quot;ease type&quot; + &quot;when&quot;.\nIf the name of the function ends in Out, the easing described appears\ntowards the end of the animation. &quot;In&quot; means during the beginning,\nand InOut means both ranges of the Animation will applied, both\nbeginning and end.\n\n</p>\n<p>One does not call the easing function directly, it must be passed to\nthe <code>easing</code> property of an animation.</p>\n",
		"examples": [
			"<pre><code>dojo.require(&quot;dojo.fx.easing&quot;);\nvar anim = dojo.fadeOut({\n    node: &#39;node&#39;,\n    duration: 2000,\n    //  note there is no ()\n    easing: dojo.fx.easing.quadIn\n}).play();</code></pre>\n"
		],
		"methods": [
			{
				"name": "backIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that starts away from the target,\nand quickly accelerates towards the end value.\n\n</p>\n<p>Use caution when the easing will cause values to become\nnegative as some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "backInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function combining the effects of <code>backIn</code> and <code>backOut</code></p>\n",
				"description": "<p>An easing function combining the effects of <code>backIn</code> and <code>backOut</code>.\nUse caution when the easing will cause values to become negative\nas some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "backOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that pops past the range briefly, and slowly comes back.</p>\n",
				"description": "<p>An easing function that pops past the range briefly, and slowly comes back.\n\n</p>\n<p>Use caution when the easing will cause values to become negative as some\nproperties cannot be set to negative values.</p>\n"
			},
			{
				"name": "bounceIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that &#39;bounces&#39; near the beginning of an Animation</p>\n"
			},
			{
				"name": "bounceInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that &#39;bounces&#39; at the beginning and end of the Animation</p>\n"
			},
			{
				"name": "bounceOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that &#39;bounces&#39; near the end of an Animation</p>\n"
			},
			{
				"name": "circIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "circInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "circOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "cubicIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "cubicInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "cubicOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "elasticIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Decimal",
					"number"
				],
				"summary": "<p>An easing function the elastically snaps from the start value</p>\n",
				"description": "<p>An easing function the elastically snaps from the start value\n\n</p>\n<p>Use caution when the elasticity will cause values to become negative\nas some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "elasticInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				],
				"summary": "<p>An easing function that elasticly snaps around the value, near\nthe beginning and end of the Animation.</p>\n",
				"description": "<p>An easing function that elasticly snaps around the value, near\nthe beginning and end of the Animation.\n\n</p>\n<p>Use caution when the elasticity will cause values to become\nnegative as some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "elasticOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Decimal",
					"number"
				],
				"summary": "<p>An easing function that elasticly snaps around the target value,\nnear the end of the Animation</p>\n",
				"description": "<p>An easing function that elasticly snaps around the target value,\nnear the end of the Animation\n\n</p>\n<p>Use caution when the elasticity will cause values to become\nnegative as some properties cannot be set to negative values.</p>\n"
			},
			{
				"name": "expoIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "expoInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "expoOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "linear",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"Decimal"
				],
				"summary": "<p>A linear easing function</p>\n"
			},
			{
				"name": "quadIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "quadInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quadOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quartIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "quartInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quartOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quintIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "quintInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "quintOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "sineIn",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "sineInOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"number"
				]
			},
			{
				"name": "sineOut",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/fx/easing",
				"parameters": [
					{
						"name": "n",
						"types": [
							"Decimal"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				]
			}
		]
	},
	"havok/widget/Alert": {
		"location": "havok/widget/Alert",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_HideableMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "closeButtonTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Alert"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Alert"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_HideableMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Alert"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Alert",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Alert",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onCloseClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Alert",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/Affix": {
		"location": "havok/widget/Affix",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/_WidgetBase",
		"mixins": [
			"dijit/_WidgetBase",
			"havok/widget/_AffixMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "affix",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_AffixMixin"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "focused",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"extensionModule": true,
				"summary": "<p>This widget or a widget it contains has focus, or is &quot;active&quot; because\nit was recently clicked.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			},
			{
				"name": "viewportOffset",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/_AffixMixin"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAffixTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setAffixAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setAffixTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Construct the UI for this widget, setting this.domNode.\nMost widgets will mixin <code>dijit._TemplatedMixin</code>, which implements this method.</p>\n"
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "updateAffix",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they stop being active,\nsuch as changing CSS classes.  See onBlur() for more details.</p>\n"
			},
			{
				"name": "_onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they are active,\nsuch as changing CSS classes.  See onFocus() for more details.</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget stops being &quot;active&quot; because\nfocus moved to something outside of it, or the user\nclicked somewhere outside of it, or the widget was\nhidden.</p>\n"
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget becomes &quot;active&quot; because\nit or a widget inside of it either has focus, or has recently\nbeen clicked.</p>\n"
			}
		]
	},
	"havok/widget/_AffixMixin": {
		"location": "havok/widget/_AffixMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "affix",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_AffixMixin"
			},
			{
				"name": "viewportOffset",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/widget/_AffixMixin"
			}
		],
		"methods": [
			{
				"name": "_getAffixTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_setAffixAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setAffixTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateAffix",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_AffixMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/Carousel": {
		"location": "havok/widget/Carousel",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_StoreMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "captionTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Carousel"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "interval",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/Carousel"
			},
			{
				"name": "itemTemplate",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/Carousel"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "paused",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/Carousel"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Carousel"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_indicatorClick",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_slide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "dir",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "cycle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "next",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "pause",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "prev",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onMouseenter",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onMouseleave",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "onNext",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "onPrev",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Carousel",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/Dragable": {
		"location": "havok/widget/Dragable",
		"type": "constructor",
		"classlike": true,
		"superclass": "dijit/_WidgetBase",
		"mixins": [
			"dijit/_WidgetBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "focused",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"readonly",
					"readonly"
				],
				"extensionModule": true,
				"summary": "<p>This widget or a widget it contains has focus, or is &quot;active&quot; because\nit was recently clicked.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Construct the UI for this widget, setting this.domNode.\nMost widgets will mixin <code>dijit._TemplatedMixin</code>, which implements this method.</p>\n"
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dragable",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "dragend",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dragable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "dragstart",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dragable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "mousedown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dragable",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Dragable",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they stop being active,\nsuch as changing CSS classes.  See onBlur() for more details.</p>\n"
			},
			{
				"name": "_onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>This is where widgets do processing for when they are active,\nsuch as changing CSS classes.  See onFocus() for more details.</p>\n"
			},
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			},
			{
				"name": "onBlur",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget stops being &quot;active&quot; because\nfocus moved to something outside of it, or the user\nclicked somewhere outside of it, or the widget was\nhidden.</p>\n"
			},
			{
				"name": "onFocus",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_FocusMixin",
				"tags": [
					"callback"
				],
				"extensionModule": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called when the widget becomes &quot;active&quot; because\nit or a widget inside of it either has focus, or has recently\nbeen clicked.</p>\n"
			}
		]
	},
	"havok/widget/NavBar": {
		"location": "havok/widget/NavBar",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/NavBar"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/NavBar",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/NavBar",
				"parameters": [
					{
						"name": "e",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/NavBarLinks": {
		"location": "havok/widget/NavBarLinks",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_NavBase",
		"mixins": [
			"havok/widget/_NavBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "ariaLabelledBy",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/NavBarLinks"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/_NavBase": {
		"location": "havok/widget/_NavBase",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_StoreMixin",
			"havok/widget/_ListMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "ariaLabelledBy",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_WidgetBase",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/NavTab": {
		"location": "havok/widget/NavTab",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_NavBase",
		"mixins": [
			"havok/widget/_NavBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "ariaLabelledBy",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/NavTab",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/NavPill": {
		"location": "havok/widget/NavPill",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_NavBase",
		"mixins": [
			"havok/widget/_NavBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "ariaLabelledBy",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/NavPill",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/NavList": {
		"location": "havok/widget/NavList",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_NavBase",
		"mixins": [
			"havok/widget/_NavBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_readyToQuery",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "ariaLabelledBy",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultClass",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "dividerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "headerTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "linkTemplate",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "queryThrottle",
				"scope": "prototype",
				"types": [
					"number"
				],
				"from": "havok/widget/_StoreMixin"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "tag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_NavBase"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachClickListener",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_createDisabled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDivider",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createDropdown",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createLink",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNavHeader",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_createNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_getDataAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_getQueryAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"object"
				]
			},
			{
				"name": "_getStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setActiveAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_NavBase",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStoreAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_StoreMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/NavList",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ListMixin",
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is added to the document</p>\n",
				"description": "<p>Called after a widget and its children have been created and added to the page,\nand all related widgets have finished their create() cycle, up through postCreate().\n\n</p>\n<p>Note that startup() may be called while the widget is still hidden, for example if the widget is\ninside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.\nFor widgets that need to do layout, it&#39;s best to put that layout code inside resize(), and then\nextend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.</p>\n"
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/Overlay": {
		"location": "havok/widget/Overlay",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase",
			"havok/widget/_HideableMixin"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>A widget designed to act as a Standby/Busy/Disable/Blocking widget to indicate a\nparticular DOM node is processing and cannot be clicked on at this time.\nThis widget uses absolute positioning to apply the overlay and image.\nInspired by dojox/widget/Standby</p>\n",
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "hidden",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_HideableMixin"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/Overlay"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_position",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setHiddenAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "hide",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "show",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/Overlay",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toggle",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_HideableMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/TabContainer": {
		"location": "havok/widget/TabContainer",
		"type": "constructor",
		"classlike": true,
		"superclass": "havok/widget/_WidgetBase",
		"mixins": [
			"havok/widget/_WidgetBase"
		],
		"parameters": [
			{
				"name": "params",
				"types": [
					"Object",
					"null"
				],
				"usage": "required",
				"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
			},
			{
				"name": "srcNodeRef",
				"types": [
					"DOMNode",
					"String"
				],
				"usage": "optional",
				"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
			}
		],
		"returnTypes": [],
		"properties": [
			{
				"name": "_attachEvents",
				"scope": "prototype",
				"types": [
					"Handle[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of connections associated with data-dojo-attach-event=... in the\ntemplate</p>\n"
			},
			{
				"name": "_attachPoints",
				"scope": "prototype",
				"types": [
					"String[]"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"summary": "<p>List of widget attribute names associated with data-dojo-attach-point=... in the\ntemplate, ex: [&quot;containerNode&quot;, &quot;labelNode&quot;]</p>\n"
			},
			{
				"name": "_attrPairNames",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_blankGif",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"summary": "<p>Path to a blank 1x1 image.\nUsed by <code>&lt;img&gt;</code> nodes in templates that really get their image via CSS background-image.</p>\n"
			},
			{
				"name": "_rendered",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"summary": "<p>Not normally use, but this flag can be set by the app if the server has already rendered the template,\ni.e. already inlining the template for the widget into the main page.   Reduces _TemplatedMixin to\njust function like _AttachMixin.</p>\n"
			},
			{
				"name": "_setClassAttr",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setDirAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setIdAttr",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_setLangAttr",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "dijit/_WidgetBase",
				"private": true
			},
			{
				"name": "_skipNodeCache",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true
			},
			{
				"name": "_started",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"readonly"
				],
				"summary": "<p>startup() has completed.</p>\n"
			},
			{
				"name": "attachScope",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_AttachMixin",
				"tags": [
					"public"
				],
				"summary": "<p>Object to which attach points and events will be scoped.  Defaults\nto &#39;this&#39;.</p>\n"
			},
			{
				"name": "attributeMap",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute\nfor each XXX attribute to be mapped to the DOM.\n\n</p>\n<p>attributeMap sets up a &quot;binding&quot; between attributes (aka properties)\nof the widget and the widget&#39;s DOM.\nChanges to widget attributes listed in attributeMap will be\nreflected into the DOM.\n\n</p>\n<p>For example, calling set(&#39;title&#39;, &#39;hello&#39;)\non a TitlePane will automatically cause the TitlePane&#39;s DOM to update\nwith the new title.\n\n</p>\n<p>attributeMap is a hash where the key is an attribute of the widget,\nand the value reflects a binding to a:\n\n</p>\n<ul>\n<li><p>DOM node attribute</p>\n<p>  focus: {node: &quot;focusNode&quot;, type: &quot;attribute&quot;}\nMaps this.focus to this.focusNode.focus</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerHTML</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerHTML&quot; }\nMaps this.title to this.titleNode.innerHTML</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node innerText</p>\n<p>  title: { node: &quot;titleNode&quot;, type: &quot;innerText&quot; }\nMaps this.title to this.titleNode.innerText</p>\n</li>\n</ul>\n<ul>\n<li><p>DOM node CSS class</p>\n<p>  myClass: { node: &quot;domNode&quot;, type: &quot;class&quot; }\nMaps this.myClass to this.domNode.className</p>\n</li>\n</ul>\n<p>If the value is an array, then each element in the array matches one of the\nformats of the above list.\n\n</p>\n<p>There are also some shorthands for backwards compatibility:\n\n</p>\n<ul>\n<li>string --&gt; { node: string, type: &quot;attribute&quot; }, for example:</li>\n</ul>\n<pre><code>&quot;focusNode&quot; ---&gt; { node: &quot;focusNode&quot;, type: &quot;attribute&quot; }</code></pre>\n<ul>\n<li>&quot;&quot; --&gt; { node: &quot;domNode&quot;, type: &quot;attribute&quot; }</li>\n</ul>\n"
			},
			{
				"name": "baseClass",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"summary": "<p>Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate\nwidget state.</p>\n"
			},
			{
				"name": "class",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "dijit/_WidgetBase"
			},
			{
				"name": "containerNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>Designates where children of the source DOM node will be placed.\n&quot;Children&quot; in this case refers to both DOM nodes and widgets.\nFor example, for myWidget:\n\n\n</p>\n<pre><code>&lt;div data-dojo-type=myWidget&gt;\n    &lt;b&gt; here&#39;s a plain DOM node\n    &lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n    &lt;i&gt; and another plain DOM node &lt;/i&gt;\n&lt;/div&gt;</code></pre>\n<p>containerNode would point to:\n\n\n</p>\n<pre><code>&lt;b&gt; here&#39;s a plain DOM node\n&lt;span data-dojo-type=subWidget&gt;and a widget&lt;/span&gt;\n&lt;i&gt; and another plain DOM node &lt;/i&gt;</code></pre>\n<p>In templated widgets, &quot;containerNode&quot; is set via a\ndata-dojo-attach-point assignment.\n\n</p>\n<p>containerNode must be defined for any widget that accepts innerHTML\n(like ContentPane or BorderContainer or even Button), and conversely\nis null for widgets that don&#39;t, like TextBox.</p>\n"
			},
			{
				"name": "defaultTag",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/_WidgetBase"
			},
			{
				"name": "dir",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Bi-directional support, as defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir\">HTML DIR</a>\nattribute. Either left-to-right &quot;ltr&quot; or right-to-left &quot;rtl&quot;.  If undefined, widgets renders in page&#39;s\ndefault direction.</p>\n"
			},
			{
				"name": "domNode",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>This is our visible representation of the widget! Other DOM\nNodes may by assigned to other properties, usually through the\ntemplate system&#39;s data-dojo-attach-point syntax, but the domNode\nproperty is the canonical &quot;top level&quot; node in widget UI.</p>\n"
			},
			{
				"name": "id",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>A unique, opaque ID string that can be assigned by users or by the\nsystem. If the developer passes an ID which is known not to be\nunique, the specified ID is ignored and the system-generated ID is\nused instead.</p>\n"
			},
			{
				"name": "lang",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>Rarely used.  Overrides the default Dojo locale used to render this widget,\nas defined by the <a href=\"http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang\">HTML LANG</a> attribute.\nValue must be among the list of locales specified during by the Dojo bootstrap,\nformatted according to <a href=\"http://www.ietf.org/rfc/rfc3066.txt\">RFC 3066</a> (like en-us).</p>\n"
			},
			{
				"name": "ownerDocument",
				"scope": "prototype",
				"types": [
					"Document?"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"const"
				],
				"summary": "<p>The document this widget belongs to.  If not specified to constructor, will default to\nsrcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global</p>\n"
			},
			{
				"name": "placement",
				"scope": "prototype",
				"types": [
					"string"
				],
				"from": "havok/widget/TabContainer"
			},
			{
				"name": "searchContainerNode",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "dijit/_TemplatedMixin"
			},
			{
				"name": "srcNodeRef",
				"scope": "prototype",
				"types": [
					"DomNode"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"readonly"
				],
				"summary": "<p>pointer to original DOM node</p>\n"
			},
			{
				"name": "style",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML style attributes as cssText string or name/value hash</p>\n"
			},
			{
				"name": "templatePath",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_TemplatedMixin",
				"tags": [
					"deprecated",
					"protected"
				],
				"summary": "<p>Path to template (HTML file) for this widget relative to dojo.baseUrl.\nDeprecated: use templateString with require([... &quot;dojo/text!...&quot;], ...) instead</p>\n"
			},
			{
				"name": "templateString",
				"scope": "prototype",
				"types": [
					"undefined"
				],
				"from": "havok/widget/TabContainer"
			},
			{
				"name": "title",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>HTML title attribute.\n\n</p>\n<p>For form widgets this specifies a tooltip to display when hovering over\nthe widget (just like the native HTML title attribute).\n\n</p>\n<p>For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,\netc., it&#39;s used to specify the tab label, accordion pane title, etc.  In this case it&#39;s\ninterpreted as HTML.</p>\n"
			},
			{
				"name": "tooltip",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dijit/_WidgetBase",
				"summary": "<p>When this widget&#39;s title attribute is used to for a tab label, accordion pane title, etc.,\nthis specifies the tooltip to appear when the mouse is hovered over that text.</p>\n"
			}
		],
		"methods": [
			{
				"name": "_applyAttributes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Step during widget creation to copy  widget attributes to the\nDOM according to attributeMap and _setXXXAttr objects, and also to call\ncustom _setXXXAttr() methods.\n\n</p>\n<p>Skips over blank/false attribute values, unless they were explicitly specified\nas parameters to the widget, since those are the default anyway,\nand setting tabIndex=&quot;&quot; is different than not setting tabIndex at all.\n\n</p>\n<p>For backwards-compatibility reasons attributeMap overrides _setXXXAttr when\n_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.</p>\n"
			},
			{
				"name": "_attach",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "node",
						"types": [
							"DOMNode"
						],
						"usage": "required",
						"summary": "<p>The node to setup a listener on.</p>\n"
					},
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Event name like &quot;click&quot;.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Roughly corresponding to dojo/on, this is the default function for processing a\ndata-dojo-attach-event.  Meant to attach to DOMNodes, not to widgets.</p>\n"
			},
			{
				"name": "_attachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "rootNode",
						"types": [
							"DomNode"
						],
						"usage": "required",
						"summary": "<p>The node to search for properties. All descendants will be searched.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Iterate through the dom nodes and attach functions and nodes accordingly.</p>\n",
				"description": "<p>Map widget properties and functions to the handlers specified in\nthe dom node and it&#39;s descendants. This function iterates over all\nnodes and looks for these properties:\n\n</p>\n<ul>\n<li>dojoAttachPoint/data-dojo-attach-point</li>\n<li>dojoAttachEvent/data-dojo-attach-event</li>\n</ul>\n"
			},
			{
				"name": "_attrToDom",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "attr",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>Name of member variable (ex: &quot;focusNode&quot; maps to this.focusNode) pointing\nto DOMNode inside the widget, or alternately pointing to a subwidget</p>\n"
					},
					{
						"name": "value",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "commands",
						"types": [
							"Object"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [],
				"summary": "<p>Reflect a widget attribute (title, tabIndex, duration etc.) to\nthe widget DOM, as specified by commands parameter.\nIf commands isn&#39;t specified then it&#39;s looked up from attributeMap.\nNote some attributes like &quot;type&quot;\ncannot be processed this way as they are not mutable.</p>\n"
			},
			{
				"name": "_beforeFillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_changeAttrValue",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"Mixed"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.\n</p>\n"
					}
				],
				"returnTypes": [
					"function"
				],
				"returnDescription": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"summary": "<p>Internal helper for directly changing an attribute value.\n</p>\n",
				"description": "<p>Directly change the value of an attribute on an object, bypassing any \naccessor setter.  Also handles the calling of watch and emitting events. \nIt is designed to be used by descendent class when there are two values \nof attributes that are linked, but calling .set() is not appropriate.</p>\n"
			},
			{
				"name": "_detachTemplateNodes",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Detach and clean up the attachments made in _attachtempalteNodes.</p>\n"
			},
			{
				"name": "_fillContent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "source",
						"types": [
							"DomNode"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Relocate source contents to templated container node.\nthis.containerNode must be able to receive children, or exceptions will be thrown.</p>\n"
			},
			{
				"name": "_get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Helper function to get value for specified property stored by this._set(),\ni.e. for properties with custom setters.  Used mainly by custom getters.\n\n</p>\n<p>For example, CheckBox._getValueAttr() calls this._get(&quot;value&quot;).</p>\n"
			},
			{
				"name": "_getAttrNames",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined",
					"object"
				],
				"summary": "<p>Helper function for get() and set().\nCaches attribute name values so we don&#39;t do the string ops every time.</p>\n"
			},
			{
				"name": "_introspect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Collect metadata about this widget (only once per class, not once per instance):\n\n</p>\n<pre><code>- list of attributes with custom setters, storing in this.constructor._setterAttrs\n- generate this.constructor._onMap, mapping names like &quot;mousedown&quot; to functions like onMouseDown</code></pre>\n"
			},
			{
				"name": "_processTemplateNode",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_AttachMixin",
				"private": true,
				"parameters": [
					{
						"name": "baseNode",
						"types": [
							"DOMNode",
							"Widget"
						],
						"usage": "required"
					},
					{
						"name": "getAttrFunc",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function to get the specified property for a given DomNode/Widget.</p>\n"
					},
					{
						"name": "attachFunc",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Attaches an event handler from the specified node/widget to specified function.</p>\n"
					}
				],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Process data-dojo-attach-point and data-dojo-attach-event for given node or widget.\nReturns true if caller should process baseNode&#39;s children too.</p>\n"
			},
			{
				"name": "_set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "value",
						"types": [
							"anything"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Helper function to set new value for specified property, and call handlers\nregistered with watch() if the value has changed.</p>\n"
			},
			{
				"name": "_setOwnerDocumentAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "val",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setPlacementAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TabContainer",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setStyleAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "value",
						"types": [
							"String",
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Sets the style attribute of the widget according to value,\nwhich is either a hash like {height: &quot;5px&quot;, width: &quot;3px&quot;}\nor a plain string</p>\n",
				"description": "<p>Determines which node to set the style on based on style setting\nin attributeMap.</p>\n"
			},
			{
				"name": "_stringRepl",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_TemplatedMixin",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "tmpl",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Does substitution of ${foo} type properties in template string</p>\n"
			},
			{
				"name": "buildRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TabContainer",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "connect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "obj",
						"types": [
							"Object",
							"null"
						],
						"usage": "required"
					},
					{
						"name": "event",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					},
					{
						"name": "method",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>A handle that can be passed to <code>disconnect</code> in order to disconnect before\nthe widget is destroyed.</p>\n",
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.\n\n</p>\n<p>Connects specified obj/event to specified method of this object\nand registers for disconnect() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.connect, except with the\nimplicit use of this widget as the target object.\nEvents connected with <code>this.connect</code> are disconnected upon\ndestruction.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when foo.bar() is called, call the listener we&#39;re going to\n// provide in the scope of btn\nbtn.connect(foo, &quot;bar&quot;, function(){\n    console.debug(this.toString());\n});</code></pre>\n"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Create the widget.</p>\n"
			},
			{
				"name": "create",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object",
							"null"
						],
						"usage": "required",
						"summary": "<p>Hash of initialization parameters for widget, including scalar values (like title, duration etc.)\nand functions, typically callbacks like onClick.\nThe hash can contain any of the widget&#39;s properties, excluding read-only properties.</p>\n"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "optional",
						"summary": "<p>If a srcNodeRef (DOM node) is specified:\n\n</p>\n<ul>\n<li>use srcNodeRef.innerHTML as my contents</li>\n<li>if this is a behavioral widget then apply behavior to that srcNodeRef</li>\n<li>otherwise, replace srcNodeRef with my generated DOM tree</li>\n</ul>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kick off the life-cycle of a widget</p>\n",
				"description": "<p>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,\netc.), some of which of you&#39;ll want to override. See <a href=\"http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html\">http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html</a>\nfor a discussion of the widget creation lifecycle.\n\n</p>\n<p>Of course, adventurous developers could override create entirely, but this should\nonly be done as a last resort.</p>\n"
			},
			{
				"name": "defer",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected."
				],
				"parameters": [
					{
						"name": "fcn",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "delay",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Wrapper to setTimeout to avoid deferred functions executing\nafter the originating widget has been destroyed.\nReturns an object handle with a remove method (that returns null) (replaces clearTimeout).</p>\n"
			},
			{
				"name": "destroy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "required",
						"summary": "<p>If true, this method will leave the original DOM structure alone.\nNote: This will not yet work with _TemplatedMixin widgets</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget, but not its descendants.  Descendants means widgets inside of\nthis.containerNode.   Will also destroy any resources (including widgets) registered via this.own().\n\n</p>\n<p>This method will also destroy internal widgets such as those created from a template,\nassuming those widgets exist inside of this.domNode but outside of this.containerNode.\n\n</p>\n<p>For 2.0 it&#39;s planned that this method will also destroy descendant widgets, so apps should not\ndepend on the current ability to destroy a widget without destroying its descendants.   Generally\nthey should use destroyRecursive() for widgets with children.</p>\n"
			},
			{
				"name": "destroyDescendants",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, the preserveDom attribute is passed to all descendant\nwidget&#39;s .destroy() method. Not for use with _Templated\nwidgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Recursively destroy the children of this widget and their\ndescendants.</p>\n"
			},
			{
				"name": "destroyRecursive",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure\nalone of descendant Widgets. Note: This will NOT work with\ndijit._TemplatedMixin widgets.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroy this widget and its descendants</p>\n",
				"description": "<p>This is the generic &quot;destructor&quot; function that all widget users\nshould call to cleanly discard with a widget. Once a widget is\ndestroyed, it is removed from the manager object.</p>\n"
			},
			{
				"name": "destroyRendering",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "preserveDom",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If true, this method will leave the original DOM structure alone\nduring tear-down. Note: this will not work with _Templated\nwidgets yet.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Destroys the DOM nodes associated with this widget.</p>\n"
			},
			{
				"name": "disconnect",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Disconnects handle created by <code>connect</code>.</p>\n"
			},
			{
				"name": "emit",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "type",
						"types": [
							"String"
						],
						"usage": "required"
					},
					{
						"name": "eventObj",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "callbackArgs",
						"types": [
							"Array"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Used by widgets to signal that a synthetic event occurred, ex:\n\n</p>\n<pre><code>myWidget.emit(&quot;attrmodified-selectedChildWidget&quot;, {}).</code></pre>\n<p>Emits an event on this.domNode named type.toLowerCase(), based on eventObj.\nAlso calls onType() method, if present, and returns value from that method.\nBy default passes eventObj to callback, but will pass callbackArgs instead, if specified.\nModifies eventObj by adding missing parameters (bubbles, cancelable, widget).</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to get.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Get a property from a widget.</p>\n",
				"description": "<p>Get a named property from a widget. The property may\npotentially be retrieved via a getter method. If no getter is defined, this\njust retrieves the object&#39;s property.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_getFooAttr()</code>, calling:\n<code>myWidget.get(&quot;foo&quot;)</code> would be equivalent to calling\n<code>widget._getFooAttr()</code> and <code>myWidget.get(&quot;bar&quot;)</code>\nwould be equivalent to the expression\n<code>widget.bar2</code></p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"Array"
				],
				"summary": "<p>Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent\nis this widget.   Note that it does not return all descendants, but rather just direct children.\nAnalogous to <a href=\"https://developer.mozilla.org/en-US/docs/DOM/Node.childNodes\">Node.childNodes</a>,\nexcept containing widgets rather than DOMNodes.\n\n</p>\n<p>The result intentionally excludes internally created widgets (a.k.a. supporting widgets)\noutside of this.containerNode.\n\n</p>\n<p>Note that the array returned is a simple array.  Application code should not assume\nexistence of methods like forEach().</p>\n"
			},
			{
				"name": "getParent",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Returns the parent widget of this widget.</p>\n"
			},
			{
				"name": "isFocusable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return true if this widget can currently be focused\nand false if not</p>\n"
			},
			{
				"name": "isLeftToRight",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Return this widget&#39;s explicit or implicit orientation (true for LTR, false for RTL)</p>\n"
			},
			{
				"name": "on",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required",
						"summary": "<p>Name of event (ex: &quot;click&quot;) or extension event like touch.press.</p>\n"
					},
					{
						"name": "func",
						"types": [
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Call specified function when event occurs, ex: myWidget.on(&quot;click&quot;, function(){ ... }).</p>\n",
				"description": "<p>Call specified function when event <code>type</code> occurs, ex: <code>myWidget.on(&quot;click&quot;, function(){ ... })</code>.\nNote that the function is not run in any particular scope, so if (for example) you want it to run in the\nwidget&#39;s scope you must do <code>myWidget.on(&quot;click&quot;, lang.hitch(myWidget, func))</code>.</p>\n"
			},
			{
				"name": "own",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/Destroyable",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"any",
					"undefined"
				],
				"returnDescription": "<p>The array of specified handles, so you can do for example:\n\n</p>\n<pre><code>var handle = this.own(on(...))[0];</code></pre>\n",
				"summary": "<p>Track specified handles and remove/destroy them when this instance is destroyed, unless they were\nalready removed/destroyed manually.</p>\n"
			},
			{
				"name": "placeAt",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "reference",
						"types": [
							"String",
							"DomNode",
							"_Widget"
						],
						"usage": "required",
						"summary": "<p>Widget, DOMNode, or id of widget or DOMNode</p>\n"
					},
					{
						"name": "position",
						"types": [
							"String",
							"Int"
						],
						"usage": "optional",
						"summary": "<p>If reference is a widget (or id of widget), and that widget has an &quot;.addChild&quot; method,\nit will be called passing this widget instance into that method, supplying the optional\nposition index passed.  In this case position (if specified) should be an integer.\n\n</p>\n<p>If reference is a DOMNode (or id matching a DOMNode but not a widget),\nthe position argument can be a numeric index or a string\n&quot;first&quot;, &quot;last&quot;, &quot;before&quot;, or &quot;after&quot;, same as dojo/dom-construct::place().</p>\n"
					}
				],
				"returnTypes": [
					"dijit/_WidgetBase",
					"function"
				],
				"returnDescription": "<p>Provides a useful return of the newly created dijit._Widget instance so you\ncan &quot;chain&quot; this function by instantiating, placing, then saving the return value\nto a variable.</p>\n",
				"summary": "<p>Place this widget somewhere in the DOM based\non standard domConstruct.place() conventions.</p>\n",
				"description": "<p>A convenience function provided in all _Widgets, providing a simple\nshorthand mechanism to put an existing (or newly created) Widget\nsomewhere in the dom, and allow chaining.</p>\n",
				"examples": [
					"<pre><code>// create a Button with no srcNodeRef, and place it in the body:\nvar button = new Button({ label:&quot;click&quot; }).placeAt(win.body());\n// now, &#39;button&#39; is still the widget reference to the newly created button\nbutton.on(&quot;click&quot;, function(e){ console.log(&#39;click&#39;); }));</code></pre>\n",
					"<pre><code>// create a button out of a node with id=&quot;src&quot; and append it to id=&quot;wrapper&quot;:\nvar button = new Button({},&quot;src&quot;).placeAt(&quot;wrapper&quot;);</code></pre>\n",
					"<pre><code>// place a new button as the first element of some div\nvar button = new Button({ label:&quot;click&quot; }).placeAt(&quot;wrapper&quot;,&quot;first&quot;);</code></pre>\n",
					"<pre><code>// create a contentpane and add it to a TabContainer\nvar tc = dijit.byId(&quot;myTabs&quot;);\nnew ContentPane({ href:&quot;foo.html&quot;, title:&quot;Wow!&quot; }).placeAt(tc)</code></pre>\n"
				]
			},
			{
				"name": "postCreate",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Processing after the DOM fragment is created</p>\n",
				"description": "<p>Called after the DOM fragment has been created, but not necessarily\nadded to the document.  Do not include any operations which rely on\nnode dimensions or placement.</p>\n"
			},
			{
				"name": "postMixInProperties",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Called after the parameters to the widget have been read-in,\nbut before the widget template is instantiated. Especially\nuseful to set properties that are referenced in the widget\ntemplate.</p>\n"
			},
			{
				"name": "postscript",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"tags": [
					"private"
				],
				"parameters": [
					{
						"name": "params",
						"types": [
							"Object"
						],
						"usage": "optional"
					},
					{
						"name": "srcNodeRef",
						"types": [
							"DomNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Kicks off widget instantiation.  See create() for details.</p>\n"
			},
			{
				"name": "set",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The property to set.</p>\n"
					},
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required",
						"summary": "<p>The value to set in the property.</p>\n"
					}
				],
				"returnTypes": [
					"function",
					"string"
				],
				"returnDescription": "<p>Set a property on a widget</p>\n",
				"summary": "<p>Set a property on a widget</p>\n",
				"description": "<p>Sets named properties on a widget which may potentially be handled by a\nsetter in the widget.\n\n</p>\n<p>For example, if the widget has properties <code>foo</code> and <code>bar</code>\nand a method named <code>_setFooAttr()</code>, calling\n<code>myWidget.set(&quot;foo&quot;, &quot;Howdy!&quot;)</code> would be equivalent to calling\n<code>widget._setFooAttr(&quot;Howdy!&quot;)</code> and <code>myWidget.set(&quot;bar&quot;, 3)</code>\nwould be equivalent to the statement <code>widget.bar = 3;</code>\n\n</p>\n<p>set() may also be called with a hash of name/value pairs, ex:\n\n\n</p>\n<pre><code>myWidget.set({\n    foo: &quot;Howdy&quot;,\n    bar: 3\n});</code></pre>\n<p>This is equivalent to calling <code>set(foo, &quot;Howdy&quot;)</code> and <code>set(bar, 3)</code></p>\n"
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/TabContainer",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "subscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "t",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The topic</p>\n"
					},
					{
						"name": "method",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The callback</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.\n\n</p>\n<p>Subscribes to the specified topic and calls the specified method\nof this object and registers for unsubscribe() on widget destroy.\n\n</p>\n<p>Provide widget-specific analog to dojo.subscribe, except with the\nimplicit use of this widget as the target object.</p>\n",
				"examples": [
					"<pre><code>var btn = new Button();\n// when /my/topic is published, this button changes its label to\n// be the parameter of the topic.\nbtn.subscribe(&quot;/my/topic&quot;, function(v){\n    this.set(&quot;label&quot;, v);\n});</code></pre>\n"
				]
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"summary": "<p>Returns a string that represents the widget.</p>\n",
				"description": "<p>When a widget is cast to a string, this method will be used to generate the\noutput. Currently, it does not implement any sort of reversible\nserialization.</p>\n"
			},
			{
				"name": "uninitialize",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [],
				"returnTypes": [
					"boolean"
				],
				"summary": "<p>Deprecated. Override destroy() instead to implement custom widget tear-down\nbehavior.</p>\n"
			},
			{
				"name": "unsubscribe",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"tags": [
					"protected"
				],
				"parameters": [
					{
						"name": "handle",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>Deprecated, will be removed in 2.0, use handle.remove() instead.\n\n</p>\n<p>Unsubscribes handle created by this.subscribe.\nAlso removes handle from this widget&#39;s list of subscriptions</p>\n"
			},
			{
				"name": "watch",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/Stateful",
				"parameters": [
					{
						"name": "name",
						"types": [
							"String"
						],
						"usage": "optional",
						"summary": "<p>Indicates the property to watch. This is optional (the callback may be the\nonly parameter), and if omitted, all the properties will be watched</p>\n"
					},
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The function to execute when the property changes. This will be called after\nthe property has been changed. The callback will be called with the |this|\nset to the instance, the first argument as the name of the property, the\nsecond argument as the old value and the third argument as the new value.</p>\n"
					}
				],
				"returnTypes": [
					"any",
					"object"
				],
				"returnDescription": "<p>An object handle for the watch. The unwatch method of this object\ncan be used to discontinue watching this property:\n\n</p>\n<pre><code>var watchHandle = obj.watch(&quot;foo&quot;, callback);\nwatchHandle.unwatch(); // callback won&#39;t be called now</code></pre>\n",
				"summary": "<p>Watches a property for changes</p>\n"
			}
		],
		"events": [
			{
				"name": "_onMap",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dijit/_WidgetBase",
				"private": true,
				"parameters": [
					{
						"name": "type",
						"types": [
							"String",
							"Function"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Maps on() type parameter (ex: &quot;mousemove&quot;) to method name (ex: &quot;onMouseMove&quot;).\nIf type is a synthetic event like touch.press then returns undefined.</p>\n"
			}
		]
	},
	"havok/widget/_SortableMixin": {
		"location": "havok/widget/_SortableMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "dropTargets",
				"scope": "prototype",
				"types": [
					"Array"
				],
				"from": "havok/widget/_SortableMixin"
			}
		],
		"methods": [
			{
				"name": "_makeDragable",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_SortableMixin",
				"private": true,
				"parameters": [
					{
						"name": "item",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_refresh",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_SortableMixin",
				"private": true,
				"parameters": [
					{
						"name": "data",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"havok/widget/_ScrollSpyMixin": {
		"location": "havok/widget/_ScrollSpyMixin",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "generateSpyStore",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_ScrollSpyMixin"
			},
			{
				"name": "scrollSpy",
				"scope": "prototype",
				"types": [
					"boolean"
				],
				"from": "havok/widget/_ScrollSpyMixin"
			}
		],
		"methods": [
			{
				"name": "_domToStoreData",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ScrollSpyMixin",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"undefined",
					"object"
				]
			},
			{
				"name": "_setScrollSpyAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ScrollSpyMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "_setSpyTargetAttr",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ScrollSpyMixin",
				"private": true,
				"parameters": [
					{
						"name": "value",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "startup",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ScrollSpyMixin",
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "updateScrollSpy",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/widget/_ScrollSpyMixin",
				"parameters": [],
				"returnTypes": []
			}
		]
	},
	"havok/widget/font": {
		"location": "havok/widget/font",
		"type": "instance"
	},
	"havok/widget/fontsize": {
		"location": "havok/widget/fontsize",
		"type": "instance"
	},
	"mystique/mystique": {
		"location": "mystique/mystique",
		"type": "undefined"
	},
	"mystique/Alpha": {
		"location": "mystique/Alpha",
		"type": "undefined"
	},
	"mystique/Boolean": {
		"location": "mystique/Boolean",
		"type": "undefined"
	},
	"mystique/CreditCard": {
		"location": "mystique/CreditCard",
		"type": "undefined"
	},
	"mystique/Cvv": {
		"location": "mystique/Cvv",
		"type": "undefined"
	},
	"mystique/Int": {
		"location": "mystique/Int",
		"type": "undefined"
	},
	"mystique/Equal": {
		"location": "mystique/Equal",
		"type": "undefined"
	},
	"mystique/Float": {
		"location": "mystique/Float",
		"type": "undefined"
	},
	"mystique/GreaterThan": {
		"location": "mystique/GreaterThan",
		"type": "undefined"
	},
	"mystique/GreaterThanEqual": {
		"location": "mystique/GreaterThanEqual",
		"type": "undefined"
	},
	"mystique/LessThan": {
		"location": "mystique/LessThan",
		"type": "undefined"
	},
	"mystique/LessThanEqual": {
		"location": "mystique/LessThanEqual",
		"type": "undefined"
	},
	"mystique/NotEqual": {
		"location": "mystique/NotEqual",
		"type": "undefined"
	},
	"mystique/Regex": {
		"location": "mystique/Regex",
		"type": "undefined"
	},
	"mystique/Slug": {
		"location": "mystique/Slug",
		"type": "undefined"
	},
	"mystique/String": {
		"location": "mystique/String",
		"type": "undefined"
	},
	"havok/router/config": {
		"location": "havok/router/config",
		"type": "object",
		"properties": [
			{
				"name": "di",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/router/config"
			}
		]
	},
	"havok/router/config.di": {
		"location": "havok/router/config.di",
		"type": "object",
		"properties": [
			{
				"name": "havok/router/router",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/router/config"
			}
		]
	},
	"havok/store/JsonRest": {
		"location": "havok/store/JsonRest",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/store/JsonRest",
		"mixins": [
			"dojo/store/JsonRest"
		],
		"parameters": [
			{
				"name": "options",
				"types": [
					"dojo/store/JsonRest"
				],
				"usage": "required",
				"summary": "<p>This provides any configuration information that will be mixed into the store</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>A standard dojo/store/JsonRest store with a few\ntweaks to make it work better with zf2 services</p>\n",
		"properties": [
			{
				"name": "-chains-",
				"scope": "prototype",
				"types": [
					"object"
				],
				"from": "havok/store/JsonRest"
			},
			{
				"name": "accepts",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>Defines the Accept header to use on HTTP requests</p>\n"
			},
			{
				"name": "ascendingPrefix",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>The prefix to apply to sort attribute names that are ascending</p>\n"
			},
			{
				"name": "descendingPrefix",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>The prefix to apply to sort attribute names that are ascending</p>\n"
			},
			{
				"name": "headers",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "havok/store/JsonRest",
				"summary": "<p>Additional headers to pass in all requests to the server. These can be overridden\nby passing additional headers to calls to the store.</p>\n"
			},
			{
				"name": "idProperty",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>Indicates the property to use as the identity property. The values of this\nproperty should be unique.</p>\n"
			},
			{
				"name": "queryEngine",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If the store can be queried locally (on the client side in JS), this defines\nthe query engine to use for querying the data store.\nThis takes a query and query options and returns a function that can execute\nthe provided query on a JavaScript array. The queryEngine may be replace to\nprovide more sophisticated querying capabilities. For example:\n\n</p>\n<pre><code>var query = store.queryEngine({foo:&quot;bar&quot;}, {count:10});\nquery(someArray) -&gt; filtered array</code></pre>\n<p>The returned query function may have a &quot;matches&quot; property that can be\n\n</p>\n<p>used to determine if an object matches the query. For example:\n\n</p>\n<pre><code>query.matches({id:&quot;some-object&quot;, foo:&quot;bar&quot;}) -&gt; true\nquery.matches({id:&quot;some-object&quot;, foo:&quot;something else&quot;}) -&gt; false</code></pre>\n"
			},
			{
				"name": "target",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>The target base URL to use for all requests to the server. This string will be\nprepended to the id to generate the URL (relative or absolute) for requests\nsent to the server</p>\n"
			}
		],
		"methods": [
			{
				"name": "add",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Additional metadata for storing the data.  Includes an &quot;id&quot;\nproperty if a specific id is to be used.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Adds an object. This will trigger a PUT request to the server\nif the object has an id, otherwise it will trigger a POST request.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/store/JsonRest",
				"parameters": [
					{
						"name": "options",
						"types": [
							"dojo/store/JsonRest"
						],
						"usage": "required",
						"summary": "<p>This provides any configuration information that will be mixed into the store</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This is a basic store for RESTful communicating with a server through JSON\nformatted data.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to lookup the object</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>HTTP headers. For consistency with other methods, if a <code>headers</code> key exists on this object, it will be\nused to provide HTTP headers instead.</p>\n"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"returnDescription": "<p>The object in the store that matches the given id.</p>\n",
				"summary": "<p>Retrieves an object by its identity. This will trigger a GET request to the server using\nthe url <code>this.target + id</code>.</p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "parent",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to find the children of.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>Additional options to apply to the retrieval of the children.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"returnDescription": "<p>A result set of the children of the parent object.</p>\n",
				"summary": "<p>Retrieves the children of an object.</p>\n"
			},
			{
				"name": "getIdentity",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to get the identity from</p>\n"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Returns an object&#39;s identity</p>\n"
			},
			{
				"name": "getMetadata",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to return metadata for.</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>An object containing metadata.</p>\n",
				"summary": "<p>Returns any metadata about the object. This may include attribution,\ncache directives, history, or version information.</p>\n"
			},
			{
				"name": "put",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Additional metadata for storing the data.  Includes an &quot;id&quot;\nproperty if a specific id is to be used.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"dojo/_base/Deferred",
					"undefined"
				],
				"summary": "<p>Stores an object. This will trigger a PUT request to the server\nif the object has an id, otherwise it will trigger a POST request.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "query",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The query to use for retrieving objects from the store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The optional arguments to apply to the resultset.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults",
					"undefined"
				],
				"returnDescription": "<p>The results of the query, extended with iterative methods.</p>\n",
				"summary": "<p>Queries the store for objects. This will trigger a GET request to the server, with the\nquery added as a query string.</p>\n"
			},
			{
				"name": "remove",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "havok/store/JsonRest",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to delete the object</p>\n"
					},
					{
						"name": "options",
						"types": [
							"__HeaderOptions"
						],
						"usage": "optional",
						"summary": "<p>HTTP headers.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deletes an object by its identity. This will trigger a DELETE request to the server.</p>\n"
			},
			{
				"name": "transaction",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": [
					"dojo/store/api/Store.Transaction"
				],
				"returnDescription": "<p>This represents the new current transaction.</p>\n",
				"summary": "<p>Starts a new transaction.\nNote that a store user might not call transaction() prior to using put,\ndelete, etc. in which case these operations effectively could be thought of\nas &quot;auto-commit&quot; style actions.</p>\n"
			}
		]
	},
	"dojo/_base/xhr": {
		"location": "dojo/_base/xhr",
		"type": "function",
		"parameters": [
			{
				"name": "method",
				"types": [
					"String"
				],
				"usage": "required",
				"summary": "<p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.</p>\n"
			},
			{
				"name": "args",
				"types": [
					"Object"
				],
				"usage": "required",
				"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
			},
			{
				"name": "hasBody",
				"types": [
					"Boolean"
				],
				"usage": "optional",
				"summary": "<p>If the request has an HTTP body, then pass true for hasBody.</p>\n"
			}
		],
		"returnTypes": [
			"undefined"
		],
		"summary": "<p>Deprecated.   Use dojo/request instead.</p>\n",
		"description": "<p>Sends an HTTP request with the given method.\nSee also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts\nfor those HTTP methods. There are also methods for &quot;raw&quot; PUT and POST methods\nvia dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</p>\n",
		"properties": [
			{
				"name": "contentHandlers",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "dojo/_base/xhr",
				"summary": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls.</p>\n",
				"description": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls. Each contentHandler is\ncalled, passing the xhr object for manipulation. The return value\nfrom the contentHandler will be passed to the <code>load</code> or <code>handle</code>\nfunctions defined in the original xhr call.</p>\n",
				"examples": [
					"<p>Creating a custom content-handler:\n\n</p>\n<pre><code>xhr.contentHandlers.makeCaps = function(xhr){\n    return xhr.responseText.toUpperCase();\n}\n// and later:\ndojo.xhrGet({\n    url:&quot;foo.txt&quot;,\n    handleAs:&quot;makeCaps&quot;,\n    load: function(data){ /* data is a toUpper version of foo.txt */ }\n});</code></pre>\n"
				]
			}
		],
		"methods": [
			{
				"name": "_getText",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [
					{
						"name": "url",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_ioAddQueryToUrl",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [
					{
						"name": "ioArgs",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>args (Object): <p>the original object argument to the IO call.</p>\n</li><li>xhr (XMLHttpRequest): <p>For XMLHttpRequest calls only, the\nXMLHttpRequest object that was used for the\nrequest.</p>\n</li><li>url (String): <p>The final URL used for the call. Many times it\nwill be different than the original args.url\nvalue.</p>\n</li><li>query (String): <p>For non-GET requests, the\nname1=value1&amp;name2=value2 parameters sent up in\nthe request.</p>\n</li><li>handleAs (String): <p>The final indicator on how the response will be\nhandled.</p>\n</li><li>id (String): <p>For dojo/io/script calls only, the internal\nscript ID used for the request.</p>\n</li><li>canDelete (Boolean): <p>For dojo/io/script calls only, indicates\nwhether the script tag that represents the\nrequest can be deleted after callbacks have\nbeen called. Used internally to know when\ncleanup can happen on JSONP-type requests.</p>\n</li><li>json (Object): <p>For dojo/io/script calls only: holds the JSON\nresponse for JSONP-type requests. Used\ninternally to hold on to the JSON responses.\nYou should not need to access it directly --\nthe same object should be passed to the success\ncallbacks directly.</p>\n</li></ul>"
					}
				],
				"returnTypes": [],
				"summary": "<p>Adds query params discovered by the io deferred construction to the URL.\nOnly use this for operations which are fundamentally GET-type operations.</p>\n"
			},
			{
				"name": "_ioCancelAll",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Cancels all pending IO requests, regardless of IO type\n(xhr, script, iframe).</p>\n"
			},
			{
				"name": "_ioNotifyStart",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [
					{
						"name": "dfd",
						"types": [
							"dojo/_base/Deferred"
						],
						"usage": "required"
					}
				],
				"returnTypes": [],
				"summary": "<p>If dojo.publish is available, publish topics\nabout the start of a request queue and/or the\nthe beginning of request.\n\n</p>\n<p>Used by IO transports. An IO transport should\ncall this method before making the network connection.</p>\n"
			},
			{
				"name": "_ioSetArgs",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [
					{
						"name": "args",
						"types": [
							"dojo/main.__IoArgs"
						],
						"usage": "required",
						"summary": "<p>The args object passed into the public io call. Recognized properties on\nthe args object are:</p>\n"
					},
					{
						"name": "canceller",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The canceller function used for the Deferred object. The function\nwill receive one argument, the Deferred object that is related to the\ncanceller.</p>\n"
					},
					{
						"name": "okHandler",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The first OK callback to be registered with Deferred. It has the opportunity\nto transform the OK response. It will receive one argument -- the Deferred\nobject returned from this function.</p>\n"
					},
					{
						"name": "errHandler",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>The first error callback to be registered with Deferred. It has the opportunity\nto do cleanup on an error. It will receive two arguments: error (the\nError object) and dfd, the Deferred object returned from this function.</p>\n"
					}
				],
				"returnTypes": [
					"instance"
				],
				"summary": "<p>sets up the Deferred and ioArgs property on the Deferred so it\ncan be used in an io call.</p>\n"
			},
			{
				"name": "_ioWatch",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [
					{
						"name": "dfd",
						"types": [
							"dojo/_base/Deferred"
						],
						"usage": "required",
						"summary": "<p>The Deferred object to watch.</p>\n"
					},
					{
						"name": "validCheck",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function used to check if the IO request is still valid. Gets the dfd\nobject as its only argument.</p>\n"
					},
					{
						"name": "ioCheck",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function used to check if basic IO call worked. Gets the dfd\nobject as its only argument.</p>\n"
					},
					{
						"name": "resHandle",
						"types": [
							"Function"
						],
						"usage": "required",
						"summary": "<p>Function used to process response. Gets the dfd\nobject as its only argument.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Watches the io request represented by dfd to see if it completes.</p>\n"
			},
			{
				"name": "_isDocumentOk",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [
					{
						"name": "x",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "_xhrObj",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "method",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>HTTP method to be used, such as GET, POST, PUT, DELETE. Should be uppercase.</p>\n"
					},
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					},
					{
						"name": "hasBody",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If the request has an HTTP body, then pass true for hasBody.</p>\n"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deprecated.   Use dojo/request instead.</p>\n",
				"description": "<p>Sends an HTTP request with the given method.\nSee also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts\nfor those HTTP methods. There are also methods for &quot;raw&quot; PUT and POST methods\nvia dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</p>\n"
			},
			{
				"name": "del",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP DELETE request to the server.</p>\n"
			},
			{
				"name": "fieldToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "inputNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"summary": "<p>Serialize a form field to a JavaScript object.</p>\n",
				"description": "<p>Returns the value encoded in a form field as\nas a string or an array of strings. Disabled form elements\nand unchecked radio and checkboxes are skipped. Multi-select\nelements are returned as an array of string values.</p>\n"
			},
			{
				"name": "formToJson",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "prettyPrint",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"summary": "<p>Create a serialized JSON string from a form node or string\nID identifying the form to serialize</p>\n"
			},
			{
				"name": "formToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Serialize a form node to a JavaScript object.</p>\n",
				"description": "<p>Returns the values encoded in an HTML form as\nstring properties in an object which it then returns. Disabled form\nelements, buttons, and other non-value form elements are skipped.\nMulti-select elements are returned as an array of string values.</p>\n",
				"examples": [
					"<p>This form:\n\n</p>\n<pre><code>&lt;form id=&quot;test_form&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;blah&quot; value=&quot;blah&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;no_value&quot; value=&quot;blah&quot; disabled&gt;\n    &lt;input type=&quot;button&quot; name=&quot;no_value2&quot; value=&quot;blah&quot;&gt;\n    &lt;select type=&quot;select&quot; multiple name=&quot;multi&quot; size=&quot;5&quot;&gt;\n        &lt;option value=&quot;blah&quot;&gt;blah&lt;/option&gt;\n        &lt;option value=&quot;thud&quot; selected&gt;thud&lt;/option&gt;\n        &lt;option value=&quot;thonk&quot; selected&gt;thonk&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/form&gt;</code></pre>\n<p>yields this object structure as the result of a call to\nformToObject():\n\n\n</p>\n<pre><code>{\n    blah: &quot;blah&quot;,\n    multi: [\n        &quot;thud&quot;,\n        &quot;thonk&quot;\n    ]\n};</code></pre>\n"
				]
			},
			{
				"name": "formToQuery",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"summary": "<p>Returns a URL-encoded string representing the form passed as either a\nnode or string ID identifying the form to serialize</p>\n"
			},
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP GET request to the server.</p>\n"
			},
			{
				"name": "objectToQuery",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "map",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>takes a name/value mapping object and returns a string representing\na URL-encoded version of that object.</p>\n",
				"examples": [
					"<p>this object:\n\n\n</p>\n<pre><code>{\n    blah: &quot;blah&quot;,\n    multi: [\n        &quot;thud&quot;,\n        &quot;thonk&quot;\n    ]\n};</code></pre>\n<p>yields the following query string:\n\n\n</p>\n<pre><code>&quot;blah=blah&amp;multi=thud&amp;multi=thonk&quot;</code></pre>\n"
				]
			},
			{
				"name": "post",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP POST request to the server. In addition to the properties\nlisted for the dojo.__XhrArgs type, the following property is allowed:</p>\n"
			},
			{
				"name": "put",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "args",
						"types": [
							"Object"
						],
						"usage": "required",
						"description": "<p>An object with the following properties:</p><ul><li>handleAs (String, optional): <p>Acceptable values are: text (default), json, json-comment-optional,\njson-comment-filtered, javascript, xml. See <code>dojo/_base/xhr.contentHandlers</code></p>\n</li><li>sync (Boolean, optional): <p>false is default. Indicates whether the request should\nbe a synchronous (blocking) request.</p>\n</li><li>headers (Object, optional): <p>Additional HTTP headers to send in the request.</p>\n</li><li>failOk (Boolean, optional): <p>false is default. Indicates whether a request should be\nallowed to fail (and therefore no console error message in\nthe event of a failure)</p>\n</li><li>contentType (String|Boolean): <p>&quot;application/x-www-form-urlencoded&quot; is default. Set to false to\nprevent a Content-Type header from being sent, or to a string\nto send a different Content-Type.</p>\n</li><li>load: <p>This function will be\ncalled on a successful HTTP response code.</p>\n</li><li>error: <p>This function will\nbe called when the request fails due to a network or server error, the url\nis invalid, etc. It will also be called if the load or handle callback throws an\nexception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications\nto continue to run even when a logic error happens in the callback, while making\nit easier to troubleshoot while in debug mode.</p>\n</li><li>handle: <p>This function will\nbe called at the end of every request, whether or not an error occurs.</p>\n</li><li>url (String): <p>URL to server endpoint.</p>\n</li><li>content (Object, optional): <p>Contains properties with string values. These\nproperties will be serialized as name1=value2 and\npassed in the request.</p>\n</li><li>timeout (Integer, optional): <p>Milliseconds to wait for the response. If this time\npasses, the then error callbacks are called.</p>\n</li><li>form (DOMNode, optional): <p>DOM node for a form. Used to extract the form values\nand send to the server.</p>\n</li><li>preventCache (Boolean, optional): <p>Default is false. If true, then a\n&quot;dojo.preventCache&quot; parameter is sent in the request\nwith a value that changes with each request\n(timestamp). Useful only with GET-type requests.</p>\n</li><li>rawBody (String, optional): <p>Sets the raw body for an HTTP request. If this is used, then the content\nproperty is ignored. This is mostly useful for HTTP methods that have\na body to their requests, like PUT or POST. This property can be used instead\nof postData and putData for dojo/_base/xhr.rawXhrPost and dojo/_base/xhr.rawXhrPut respectively.</p>\n</li><li>ioPublish (Boolean, optional): <p>Set this explicitly to false to prevent publishing of topics related to\nIO operations. Otherwise, if djConfig.ioPublish is set to true, topics\nwill be published via dojo/topic.publish() for different phases of an IO operation.\nSee dojo/main.__IoPublish for a list of topics that are published.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Sends an HTTP PUT request to the server. In addition to the properties\nlisted for the dojo.__XhrArgs type, the following property is allowed:</p>\n"
			},
			{
				"name": "queryToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Create an object representing a de-serialized query section of a\nURL. Query keys with multiple values are returned in an array.\n</p>\n",
				"examples": [
					"<p>This string:\n\n\n</p>\n<pre><code>&quot;foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;&quot;</code></pre>\n<p>results in this object structure:\n\n\n</p>\n<pre><code>{\n    foo: [ &quot;bar&quot;, &quot;baz&quot; ],\n    thinger: &quot; spaces =blah&quot;,\n    zonk: &quot;blarg&quot;\n}</code></pre>\n<p>Note that spaces and other urlencoded entities are correctly\nhandled.</p>\n"
				]
			}
		]
	},
	"dojo/_base/xhr.contentHandlers": {
		"location": "dojo/_base/xhr.contentHandlers",
		"type": "object",
		"summary": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls.</p>\n",
		"description": "<p>A map of available XHR transport handle types. Name matches the\n<code>handleAs</code> attribute passed to XHR calls. Each contentHandler is\ncalled, passing the xhr object for manipulation. The return value\nfrom the contentHandler will be passed to the <code>load</code> or <code>handle</code>\nfunctions defined in the original xhr call.</p>\n",
		"examples": [
			"<p>Creating a custom content-handler:\n\n</p>\n<pre><code>xhr.contentHandlers.makeCaps = function(xhr){\n    return xhr.responseText.toUpperCase();\n}\n// and later:\ndojo.xhrGet({\n    url:&quot;foo.txt&quot;,\n    handleAs:&quot;makeCaps&quot;,\n    load: function(data){ /* data is a toUpper version of foo.txt */ }\n});</code></pre>\n"
		],
		"methods": [
			{
				"name": "javascript",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which evaluates the response data, expecting it to be valid JavaScript</p>\n"
			},
			{
				"name": "json",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which returns a JavaScript object created from the response data</p>\n"
			},
			{
				"name": "json-comment-filtered",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which expects comment-filtered JSON.</p>\n",
				"description": "<p>A contentHandler which expects comment-filtered JSON.\nthe json-comment-filtered option was implemented to prevent\n&quot;JavaScript Hijacking&quot;, but it is less secure than standard JSON. Use\nstandard JSON instead. JSON prefixing can be used to subvert hijacking.\n\n</p>\n<p>Will throw a notice suggesting to use application/json mimetype, as\njson-commenting can introduce security issues. To decrease the chances of hijacking,\nuse the standard <code>json</code> contentHandler, and prefix your &quot;JSON&quot; with: {}&amp;&amp;\n\n</p>\n<p>use djConfig.useCommentedJson = true to turn off the notice</p>\n"
			},
			{
				"name": "json-comment-optional",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which checks the presence of comment-filtered JSON and\nalternates between the <code>json</code> and <code>json-comment-filtered</code> contentHandlers.</p>\n"
			},
			{
				"name": "text",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler which simply returns the plaintext response data</p>\n"
			},
			{
				"name": "xml",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/_base/xhr",
				"parameters": [
					{
						"name": "xhr",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>A contentHandler returning an XML Document parsed from the response data</p>\n"
			}
		]
	},
	"dojo/io-query": {
		"location": "dojo/io-query",
		"type": "object",
		"summary": "<p>This module defines query string processing functions.</p>\n",
		"methods": [
			{
				"name": "objectToQuery",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/io-query",
				"parameters": [
					{
						"name": "map",
						"types": [
							"Object"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>takes a name/value mapping object and returns a string representing\na URL-encoded version of that object.</p>\n",
				"examples": [
					"<p>this object:\n\n\n</p>\n<pre><code>{\n    blah: &quot;blah&quot;,\n    multi: [\n        &quot;thud&quot;,\n        &quot;thonk&quot;\n    ]\n};</code></pre>\n<p>yields the following query string:\n\n\n</p>\n<pre><code>&quot;blah=blah&amp;multi=thud&amp;multi=thonk&quot;</code></pre>\n"
				]
			},
			{
				"name": "queryToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/io-query",
				"parameters": [
					{
						"name": "str",
						"types": [
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Create an object representing a de-serialized query section of a\nURL. Query keys with multiple values are returned in an array.\n</p>\n",
				"examples": [
					"<p>This string:\n\n\n</p>\n<pre><code>&quot;foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;&quot;</code></pre>\n<p>results in this object structure:\n\n\n</p>\n<pre><code>{\n    foo: [ &quot;bar&quot;, &quot;baz&quot; ],\n    thinger: &quot; spaces =blah&quot;,\n    zonk: &quot;blarg&quot;\n}</code></pre>\n<p>Note that spaces and other urlencoded entities are correctly\nhandled.</p>\n"
				]
			}
		]
	},
	"dojo/dom-form": {
		"location": "dojo/dom-form",
		"type": "object",
		"summary": "<p>This module defines form-processing functions.</p>\n",
		"methods": [
			{
				"name": "fieldToObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"parameters": [
					{
						"name": "inputNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"summary": "<p>Serialize a form field to a JavaScript object.</p>\n",
				"description": "<p>Returns the value encoded in a form field as\nas a string or an array of strings. Disabled form elements\nand unchecked radio and checkboxes are skipped. Multi-select\nelements are returned as an array of string values.</p>\n"
			},
			{
				"name": "toJson",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					},
					{
						"name": "prettyPrint",
						"types": [
							"Boolean"
						],
						"usage": "optional"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"summary": "<p>Create a serialized JSON string from a form node or string\nID identifying the form to serialize</p>\n"
			},
			{
				"name": "toObject",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				],
				"summary": "<p>Serialize a form node to a JavaScript object.</p>\n",
				"description": "<p>Returns the values encoded in an HTML form as\nstring properties in an object which it then returns. Disabled form\nelements, buttons, and other non-value form elements are skipped.\nMulti-select elements are returned as an array of string values.</p>\n",
				"examples": [
					"<p>This form:\n\n</p>\n<pre><code>&lt;form id=&quot;test_form&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;blah&quot; value=&quot;blah&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;no_value&quot; value=&quot;blah&quot; disabled&gt;\n    &lt;input type=&quot;button&quot; name=&quot;no_value2&quot; value=&quot;blah&quot;&gt;\n    &lt;select type=&quot;select&quot; multiple name=&quot;multi&quot; size=&quot;5&quot;&gt;\n        &lt;option value=&quot;blah&quot;&gt;blah&lt;/option&gt;\n        &lt;option value=&quot;thud&quot; selected&gt;thud&lt;/option&gt;\n        &lt;option value=&quot;thonk&quot; selected&gt;thonk&lt;/option&gt;\n    &lt;/select&gt;\n&lt;/form&gt;</code></pre>\n<p>yields this object structure as the result of a call to\nformToObject():\n\n\n</p>\n<pre><code>{\n    blah: &quot;blah&quot;,\n    multi: [\n        &quot;thud&quot;,\n        &quot;thonk&quot;\n    ]\n};</code></pre>\n"
				]
			},
			{
				"name": "toQuery",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/dom-form",
				"parameters": [
					{
						"name": "formNode",
						"types": [
							"DOMNode",
							"String"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"String",
					"undefined"
				],
				"summary": "<p>Returns a URL-encoded string representing the form passed as either a\nnode or string ID identifying the form to serialize</p>\n"
			}
		]
	},
	"dojo/_base/json": {
		"location": "dojo/_base/json",
		"type": "object",
		"summary": "<p>This module defines the dojo JSON API.</p>\n"
	},
	"dojo/request/watch": {
		"location": "dojo/request/watch",
		"type": "function",
		"parameters": [
			{
				"name": "dfd",
				"types": [
					"Deferred"
				],
				"usage": "required",
				"summary": "<p>The Deferred object to watch.</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>Watches the io request represented by dfd to see if it completes.</p>\n",
		"properties": [
			{
				"name": "ioCheck",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/request/watch",
				"summary": "<p>Function used to check if basic IO call worked. Gets the dfd\nobject as its only argument.</p>\n"
			},
			{
				"name": "resHandle",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/request/watch",
				"summary": "<p>Function used to process response. Gets the dfd\nobject as its only argument.</p>\n"
			},
			{
				"name": "validCheck",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/request/watch",
				"summary": "<p>Function used to check if the IO request is still valid. Gets the dfd\nobject as its only argument.</p>\n"
			}
		],
		"methods": [
			{
				"name": "cancelAll",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/watch",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>Cancels all pending IO requests, regardless of IO type</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/request/watch",
				"parameters": [
					{
						"name": "dfd",
						"types": [
							"Deferred"
						],
						"usage": "required",
						"summary": "<p>The Deferred object to watch.</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>Watches the io request represented by dfd to see if it completes.</p>\n"
			}
		]
	},
	"dojo/request/util": {
		"location": "dojo/request/util",
		"type": "object",
		"methods": [
			{
				"name": "addCommonMethods",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/util",
				"parameters": [
					{
						"name": "provider",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "methods",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			},
			{
				"name": "checkStatus",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/util",
				"parameters": [
					{
						"name": "stat",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"boolean"
				]
			},
			{
				"name": "deepCopy",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/util",
				"parameters": [
					{
						"name": "target",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "source",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "deepCreate",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/util",
				"parameters": [
					{
						"name": "source",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "properties",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "deferred",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/util",
				"parameters": [
					{
						"name": "response",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object used as the value of the request promise.</p>\n"
					},
					{
						"name": "cancel",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "isValid",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "isReady",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "handleResponse",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "last",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "parseArgs",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/util",
				"parameters": [
					{
						"name": "url",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "options",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "skipData",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"object"
				]
			}
		]
	},
	"dojo/errors/RequestError": {
		"location": "dojo/errors/RequestError",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/errors/RequestError",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>TODOC</p>\n"
			}
		]
	},
	"dojo/errors/RequestTimeoutError": {
		"location": "dojo/errors/RequestTimeoutError",
		"type": "function",
		"parameters": [],
		"returnTypes": [],
		"summary": "<p>TODOC</p>\n",
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/errors/RequestTimeoutError",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>TODOC</p>\n"
			}
		]
	},
	"dojo/request/xhr": {
		"location": "dojo/request/xhr",
		"type": "function",
		"parameters": [
			{
				"name": "url",
				"types": [
					"String"
				],
				"usage": "required",
				"summary": "<p>URL to request</p>\n"
			},
			{
				"name": "options",
				"types": [
					"dojo/request/xhr.__Options"
				],
				"usage": "optional",
				"summary": "<p>Options for the request.</p>\n"
			}
		],
		"returnTypes": [
			"dojo/request.__Promise"
		],
		"summary": "<p>Sends a request using XMLHttpRequest with the given URL and options.</p>\n",
		"methods": [
			{
				"name": "__BaseOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request/xhr",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__MethodOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request/xhr",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__Options",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request/xhr",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "_create",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"private": true,
				"parameters": [],
				"returnTypes": [
					"instance"
				]
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request/xhr.__Options"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Sends a request using XMLHttpRequest with the given URL and options.</p>\n"
			},
			{
				"name": "del",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request/xhr.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP DELETE request using XMLHttpRequest with the given URL and options.</p>\n"
			},
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request/xhr.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP GET request using XMLHttpRequest with the given URL and options.</p>\n"
			},
			{
				"name": "post",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request/xhr.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP POST request using XMLHttpRequest with the given URL and options.</p>\n"
			},
			{
				"name": "put",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/xhr",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request/xhr.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP PUT request using XMLHttpRequest with the given URL and options.</p>\n"
			}
		]
	},
	"dojo/request/xhr.__BaseOptions": {
		"location": "dojo/request/xhr.__BaseOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "data",
				"scope": "prototype",
				"types": [
					"String",
					"Object",
					"FormData"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Data to transfer. This is ignored for GET and DELETE\nrequests.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request",
				"summary": "<p>How to handle the response from the server.  Default is\n&#39;text&#39;.  Other values are &#39;json&#39;, &#39;javascript&#39;, and &#39;xml&#39;.</p>\n"
			},
			{
				"name": "headers",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Headers to use for the request.</p>\n"
			},
			{
				"name": "password",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Password to use during the request.</p>\n"
			},
			{
				"name": "preventCache",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request",
				"summary": "<p>Whether to append a cache-busting parameter to the URL.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dojo/request",
				"summary": "<p>Query parameters to append to the URL.</p>\n"
			},
			{
				"name": "sync",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Whether to make a synchronous request or not. Default\nis <code>false</code> (asynchronous).</p>\n"
			},
			{
				"name": "timeout",
				"scope": "prototype",
				"types": [
					"Integer"
				],
				"from": "dojo/request",
				"summary": "<p>Milliseconds to wait for the response.  If this time\npasses, the then the promise is rejected.</p>\n"
			},
			{
				"name": "user",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Username to use during the request.</p>\n"
			},
			{
				"name": "withCredentials",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>For cross-site requests, whether to send credentials\nor not.</p>\n"
			}
		]
	},
	"dojo/request/xhr.__MethodOptions": {
		"location": "dojo/request/xhr.__MethodOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "method",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>The HTTP method to use to make the request. Must be\nuppercase. Default is <code>&quot;GET&quot;</code>.</p>\n"
			}
		]
	},
	"dojo/request/xhr.__Options": {
		"location": "dojo/request/xhr.__Options",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "data",
				"scope": "prototype",
				"types": [
					"String",
					"Object",
					"FormData"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Data to transfer. This is ignored for GET and DELETE\nrequests.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request",
				"summary": "<p>How to handle the response from the server.  Default is\n&#39;text&#39;.  Other values are &#39;json&#39;, &#39;javascript&#39;, and &#39;xml&#39;.</p>\n"
			},
			{
				"name": "headers",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Headers to use for the request.</p>\n"
			},
			{
				"name": "method",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>The HTTP method to use to make the request. Must be\nuppercase. Default is <code>&quot;GET&quot;</code>.</p>\n"
			},
			{
				"name": "password",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Password to use during the request.</p>\n"
			},
			{
				"name": "preventCache",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request",
				"summary": "<p>Whether to append a cache-busting parameter to the URL.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dojo/request",
				"summary": "<p>Query parameters to append to the URL.</p>\n"
			},
			{
				"name": "sync",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Whether to make a synchronous request or not. Default\nis <code>false</code> (asynchronous).</p>\n"
			},
			{
				"name": "timeout",
				"scope": "prototype",
				"types": [
					"Integer"
				],
				"from": "dojo/request",
				"summary": "<p>Milliseconds to wait for the response.  If this time\npasses, the then the promise is rejected.</p>\n"
			},
			{
				"name": "user",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>Username to use during the request.</p>\n"
			},
			{
				"name": "withCredentials",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request/xhr",
				"summary": "<p>For cross-site requests, whether to send credentials\nor not.</p>\n"
			}
		]
	},
	"dojo/request/handlers": {
		"location": "dojo/request/handlers",
		"type": "function",
		"parameters": [
			{
				"name": "response",
				"types": [
					"undefined"
				],
				"usage": "required"
			}
		],
		"returnTypes": [
			"undefined"
		],
		"methods": [
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/request/handlers",
				"parameters": [
					{
						"name": "response",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "register",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request/handlers",
				"parameters": [
					{
						"name": "name",
						"types": [
							"undefined"
						],
						"usage": "required"
					},
					{
						"name": "handler",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": []
			}
		]
	},
	"dojo/request": {
		"location": "dojo/request",
		"type": "function",
		"parameters": [
			{
				"name": "url",
				"types": [
					"String"
				],
				"usage": "required",
				"summary": "<p>The URL to request.</p>\n"
			},
			{
				"name": "options",
				"types": [
					"dojo/request.__Options"
				],
				"usage": "optional",
				"summary": "<p>Options for the request.</p>\n"
			}
		],
		"returnTypes": [
			"dojo/request.__Promise"
		],
		"summary": "<p>Send a request using the default transport for the current platform.</p>\n",
		"methods": [
			{
				"name": "__BaseOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__MethodOptions",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__Options",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "__Promise",
				"scope": "normal",
				"types": [
					"constructor"
				],
				"from": "dojo/request",
				"private": true,
				"parameters": [],
				"returnTypes": []
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/request",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>The URL to request.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request.__Options"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send a request using the default transport for the current platform.</p>\n"
			},
			{
				"name": "del",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP DELETE request using the default transport for the current platform.</p>\n"
			},
			{
				"name": "get",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP GET request using the default transport for the current platform.</p>\n"
			},
			{
				"name": "post",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP POST request using the default transport for the current platform.</p>\n"
			},
			{
				"name": "put",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "dojo/request",
				"parameters": [
					{
						"name": "url",
						"types": [
							"String"
						],
						"usage": "required",
						"summary": "<p>URL to request</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/request.__BaseOptions"
						],
						"usage": "optional",
						"summary": "<p>Options for the request.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/request.__Promise"
				],
				"summary": "<p>Send an HTTP POST request using the default transport for the current platform.</p>\n"
			}
		]
	},
	"dojo/request.__Promise": {
		"location": "dojo/request.__Promise",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/promise/Promise",
		"mixins": [
			"dojo/promise/Promise"
		],
		"parameters": [],
		"returnTypes": [],
		"properties": [
			{
				"name": "response",
				"scope": "prototype",
				"types": [
					"dojo/promise/Promise"
				],
				"from": "dojo/request",
				"summary": "<p>A promise resolving to an object representing\nthe response from the server.</p>\n"
			}
		],
		"methods": [
			{
				"name": "always",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "callbackOrErrback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>A function that is used both as a callback and errback.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Returns a new promise for the result of the callback/errback.</p>\n",
				"summary": "<p>Add a callback to be invoked when the promise is resolved\nor rejected.</p>\n"
			},
			{
				"name": "cancel",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "reason",
						"types": [
							"any"
						],
						"usage": "required",
						"summary": "<p>A message that may be sent to the deferred&#39;s canceler,\nexplaining why it&#39;s being canceled.</p>\n"
					},
					{
						"name": "strict",
						"types": [
							"Boolean"
						],
						"usage": "optional",
						"summary": "<p>If strict, will throw an error if the deferred has already\nbeen fulfilled and consequently cannot be canceled.</p>\n"
					}
				],
				"returnTypes": [
					"any"
				],
				"returnDescription": "<p>Returns the rejection reason if the deferred was canceled\nnormally.</p>\n",
				"summary": "<p>Inform the deferred it may cancel its asynchronous operation.</p>\n",
				"description": "<p>Inform the deferred it may cancel its asynchronous operation.\nThe deferred&#39;s (optional) canceler is invoked and the\ndeferred will be left in a rejected state. Can affect other\npromises that originate with the same deferred.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [],
				"summary": "<p>The public interface to a deferred.</p>\n",
				"description": "<p>The public interface to a deferred. All promises in Dojo are\ninstances of this class.</p>\n"
			},
			{
				"name": "isCanceled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been canceled.</p>\n"
			},
			{
				"name": "isFulfilled",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been resolved or rejected.</p>\n"
			},
			{
				"name": "isRejected",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been rejected.</p>\n"
			},
			{
				"name": "isResolved",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"Boolean"
				],
				"summary": "<p>Checks whether the promise has been resolved.</p>\n"
			},
			{
				"name": "otherwise",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise",
					"undefined"
				],
				"returnDescription": "<p>Returns a new promise for the result of the errback.</p>\n",
				"summary": "<p>Add new errbacks to the promise.</p>\n"
			},
			{
				"name": "then",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [
					{
						"name": "callback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is resolved.\nReceives the resolution value.</p>\n"
					},
					{
						"name": "errback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise is rejected.\nReceives the rejection error.</p>\n"
					},
					{
						"name": "progback",
						"types": [
							"Function"
						],
						"usage": "optional",
						"summary": "<p>Callback to be invoked when the promise emits a progress\nupdate. Receives the progress update.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/promise/Promise"
				],
				"returnDescription": "<p>Returns a new promise for the result of the callback(s).\nThis can be used for chaining many asynchronous operations.</p>\n",
				"summary": "<p>Add new callbacks to the promise.</p>\n",
				"description": "<p>Add new callbacks to the deferred. Callbacks can be added\nbefore or after the deferred is fulfilled.</p>\n"
			},
			{
				"name": "toString",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"string"
				],
				"returnDescription": "<p>Returns <code>[object Promise]</code>.</p>\n"
			},
			{
				"name": "trace",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"function"
				]
			},
			{
				"name": "traceRejected",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/promise/Promise",
				"parameters": [],
				"returnTypes": [
					"function"
				]
			}
		]
	},
	"dojo/request.__BaseOptions": {
		"location": "dojo/request.__BaseOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "data",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dojo/request",
				"summary": "<p>Data to transfer.  This is ignored for GET and DELETE\nrequests.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request",
				"summary": "<p>How to handle the response from the server.  Default is\n&#39;text&#39;.  Other values are &#39;json&#39;, &#39;javascript&#39;, and &#39;xml&#39;.</p>\n"
			},
			{
				"name": "preventCache",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request",
				"summary": "<p>Whether to append a cache-busting parameter to the URL.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dojo/request",
				"summary": "<p>Query parameters to append to the URL.</p>\n"
			},
			{
				"name": "timeout",
				"scope": "prototype",
				"types": [
					"Integer"
				],
				"from": "dojo/request",
				"summary": "<p>Milliseconds to wait for the response.  If this time\npasses, the then the promise is rejected.</p>\n"
			}
		]
	},
	"dojo/request.__MethodOptions": {
		"location": "dojo/request.__MethodOptions",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "method",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request",
				"summary": "<p>The HTTP method to use to make the request.  Must be\nuppercase.</p>\n"
			}
		]
	},
	"dojo/request.__Options": {
		"location": "dojo/request.__Options",
		"type": "constructor",
		"classlike": true,
		"properties": [
			{
				"name": "data",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dojo/request",
				"summary": "<p>Data to transfer.  This is ignored for GET and DELETE\nrequests.</p>\n"
			},
			{
				"name": "handleAs",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request",
				"summary": "<p>How to handle the response from the server.  Default is\n&#39;text&#39;.  Other values are &#39;json&#39;, &#39;javascript&#39;, and &#39;xml&#39;.</p>\n"
			},
			{
				"name": "method",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/request",
				"summary": "<p>The HTTP method to use to make the request.  Must be\nuppercase.</p>\n"
			},
			{
				"name": "preventCache",
				"scope": "prototype",
				"types": [
					"Boolean"
				],
				"from": "dojo/request",
				"summary": "<p>Whether to append a cache-busting parameter to the URL.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"String",
					"Object"
				],
				"from": "dojo/request",
				"summary": "<p>Query parameters to append to the URL.</p>\n"
			},
			{
				"name": "timeout",
				"scope": "prototype",
				"types": [
					"Integer"
				],
				"from": "dojo/request",
				"summary": "<p>Milliseconds to wait for the response.  If this time\npasses, the then the promise is rejected.</p>\n"
			}
		]
	},
	"dojo/store/JsonRest": {
		"location": "dojo/store/JsonRest",
		"type": "constructor",
		"classlike": true,
		"superclass": "dojo/store/api/Store",
		"mixins": [
			"dojo/store/api/Store"
		],
		"parameters": [
			{
				"name": "options",
				"types": [
					"dojo/store/JsonRest"
				],
				"usage": "required",
				"summary": "<p>This provides any configuration information that will be mixed into the store</p>\n"
			}
		],
		"returnTypes": [],
		"summary": "<p>This is a basic store for RESTful communicating with a server through JSON\nformatted data. It implements dojo/store/api/Store.</p>\n",
		"properties": [
			{
				"name": "accepts",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>Defines the Accept header to use on HTTP requests</p>\n"
			},
			{
				"name": "ascendingPrefix",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>The prefix to apply to sort attribute names that are ascending</p>\n"
			},
			{
				"name": "descendingPrefix",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>The prefix to apply to sort attribute names that are ascending</p>\n"
			},
			{
				"name": "headers",
				"scope": "prototype",
				"types": [
					"Object"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>Additional headers to pass in all requests to the server. These can be overridden\nby passing additional headers to calls to the store.</p>\n"
			},
			{
				"name": "idProperty",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>Indicates the property to use as the identity property. The values of this\nproperty should be unique.</p>\n"
			},
			{
				"name": "queryEngine",
				"scope": "prototype",
				"types": [
					"Function"
				],
				"from": "dojo/store/api/Store",
				"summary": "<p>If the store can be queried locally (on the client side in JS), this defines\nthe query engine to use for querying the data store.\nThis takes a query and query options and returns a function that can execute\nthe provided query on a JavaScript array. The queryEngine may be replace to\nprovide more sophisticated querying capabilities. For example:\n\n</p>\n<pre><code>var query = store.queryEngine({foo:&quot;bar&quot;}, {count:10});\nquery(someArray) -&gt; filtered array</code></pre>\n<p>The returned query function may have a &quot;matches&quot; property that can be\n\n</p>\n<p>used to determine if an object matches the query. For example:\n\n</p>\n<pre><code>query.matches({id:&quot;some-object&quot;, foo:&quot;bar&quot;}) -&gt; true\nquery.matches({id:&quot;some-object&quot;, foo:&quot;something else&quot;}) -&gt; false</code></pre>\n"
			},
			{
				"name": "target",
				"scope": "prototype",
				"types": [
					"String"
				],
				"from": "dojo/store/JsonRest",
				"summary": "<p>The target base URL to use for all requests to the server. This string will be\nprepended to the id to generate the URL (relative or absolute) for requests\nsent to the server</p>\n"
			}
		],
		"methods": [
			{
				"name": "add",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Additional metadata for storing the data.  Includes an &quot;id&quot;\nproperty if a specific id is to be used.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Adds an object. This will trigger a PUT request to the server\nif the object has an id, otherwise it will trigger a POST request.</p>\n"
			},
			{
				"name": "constructor",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "options",
						"types": [
							"dojo/store/JsonRest"
						],
						"usage": "required",
						"summary": "<p>This provides any configuration information that will be mixed into the store</p>\n"
					}
				],
				"returnTypes": [],
				"summary": "<p>This is a basic store for RESTful communicating with a server through JSON\nformatted data.</p>\n"
			},
			{
				"name": "get",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to lookup the object</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>HTTP headers. For consistency with other methods, if a <code>headers</code> key exists on this object, it will be\nused to provide HTTP headers instead.</p>\n"
					}
				],
				"returnTypes": [
					"Object",
					"undefined"
				],
				"returnDescription": "<p>The object in the store that matches the given id.</p>\n",
				"summary": "<p>Retrieves an object by its identity. This will trigger a GET request to the server using\nthe url <code>this.target + id</code>.</p>\n"
			},
			{
				"name": "getChildren",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "parent",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to find the children of.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"dojo/store/api/Store.QueryOptions"
						],
						"usage": "optional",
						"summary": "<p>Additional options to apply to the retrieval of the children.</p>\n"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults"
				],
				"returnDescription": "<p>A result set of the children of the parent object.</p>\n",
				"summary": "<p>Retrieves the children of an object.</p>\n"
			},
			{
				"name": "getIdentity",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to get the identity from</p>\n"
					}
				],
				"returnTypes": [
					"Number",
					"undefined"
				],
				"summary": "<p>Returns an object&#39;s identity</p>\n"
			},
			{
				"name": "getMetadata",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to return metadata for.</p>\n"
					}
				],
				"returnTypes": [
					"Object"
				],
				"returnDescription": "<p>An object containing metadata.</p>\n",
				"summary": "<p>Returns any metadata about the object. This may include attribution,\ncache directives, history, or version information.</p>\n"
			},
			{
				"name": "put",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "object",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The object to store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>Additional metadata for storing the data.  Includes an &quot;id&quot;\nproperty if a specific id is to be used.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"dojo/_base/Deferred",
					"undefined"
				],
				"summary": "<p>Stores an object. This will trigger a PUT request to the server\nif the object has an id, otherwise it will trigger a POST request.</p>\n"
			},
			{
				"name": "query",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "query",
						"types": [
							"Object"
						],
						"usage": "required",
						"summary": "<p>The query to use for retrieving objects from the store.</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>The optional arguments to apply to the resultset.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"dojo/store/api/Store.QueryResults",
					"undefined"
				],
				"returnDescription": "<p>The results of the query, extended with iterative methods.</p>\n",
				"summary": "<p>Queries the store for objects. This will trigger a GET request to the server, with the\nquery added as a query string.</p>\n"
			},
			{
				"name": "remove",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/JsonRest",
				"parameters": [
					{
						"name": "id",
						"types": [
							"Number"
						],
						"usage": "required",
						"summary": "<p>The identity to use to delete the object</p>\n"
					},
					{
						"name": "options",
						"types": [
							"Object"
						],
						"usage": "optional",
						"summary": "<p>HTTP headers.</p>\n",
						"description": "<p>An object with the following properties:</p><ul><li>headers (Object, optional): <p>Additional headers to send along with the request.</p>\n</li><li>id (String|Number, optional): <p>Indicates the identity of the object if a new object is created</p>\n</li><li>before (Object, optional): <p>If the collection of objects in the store has a natural ordering,\nthis indicates that the created or updated object should be placed before the\nobject specified by the value of this property. A value of null indicates that the\nobject should be last.</p>\n</li><li>parent: <p>If the store is hierarchical (with single parenting) this property indicates the\nnew parent of the created or updated object.</p>\n</li><li>overwrite (Boolean, optional): <p>If this is provided as a boolean it indicates that the object should or should not\noverwrite an existing object. A value of true indicates that a new object\nshould not be created, the operation should update an existing object. A\nvalue of false indicates that an existing object should not be updated, a new\nobject should be created (which is the same as an add() operation). When\nthis property is not provided, either an update or creation is acceptable.</p>\n</li><li>sort (dojo/store/api/Store.SortInformation[], optional): <p>A list of attributes to sort on, as well as direction\nFor example:\n\n</p>\n<pre><code>[{attribute:&quot;price, descending: true}].</code></pre>\n<p>If the sort parameter is omitted, then the natural order of the store may be\n\n</p>\n<p>applied if there is a natural order.</p>\n</li><li>start (Number, optional): <p>The first result to begin iteration on</p>\n</li><li>count (Number, optional): <p>The number of how many results should be returned.</p>\n</li></ul>"
					}
				],
				"returnTypes": [
					"undefined"
				],
				"summary": "<p>Deletes an object by its identity. This will trigger a DELETE request to the server.</p>\n"
			},
			{
				"name": "transaction",
				"scope": "prototype",
				"types": [
					"function"
				],
				"from": "dojo/store/api/Store",
				"parameters": [],
				"returnTypes": [
					"dojo/store/api/Store.Transaction"
				],
				"returnDescription": "<p>This represents the new current transaction.</p>\n",
				"summary": "<p>Starts a new transaction.\nNote that a store user might not call transaction() prior to using put,\ndelete, etc. in which case these operations effectively could be thought of\nas &quot;auto-commit&quot; style actions.</p>\n"
			}
		]
	},
	"havok/store/config": {
		"location": "havok/store/config",
		"type": "object",
		"properties": [
			{
				"name": "di",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/store/config"
			}
		]
	},
	"havok/store/config.di": {
		"location": "havok/store/config.di",
		"type": "object",
		"properties": [
			{
				"name": "havok/store/manager",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/store/config"
			},
			{
				"name": "havok/store/stores",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/store/config"
			}
		]
	},
	"havok/validator/config": {
		"location": "havok/validator/config",
		"type": "object",
		"properties": [
			{
				"name": "di",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/validator/config"
			}
		]
	},
	"havok/validator/config.di": {
		"location": "havok/validator/config.di",
		"type": "object",
		"properties": [
			{
				"name": "havok/validator/factory",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/validator/config"
			},
			{
				"name": "mystique/Chain",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/validator/config"
			}
		]
	},
	"havok/validator/factory": {
		"location": "havok/validator/factory",
		"type": "object",
		"properties": [
			{
				"name": "abreviations",
				"scope": "normal",
				"types": [
					"Array"
				],
				"from": "havok/validator/factory"
			}
		],
		"methods": [
			{
				"name": "create",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/validator/factory",
				"parameters": [
					{
						"name": "config",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"undefined"
				]
			},
			{
				"name": "expand",
				"scope": "normal",
				"types": [
					"function"
				],
				"from": "havok/validator/factory",
				"parameters": [
					{
						"name": "base",
						"types": [
							"undefined"
						],
						"usage": "required"
					}
				],
				"returnTypes": [
					"string",
					"undefined"
				]
			}
		]
	},
	"havok/widget/config": {
		"location": "havok/widget/config",
		"type": "object",
		"properties": [
			{
				"name": "di",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/widget/config"
			}
		]
	},
	"havok/widget/config.di": {
		"location": "havok/widget/config.di",
		"type": "object",
		"properties": [
			{
				"name": "havok/store/stores",
				"scope": "normal",
				"types": [
					"object"
				],
				"from": "havok/widget/config"
			}
		]
	},
	"havok/widget/dragData": {
		"location": "havok/widget/dragData",
		"type": "object"
	}
}